{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ormar Overview The ormar package is an async mini ORM for Python, with support for Postgres, MySQL , and SQLite . The main benefit of using ormar are: getting an async ORM that can be used with async frameworks (fastapi, starlette etc.) getting just one model to maintain - you don't have to maintain pydantic and other orm model (sqlalchemy, peewee, gino etc.) The goal was to create a simple ORM that can be used directly (as request and response models) with fastapi that bases it's data validation on pydantic. Ormar - apart form obvious ORM in name - get it's name from ormar in swedish which means snakes, and ormar(e) in italian which means cabinet. And what's a better name for python ORM than snakes cabinet :) If you like ormar remember to star the repository in github ! The bigger community we build, the easier it will be to catch bugs and attract contributors ;) Documentation Check out the documentation for details. Note that for brevity most of the documentation snippets omit the creation of the database and scheduling the execution of functions for asynchronous run. If you want more real life examples than in the documentation you can see tests folder, since they actually have to create and connect to database in most of the tests. Yet remember that those are - well - tests and not all solutions are suitable to be used in real life applications. Part of the fastapi ecosystem As part of the fastapi ecosystem ormar is supported in libraries that somehow work with databases. As of now ormar is supported by: fastapi-users fastapi-crudrouter fastapi-pagination If you maintain or use different library and would like it to support ormar let us know how we can help. Dependencies Ormar is built with: sqlalchemy core for query building. databases for cross-database async support. pydantic for data validation. typing_extensions for python 3.6 - 3.7 License ormar is built as an open-sorce software and remain completely free (MIT license). As I write open-source code to solve everyday problems in my work or to promote and build strong python community you can say thank you and buy me a coffee or sponsor me with a monthly amount to help ensure my work remains free and maintained. Sponsor Migrating from sqlalchemy and existing databases If you currently use sqlalchemy and would like to switch to ormar check out the auto-translation tool that can help you with translating existing sqlalchemy orm models so you do not have to do it manually. Beta versions available at github: sqlalchemy-to-ormar or simply pip install sqlalchemy-to-ormar sqlalchemy-to-ormar can be used in pair with sqlacodegen to auto-map/ generate ormar models from existing database, even if you don't use the sqlalchemy for your project. Migrations & Database creation Because ormar is built on SQLAlchemy core, you can use alembic to provide database migrations (and you really should for production code). For tests and basic applications the sqlalchemy is more than enough: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # note this is just a partial snippet full working example below # 1. Imports import sqlalchemy import databases # 2. Initialization DATABASE_URL = \"sqlite:///db.sqlite\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () # Define models here # 3. Database creation and tables creation engine = sqlalchemy . create_engine ( DATABASE_URL ) metadata . create_all ( engine ) For a sample configuration of alembic and more information regarding migrations and database creation visit migrations documentation section. Package versions ormar is still under development: We recommend pinning any dependencies (with i.e. ormar~=0.9.1 ) ormar also follows the release numeration that breaking changes bump the major number, while other changes and fixes bump minor number, so with the latter you should be safe to update, yet always read the releases docs before. example: (0.5.2 -> 0.6.0 - breaking, 0.5.2 -> 0.5.3 - non breaking) . Asynchronous Python Note that ormar is an asynchronous ORM, which means that you have to await the calls to the methods, that are scheduled for execution in an event loop. Python has a builtin module asyncio that allows you to do just that. Note that most of \"normal\" python interpreters do not allow execution of await outside of a function (cause you actually schedule this function for delayed execution and don't get the result immediately). In a modern web frameworks (like fastapi ), the framework will handle this for you, but if you plan to do this on your own you need to perform this manually like described in a quick start below. Quick Start Note that you can find the same script in examples folder on github. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 from typing import Optional import databases import pydantic import ormar import sqlalchemy DATABASE_URL = \"sqlite:///db.sqlite\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () # note that this step is optional -> all ormar cares is a internal # class with name Meta and proper parameters, but this way you do not # have to repeat the same parameters if you use only one database class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database # Note that all type hints are optional # below is a perfectly valid model declaration # class Author(ormar.Model): # class Meta(BaseMeta): # tablename = \"authors\" # # id = ormar.Integer(primary_key=True) # <= notice no field types # name = ormar.String(max_length=100) class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) # create the database # note that in production you should use migrations # note that this is not required if you connect to existing database engine = sqlalchemy . create_engine ( DATABASE_URL ) # just to be sure we clear the db before metadata . drop_all ( engine ) metadata . create_all ( engine ) # all functions below are divided into functionality categories # note how all functions are defined with async - hence can use await AND needs to # be awaited on their own async def create (): # Create some records to work with through QuerySet.create method. # Note that queryset is exposed on each Model's class as objects tolkien = await Author . objects . create ( name = \"J.R.R. Tolkien\" ) await Book . objects . create ( author = tolkien , title = \"The Hobbit\" , year = 1937 ) await Book . objects . create ( author = tolkien , title = \"The Lord of the Rings\" , year = 1955 ) await Book . objects . create ( author = tolkien , title = \"The Silmarillion\" , year = 1977 ) # alternative creation of object divided into 2 steps sapkowski = Author ( name = \"Andrzej Sapkowski\" ) # do some stuff await sapkowski . save () # or save() after initialization await Book ( author = sapkowski , title = \"The Witcher\" , year = 1990 ) . save () await Book ( author = sapkowski , title = \"The Tower of Fools\" , year = 2002 ) . save () # to read more about inserting data into the database # visit: https://collerek.github.io/ormar/queries/create/ async def read (): # Fetch an instance, without loading a foreign key relationship on it. # Django style book = await Book . objects . get ( title = \"The Hobbit\" ) # or python style book = await Book . objects . get ( Book . title == \"The Hobbit\" ) book2 = await Book . objects . first () # first() fetch the instance with lower primary key value assert book == book2 # you can access all fields on loaded model assert book . title == \"The Hobbit\" assert book . year == 1937 # when no condition is passed to get() # it behaves as last() based on primary key column book3 = await Book . objects . get () assert book3 . title == \"The Tower of Fools\" # When you have a relation, ormar always defines a related model for you # even when all you loaded is a foreign key value like in this example assert isinstance ( book . author , Author ) # primary key is populated from foreign key stored in books table assert book . author . pk == 1 # since the related model was not loaded all other fields are None assert book . author . name is None # Load the relationship from the database when you already have the related model # alternatively see joins section below await book . author . load () assert book . author . name == \"J.R.R. Tolkien\" # get all rows for given model authors = await Author . objects . all () assert len ( authors ) == 2 # to read more about reading data from the database # visit: https://collerek.github.io/ormar/queries/read/ async def update (): # read existing row from db tolkien = await Author . objects . get ( name = \"J.R.R. Tolkien\" ) assert tolkien . name == \"J.R.R. Tolkien\" tolkien_id = tolkien . id # change the selected property tolkien . name = \"John Ronald Reuel Tolkien\" # call update on a model instance await tolkien . update () # confirm that object was updated tolkien = await Author . objects . get ( name = \"John Ronald Reuel Tolkien\" ) assert tolkien . name == \"John Ronald Reuel Tolkien\" assert tolkien . id == tolkien_id # alternatively update data without loading await Author . objects . filter ( name__contains = \"Tolkien\" ) . update ( name = \"J.R.R. Tolkien\" ) # to read more about updating data in the database # visit: https://collerek.github.io/ormar/queries/update/ async def delete (): silmarillion = await Book . objects . get ( year = 1977 ) # call delete() on instance await silmarillion . delete () # alternatively delete without loading await Book . objects . delete ( title = \"The Tower of Fools\" ) # note that when there is no record ormar raises NoMatch exception try : await Book . objects . get ( year = 1977 ) except ormar . NoMatch : print ( \"No book from 1977!\" ) # to read more about deleting data from the database # visit: https://collerek.github.io/ormar/queries/delete/ # note that despite the fact that record no longer exists in database # the object above is still accessible and you can use it (and i.e. save()) again. tolkien = silmarillion . author await Book . objects . create ( author = tolkien , title = \"The Silmarillion\" , year = 1977 ) async def joins (): # Tho join two models use select_related # Django style book = await Book . objects . select_related ( \"author\" ) . get ( title = \"The Hobbit\" ) # Python style book = await Book . objects . select_related ( Book . author ) . get ( Book . title == \"The Hobbit\" ) # now the author is already prefetched assert book . author . name == \"J.R.R. Tolkien\" # By default you also get a second side of the relation # constructed as lowercase source model name +'s' (books in this case) # you can also provide custom name with parameter related_name # Django style author = await Author . objects . select_related ( \"books\" ) . all ( name = \"J.R.R. Tolkien\" ) # Python style author = await Author . objects . select_related ( Author . books ) . all ( Author . name == \"J.R.R. Tolkien\" ) assert len ( author [ 0 ] . books ) == 3 # for reverse and many to many relations you can also prefetch_related # that executes a separate query for each of related models # Django style author = await Author . objects . prefetch_related ( \"books\" ) . get ( name = \"J.R.R. Tolkien\" ) # Python style author = await Author . objects . prefetch_related ( Author . books ) . get ( Author . name == \"J.R.R. Tolkien\" ) assert len ( author . books ) == 3 # to read more about relations # visit: https://collerek.github.io/ormar/relations/ # to read more about joins and subqueries # visit: https://collerek.github.io/ormar/queries/joins-and-subqueries/ async def filter_and_sort (): # to filter the query you can use filter() or pass key-value pars to # get(), all() etc. # to use special methods or access related model fields use double # underscore like to filter by the name of the author use author__name # Django style books = await Book . objects . all ( author__name = \"J.R.R. Tolkien\" ) # python style books = await Book . objects . all ( Book . author . name == \"J.R.R. Tolkien\" ) assert len ( books ) == 3 # filter can accept special methods also separated with double underscore # to issue sql query ` where authors.name like \"%tolkien%\"` that is not # case sensitive (hence small t in Tolkien) # Django style books = await Book . objects . filter ( author__name__icontains = \"tolkien\" ) . all () # python style books = await Book . objects . filter ( Book . author . name . icontains ( \"tolkien\" )) . all () assert len ( books ) == 3 # to sort use order_by() function of queryset # to sort decreasing use hyphen before the field name # same as with filter you can use double underscores to access related fields # Django style books = ( await Book . objects . filter ( author__name__icontains = \"tolkien\" ) . order_by ( \"-year\" ) . all () ) # python style books = ( await Book . objects . filter ( Book . author . name . icontains ( \"tolkien\" )) . order_by ( Book . year . desc ()) . all () ) assert len ( books ) == 3 assert books [ 0 ] . title == \"The Silmarillion\" assert books [ 2 ] . title == \"The Hobbit\" # to read more about filtering and ordering # visit: https://collerek.github.io/ormar/queries/filter-and-sort/ async def subset_of_columns (): # to exclude some columns from loading when querying the database # you can use fileds() method hobbit = await Book . objects . fields ([ \"title\" ]) . get ( title = \"The Hobbit\" ) # note that fields not included in fields are empty (set to None) assert hobbit . year is None assert hobbit . author is None # selected field is there assert hobbit . title == \"The Hobbit\" # alternatively you can provide columns you want to exclude hobbit = await Book . objects . exclude_fields ([ \"year\" ]) . get ( title = \"The Hobbit\" ) # year is still not set assert hobbit . year is None # but author is back assert hobbit . author is not None # also you cannot exclude primary key column - it's always there # even if you EXPLICITLY exclude it it will be there # note that each model have a shortcut for primary_key column which is pk # and you can filter/access/set the values by this alias like below assert hobbit . pk is not None # note that you cannot exclude fields that are not nullable # (required) in model definition try : await Book . objects . exclude_fields ([ \"title\" ]) . get ( title = \"The Hobbit\" ) except pydantic . ValidationError : print ( \"Cannot exclude non nullable field title\" ) # to read more about selecting subset of columns # visit: https://collerek.github.io/ormar/queries/select-columns/ async def pagination (): # to limit number of returned rows use limit() books = await Book . objects . limit ( 1 ) . all () assert len ( books ) == 1 assert books [ 0 ] . title == \"The Hobbit\" # to offset number of returned rows use offset() books = await Book . objects . limit ( 1 ) . offset ( 1 ) . all () assert len ( books ) == 1 assert books [ 0 ] . title == \"The Lord of the Rings\" # alternatively use paginate that combines both books = await Book . objects . paginate ( page = 2 , page_size = 2 ) . all () assert len ( books ) == 2 # note that we removed one book of Sapkowski in delete() # and recreated The Silmarillion - by default when no order_by is set # ordering sorts by primary_key column assert books [ 0 ] . title == \"The Witcher\" assert books [ 1 ] . title == \"The Silmarillion\" # to read more about pagination and number of rows # visit: https://collerek.github.io/ormar/queries/pagination-and-rows-number/ async def aggregations (): # count: assert 2 == await Author . objects . count () # exists assert await Book . objects . filter ( title = \"The Hobbit\" ) . exists () # maximum assert 1990 == await Book . objects . max ( columns = [ \"year\" ]) # minimum assert 1937 == await Book . objects . min ( columns = [ \"year\" ]) # average assert 1964.75 == await Book . objects . avg ( columns = [ \"year\" ]) # sum assert 7859 == await Book . objects . sum ( columns = [ \"year\" ]) # to read more about aggregated functions # visit: https://collerek.github.io/ormar/queries/aggregations/ async def raw_data (): # extract raw data in a form of dicts or tuples # note that this skips the validation(!) as models are # not created from parsed data # get list of objects as dicts assert await Book . objects . values () == [ { \"id\" : 1 , \"author\" : 1 , \"title\" : \"The Hobbit\" , \"year\" : 1937 }, { \"id\" : 2 , \"author\" : 1 , \"title\" : \"The Lord of the Rings\" , \"year\" : 1955 }, { \"id\" : 4 , \"author\" : 2 , \"title\" : \"The Witcher\" , \"year\" : 1990 }, { \"id\" : 5 , \"author\" : 1 , \"title\" : \"The Silmarillion\" , \"year\" : 1977 }, ] # get list of objects as tuples assert await Book . objects . values_list () == [ ( 1 , 1 , \"The Hobbit\" , 1937 ), ( 2 , 1 , \"The Lord of the Rings\" , 1955 ), ( 4 , 2 , \"The Witcher\" , 1990 ), ( 5 , 1 , \"The Silmarillion\" , 1977 ), ] # filter data - note how you always get a list assert await Book . objects . filter ( title = \"The Hobbit\" ) . values () == [ { \"id\" : 1 , \"author\" : 1 , \"title\" : \"The Hobbit\" , \"year\" : 1937 } ] # select only wanted fields assert await Book . objects . filter ( title = \"The Hobbit\" ) . values ([ \"id\" , \"title\" ]) == [ { \"id\" : 1 , \"title\" : \"The Hobbit\" } ] # if you select only one column you could flatten it with values_list assert await Book . objects . values_list ( \"title\" , flatten = True ) == [ \"The Hobbit\" , \"The Lord of the Rings\" , \"The Witcher\" , \"The Silmarillion\" , ] # to read more about extracting raw values # visit: https://collerek.github.io/ormar/queries/aggregations/ async def with_connect ( function ): # note that for any other backend than sqlite you actually need to # connect to the database to perform db operations async with database : await function () # note that if you use framework like `fastapi` you shouldn't connect # in your endpoints but have a global connection pool # check https://collerek.github.io/ormar/fastapi/ and section with db connection # gather and execute all functions # note - normally import should be at the beginning of the file import asyncio # note that normally you use gather() function to run several functions # concurrently but we actually modify the data and we rely on the order of functions for func in [ create , read , update , delete , joins , filter_and_sort , subset_of_columns , pagination , aggregations , raw_data , ]: print ( f \"Executing: { func . __name__ } \" ) asyncio . run ( with_connect ( func )) # drop the database tables metadata . drop_all ( engine ) Ormar Specification QuerySet methods create(**kwargs): -> Model get(*args, **kwargs): -> Model get_or_none(*args, **kwargs): -> Optional[Model] get_or_create(*args, **kwargs) -> Model first(*args, **kwargs): -> Model update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None bulk_update(objects: List[Model], columns: List[str] = None) -> None delete(*args, each: bool = False, **kwargs) -> int all(*args, **kwargs) -> List[Optional[Model]] filter(*args, **kwargs) -> QuerySet exclude(*args, **kwargs) -> QuerySet select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet count() -> int exists() -> bool max(columns: List[str]) -> Any min(columns: List[str]) -> Any avg(columns: List[str]) -> Any sum(columns: List[str]) -> Any fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet values(fields: Union[List, str, Set, Dict]) values_list(fields: Union[List, str, Set, Dict]) Relation types One to many - with ForeignKey(to: Model) Many to many - with ManyToMany(to: Model, Optional[through]: Model) Model fields types Available Model Fields (with required args - optional ones in docs): String(max_length) Text() Boolean() Integer() Float() Date() Time() DateTime() JSON() BigInteger() SmallInteger() Decimal(scale, precision) UUID() LargeBinary(max_length) EnumField - by passing choices to any other Field type EncryptedString - by passing encrypt_secret and encrypt_backend ForeignKey(to) ManyToMany(to, through) Available fields options The following keyword arguments are supported on all field types. primary_key: bool nullable: bool default: Any server_default: Any index: bool unique: bool choices: typing.Sequence name: str pydantic_only: bool All fields are required unless one of the following is set: nullable - Creates a nullable column. Sets the default to None . default - Set a default value for the field. Not available for relation fields server_default - Set a default value for the field on server side (like sqlalchemy's func.now() ). Not available for relation fields primary key with autoincrement - When a column is set to primary key and autoincrement is set on this column. Autoincrement is set by default on int primary keys. pydantic_only - Field is available only as normal pydantic field, not stored in the database. Available signals Signals allow to trigger your function for a given event on a given Model. pre_save post_save pre_update post_update pre_delete post_delete pre_relation_add post_relation_add pre_relation_remove post_relation_remove","title":"Overview"},{"location":"#ormar","text":"","title":"ormar"},{"location":"#overview","text":"The ormar package is an async mini ORM for Python, with support for Postgres, MySQL , and SQLite . The main benefit of using ormar are: getting an async ORM that can be used with async frameworks (fastapi, starlette etc.) getting just one model to maintain - you don't have to maintain pydantic and other orm model (sqlalchemy, peewee, gino etc.) The goal was to create a simple ORM that can be used directly (as request and response models) with fastapi that bases it's data validation on pydantic. Ormar - apart form obvious ORM in name - get it's name from ormar in swedish which means snakes, and ormar(e) in italian which means cabinet. And what's a better name for python ORM than snakes cabinet :) If you like ormar remember to star the repository in github ! The bigger community we build, the easier it will be to catch bugs and attract contributors ;)","title":"Overview"},{"location":"#documentation","text":"Check out the documentation for details. Note that for brevity most of the documentation snippets omit the creation of the database and scheduling the execution of functions for asynchronous run. If you want more real life examples than in the documentation you can see tests folder, since they actually have to create and connect to database in most of the tests. Yet remember that those are - well - tests and not all solutions are suitable to be used in real life applications.","title":"Documentation"},{"location":"#part-of-the-fastapi-ecosystem","text":"As part of the fastapi ecosystem ormar is supported in libraries that somehow work with databases. As of now ormar is supported by: fastapi-users fastapi-crudrouter fastapi-pagination If you maintain or use different library and would like it to support ormar let us know how we can help.","title":"Part of the fastapi ecosystem"},{"location":"#dependencies","text":"Ormar is built with: sqlalchemy core for query building. databases for cross-database async support. pydantic for data validation. typing_extensions for python 3.6 - 3.7","title":"Dependencies"},{"location":"#license","text":"ormar is built as an open-sorce software and remain completely free (MIT license). As I write open-source code to solve everyday problems in my work or to promote and build strong python community you can say thank you and buy me a coffee or sponsor me with a monthly amount to help ensure my work remains free and maintained. Sponsor","title":"License"},{"location":"#migrating-from-sqlalchemy-and-existing-databases","text":"If you currently use sqlalchemy and would like to switch to ormar check out the auto-translation tool that can help you with translating existing sqlalchemy orm models so you do not have to do it manually. Beta versions available at github: sqlalchemy-to-ormar or simply pip install sqlalchemy-to-ormar sqlalchemy-to-ormar can be used in pair with sqlacodegen to auto-map/ generate ormar models from existing database, even if you don't use the sqlalchemy for your project.","title":"Migrating from sqlalchemy and existing databases"},{"location":"#migrations-database-creation","text":"Because ormar is built on SQLAlchemy core, you can use alembic to provide database migrations (and you really should for production code). For tests and basic applications the sqlalchemy is more than enough: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # note this is just a partial snippet full working example below # 1. Imports import sqlalchemy import databases # 2. Initialization DATABASE_URL = \"sqlite:///db.sqlite\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () # Define models here # 3. Database creation and tables creation engine = sqlalchemy . create_engine ( DATABASE_URL ) metadata . create_all ( engine ) For a sample configuration of alembic and more information regarding migrations and database creation visit migrations documentation section.","title":"Migrations &amp; Database creation"},{"location":"#package-versions","text":"ormar is still under development: We recommend pinning any dependencies (with i.e. ormar~=0.9.1 ) ormar also follows the release numeration that breaking changes bump the major number, while other changes and fixes bump minor number, so with the latter you should be safe to update, yet always read the releases docs before. example: (0.5.2 -> 0.6.0 - breaking, 0.5.2 -> 0.5.3 - non breaking) .","title":"Package versions"},{"location":"#asynchronous-python","text":"Note that ormar is an asynchronous ORM, which means that you have to await the calls to the methods, that are scheduled for execution in an event loop. Python has a builtin module asyncio that allows you to do just that. Note that most of \"normal\" python interpreters do not allow execution of await outside of a function (cause you actually schedule this function for delayed execution and don't get the result immediately). In a modern web frameworks (like fastapi ), the framework will handle this for you, but if you plan to do this on your own you need to perform this manually like described in a quick start below.","title":"Asynchronous Python"},{"location":"#quick-start","text":"Note that you can find the same script in examples folder on github. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 from typing import Optional import databases import pydantic import ormar import sqlalchemy DATABASE_URL = \"sqlite:///db.sqlite\" database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () # note that this step is optional -> all ormar cares is a internal # class with name Meta and proper parameters, but this way you do not # have to repeat the same parameters if you use only one database class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database # Note that all type hints are optional # below is a perfectly valid model declaration # class Author(ormar.Model): # class Meta(BaseMeta): # tablename = \"authors\" # # id = ormar.Integer(primary_key=True) # <= notice no field types # name = ormar.String(max_length=100) class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) # create the database # note that in production you should use migrations # note that this is not required if you connect to existing database engine = sqlalchemy . create_engine ( DATABASE_URL ) # just to be sure we clear the db before metadata . drop_all ( engine ) metadata . create_all ( engine ) # all functions below are divided into functionality categories # note how all functions are defined with async - hence can use await AND needs to # be awaited on their own async def create (): # Create some records to work with through QuerySet.create method. # Note that queryset is exposed on each Model's class as objects tolkien = await Author . objects . create ( name = \"J.R.R. Tolkien\" ) await Book . objects . create ( author = tolkien , title = \"The Hobbit\" , year = 1937 ) await Book . objects . create ( author = tolkien , title = \"The Lord of the Rings\" , year = 1955 ) await Book . objects . create ( author = tolkien , title = \"The Silmarillion\" , year = 1977 ) # alternative creation of object divided into 2 steps sapkowski = Author ( name = \"Andrzej Sapkowski\" ) # do some stuff await sapkowski . save () # or save() after initialization await Book ( author = sapkowski , title = \"The Witcher\" , year = 1990 ) . save () await Book ( author = sapkowski , title = \"The Tower of Fools\" , year = 2002 ) . save () # to read more about inserting data into the database # visit: https://collerek.github.io/ormar/queries/create/ async def read (): # Fetch an instance, without loading a foreign key relationship on it. # Django style book = await Book . objects . get ( title = \"The Hobbit\" ) # or python style book = await Book . objects . get ( Book . title == \"The Hobbit\" ) book2 = await Book . objects . first () # first() fetch the instance with lower primary key value assert book == book2 # you can access all fields on loaded model assert book . title == \"The Hobbit\" assert book . year == 1937 # when no condition is passed to get() # it behaves as last() based on primary key column book3 = await Book . objects . get () assert book3 . title == \"The Tower of Fools\" # When you have a relation, ormar always defines a related model for you # even when all you loaded is a foreign key value like in this example assert isinstance ( book . author , Author ) # primary key is populated from foreign key stored in books table assert book . author . pk == 1 # since the related model was not loaded all other fields are None assert book . author . name is None # Load the relationship from the database when you already have the related model # alternatively see joins section below await book . author . load () assert book . author . name == \"J.R.R. Tolkien\" # get all rows for given model authors = await Author . objects . all () assert len ( authors ) == 2 # to read more about reading data from the database # visit: https://collerek.github.io/ormar/queries/read/ async def update (): # read existing row from db tolkien = await Author . objects . get ( name = \"J.R.R. Tolkien\" ) assert tolkien . name == \"J.R.R. Tolkien\" tolkien_id = tolkien . id # change the selected property tolkien . name = \"John Ronald Reuel Tolkien\" # call update on a model instance await tolkien . update () # confirm that object was updated tolkien = await Author . objects . get ( name = \"John Ronald Reuel Tolkien\" ) assert tolkien . name == \"John Ronald Reuel Tolkien\" assert tolkien . id == tolkien_id # alternatively update data without loading await Author . objects . filter ( name__contains = \"Tolkien\" ) . update ( name = \"J.R.R. Tolkien\" ) # to read more about updating data in the database # visit: https://collerek.github.io/ormar/queries/update/ async def delete (): silmarillion = await Book . objects . get ( year = 1977 ) # call delete() on instance await silmarillion . delete () # alternatively delete without loading await Book . objects . delete ( title = \"The Tower of Fools\" ) # note that when there is no record ormar raises NoMatch exception try : await Book . objects . get ( year = 1977 ) except ormar . NoMatch : print ( \"No book from 1977!\" ) # to read more about deleting data from the database # visit: https://collerek.github.io/ormar/queries/delete/ # note that despite the fact that record no longer exists in database # the object above is still accessible and you can use it (and i.e. save()) again. tolkien = silmarillion . author await Book . objects . create ( author = tolkien , title = \"The Silmarillion\" , year = 1977 ) async def joins (): # Tho join two models use select_related # Django style book = await Book . objects . select_related ( \"author\" ) . get ( title = \"The Hobbit\" ) # Python style book = await Book . objects . select_related ( Book . author ) . get ( Book . title == \"The Hobbit\" ) # now the author is already prefetched assert book . author . name == \"J.R.R. Tolkien\" # By default you also get a second side of the relation # constructed as lowercase source model name +'s' (books in this case) # you can also provide custom name with parameter related_name # Django style author = await Author . objects . select_related ( \"books\" ) . all ( name = \"J.R.R. Tolkien\" ) # Python style author = await Author . objects . select_related ( Author . books ) . all ( Author . name == \"J.R.R. Tolkien\" ) assert len ( author [ 0 ] . books ) == 3 # for reverse and many to many relations you can also prefetch_related # that executes a separate query for each of related models # Django style author = await Author . objects . prefetch_related ( \"books\" ) . get ( name = \"J.R.R. Tolkien\" ) # Python style author = await Author . objects . prefetch_related ( Author . books ) . get ( Author . name == \"J.R.R. Tolkien\" ) assert len ( author . books ) == 3 # to read more about relations # visit: https://collerek.github.io/ormar/relations/ # to read more about joins and subqueries # visit: https://collerek.github.io/ormar/queries/joins-and-subqueries/ async def filter_and_sort (): # to filter the query you can use filter() or pass key-value pars to # get(), all() etc. # to use special methods or access related model fields use double # underscore like to filter by the name of the author use author__name # Django style books = await Book . objects . all ( author__name = \"J.R.R. Tolkien\" ) # python style books = await Book . objects . all ( Book . author . name == \"J.R.R. Tolkien\" ) assert len ( books ) == 3 # filter can accept special methods also separated with double underscore # to issue sql query ` where authors.name like \"%tolkien%\"` that is not # case sensitive (hence small t in Tolkien) # Django style books = await Book . objects . filter ( author__name__icontains = \"tolkien\" ) . all () # python style books = await Book . objects . filter ( Book . author . name . icontains ( \"tolkien\" )) . all () assert len ( books ) == 3 # to sort use order_by() function of queryset # to sort decreasing use hyphen before the field name # same as with filter you can use double underscores to access related fields # Django style books = ( await Book . objects . filter ( author__name__icontains = \"tolkien\" ) . order_by ( \"-year\" ) . all () ) # python style books = ( await Book . objects . filter ( Book . author . name . icontains ( \"tolkien\" )) . order_by ( Book . year . desc ()) . all () ) assert len ( books ) == 3 assert books [ 0 ] . title == \"The Silmarillion\" assert books [ 2 ] . title == \"The Hobbit\" # to read more about filtering and ordering # visit: https://collerek.github.io/ormar/queries/filter-and-sort/ async def subset_of_columns (): # to exclude some columns from loading when querying the database # you can use fileds() method hobbit = await Book . objects . fields ([ \"title\" ]) . get ( title = \"The Hobbit\" ) # note that fields not included in fields are empty (set to None) assert hobbit . year is None assert hobbit . author is None # selected field is there assert hobbit . title == \"The Hobbit\" # alternatively you can provide columns you want to exclude hobbit = await Book . objects . exclude_fields ([ \"year\" ]) . get ( title = \"The Hobbit\" ) # year is still not set assert hobbit . year is None # but author is back assert hobbit . author is not None # also you cannot exclude primary key column - it's always there # even if you EXPLICITLY exclude it it will be there # note that each model have a shortcut for primary_key column which is pk # and you can filter/access/set the values by this alias like below assert hobbit . pk is not None # note that you cannot exclude fields that are not nullable # (required) in model definition try : await Book . objects . exclude_fields ([ \"title\" ]) . get ( title = \"The Hobbit\" ) except pydantic . ValidationError : print ( \"Cannot exclude non nullable field title\" ) # to read more about selecting subset of columns # visit: https://collerek.github.io/ormar/queries/select-columns/ async def pagination (): # to limit number of returned rows use limit() books = await Book . objects . limit ( 1 ) . all () assert len ( books ) == 1 assert books [ 0 ] . title == \"The Hobbit\" # to offset number of returned rows use offset() books = await Book . objects . limit ( 1 ) . offset ( 1 ) . all () assert len ( books ) == 1 assert books [ 0 ] . title == \"The Lord of the Rings\" # alternatively use paginate that combines both books = await Book . objects . paginate ( page = 2 , page_size = 2 ) . all () assert len ( books ) == 2 # note that we removed one book of Sapkowski in delete() # and recreated The Silmarillion - by default when no order_by is set # ordering sorts by primary_key column assert books [ 0 ] . title == \"The Witcher\" assert books [ 1 ] . title == \"The Silmarillion\" # to read more about pagination and number of rows # visit: https://collerek.github.io/ormar/queries/pagination-and-rows-number/ async def aggregations (): # count: assert 2 == await Author . objects . count () # exists assert await Book . objects . filter ( title = \"The Hobbit\" ) . exists () # maximum assert 1990 == await Book . objects . max ( columns = [ \"year\" ]) # minimum assert 1937 == await Book . objects . min ( columns = [ \"year\" ]) # average assert 1964.75 == await Book . objects . avg ( columns = [ \"year\" ]) # sum assert 7859 == await Book . objects . sum ( columns = [ \"year\" ]) # to read more about aggregated functions # visit: https://collerek.github.io/ormar/queries/aggregations/ async def raw_data (): # extract raw data in a form of dicts or tuples # note that this skips the validation(!) as models are # not created from parsed data # get list of objects as dicts assert await Book . objects . values () == [ { \"id\" : 1 , \"author\" : 1 , \"title\" : \"The Hobbit\" , \"year\" : 1937 }, { \"id\" : 2 , \"author\" : 1 , \"title\" : \"The Lord of the Rings\" , \"year\" : 1955 }, { \"id\" : 4 , \"author\" : 2 , \"title\" : \"The Witcher\" , \"year\" : 1990 }, { \"id\" : 5 , \"author\" : 1 , \"title\" : \"The Silmarillion\" , \"year\" : 1977 }, ] # get list of objects as tuples assert await Book . objects . values_list () == [ ( 1 , 1 , \"The Hobbit\" , 1937 ), ( 2 , 1 , \"The Lord of the Rings\" , 1955 ), ( 4 , 2 , \"The Witcher\" , 1990 ), ( 5 , 1 , \"The Silmarillion\" , 1977 ), ] # filter data - note how you always get a list assert await Book . objects . filter ( title = \"The Hobbit\" ) . values () == [ { \"id\" : 1 , \"author\" : 1 , \"title\" : \"The Hobbit\" , \"year\" : 1937 } ] # select only wanted fields assert await Book . objects . filter ( title = \"The Hobbit\" ) . values ([ \"id\" , \"title\" ]) == [ { \"id\" : 1 , \"title\" : \"The Hobbit\" } ] # if you select only one column you could flatten it with values_list assert await Book . objects . values_list ( \"title\" , flatten = True ) == [ \"The Hobbit\" , \"The Lord of the Rings\" , \"The Witcher\" , \"The Silmarillion\" , ] # to read more about extracting raw values # visit: https://collerek.github.io/ormar/queries/aggregations/ async def with_connect ( function ): # note that for any other backend than sqlite you actually need to # connect to the database to perform db operations async with database : await function () # note that if you use framework like `fastapi` you shouldn't connect # in your endpoints but have a global connection pool # check https://collerek.github.io/ormar/fastapi/ and section with db connection # gather and execute all functions # note - normally import should be at the beginning of the file import asyncio # note that normally you use gather() function to run several functions # concurrently but we actually modify the data and we rely on the order of functions for func in [ create , read , update , delete , joins , filter_and_sort , subset_of_columns , pagination , aggregations , raw_data , ]: print ( f \"Executing: { func . __name__ } \" ) asyncio . run ( with_connect ( func )) # drop the database tables metadata . drop_all ( engine )","title":"Quick Start"},{"location":"#ormar-specification","text":"","title":"Ormar Specification"},{"location":"#queryset-methods","text":"create(**kwargs): -> Model get(*args, **kwargs): -> Model get_or_none(*args, **kwargs): -> Optional[Model] get_or_create(*args, **kwargs) -> Model first(*args, **kwargs): -> Model update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None bulk_update(objects: List[Model], columns: List[str] = None) -> None delete(*args, each: bool = False, **kwargs) -> int all(*args, **kwargs) -> List[Optional[Model]] filter(*args, **kwargs) -> QuerySet exclude(*args, **kwargs) -> QuerySet select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet count() -> int exists() -> bool max(columns: List[str]) -> Any min(columns: List[str]) -> Any avg(columns: List[str]) -> Any sum(columns: List[str]) -> Any fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet values(fields: Union[List, str, Set, Dict]) values_list(fields: Union[List, str, Set, Dict])","title":"QuerySet methods"},{"location":"#relation-types","text":"One to many - with ForeignKey(to: Model) Many to many - with ManyToMany(to: Model, Optional[through]: Model)","title":"Relation types"},{"location":"#model-fields-types","text":"Available Model Fields (with required args - optional ones in docs): String(max_length) Text() Boolean() Integer() Float() Date() Time() DateTime() JSON() BigInteger() SmallInteger() Decimal(scale, precision) UUID() LargeBinary(max_length) EnumField - by passing choices to any other Field type EncryptedString - by passing encrypt_secret and encrypt_backend ForeignKey(to) ManyToMany(to, through)","title":"Model fields types"},{"location":"#available-fields-options","text":"The following keyword arguments are supported on all field types. primary_key: bool nullable: bool default: Any server_default: Any index: bool unique: bool choices: typing.Sequence name: str pydantic_only: bool All fields are required unless one of the following is set: nullable - Creates a nullable column. Sets the default to None . default - Set a default value for the field. Not available for relation fields server_default - Set a default value for the field on server side (like sqlalchemy's func.now() ). Not available for relation fields primary key with autoincrement - When a column is set to primary key and autoincrement is set on this column. Autoincrement is set by default on int primary keys. pydantic_only - Field is available only as normal pydantic field, not stored in the database.","title":"Available fields options"},{"location":"#available-signals","text":"Signals allow to trigger your function for a given event on a given Model. pre_save post_save pre_update post_update pre_delete post_delete pre_relation_add post_relation_add pre_relation_remove post_relation_remove","title":"Available signals"},{"location":"contributing/","text":"All contributions to ormar are welcomed! Issues To make it as simple as possible for us to help you, please include the following: OS python version ormar version database backend (mysql, sqlite or postgresql) Please try to always include the above unless you're unable to install ormar or know it's not relevant to your question or feature request. Pull Requests It should be quite straight forward to get started and create a Pull Request. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. To make contributing as easy and fast as possible, you'll want to run tests and linting locally. You'll need to have python 3.6 , 3.7 , or 3.8 , virtualenv , and git installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 1. clone your fork and cd into the repo directory git clone git@github.com:<your username>/ormar.git cd ormar # 2. Set up a virtualenv for running tests virtualenv -p ` which python3.7 ` env source env/bin/activate # (or however you prefer to setup a python environment, 3.6 will work too) # 3. Install ormar, dependencies and test dependencies pip install -r requirements.txt # 4. Checkout a new branch and make your changes git checkout -b my-new-feature-branch # make your changes... # 5. Formatting and linting # ormar uses black for formatting, flake8 for linting and mypy for type hints check # run all of the following as all those calls will be run on travis after every push black ormar tests flake8 ormar mypy --config-file mypy.ini ormar tests # 6. Run tests # on localhost all tests are run against sglite backend # rest of the backends will be checked after push pytest -svv --cov = ormar --cov = tests --cov-fail-under = 100 --cov-report = term-missing # 7. Build documentation mkdocs build # if you have changed the documentation make sure it builds successfully # you can also use `mkdocs serve` to serve the documentation at localhost:8000 # ... commit, push, and create your pull request Tip For more information on how and why ormar works the way it works please see the API documentation","title":"Contributing"},{"location":"contributing/#issues","text":"To make it as simple as possible for us to help you, please include the following: OS python version ormar version database backend (mysql, sqlite or postgresql) Please try to always include the above unless you're unable to install ormar or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"It should be quite straight forward to get started and create a Pull Request. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. To make contributing as easy and fast as possible, you'll want to run tests and linting locally. You'll need to have python 3.6 , 3.7 , or 3.8 , virtualenv , and git installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 1. clone your fork and cd into the repo directory git clone git@github.com:<your username>/ormar.git cd ormar # 2. Set up a virtualenv for running tests virtualenv -p ` which python3.7 ` env source env/bin/activate # (or however you prefer to setup a python environment, 3.6 will work too) # 3. Install ormar, dependencies and test dependencies pip install -r requirements.txt # 4. Checkout a new branch and make your changes git checkout -b my-new-feature-branch # make your changes... # 5. Formatting and linting # ormar uses black for formatting, flake8 for linting and mypy for type hints check # run all of the following as all those calls will be run on travis after every push black ormar tests flake8 ormar mypy --config-file mypy.ini ormar tests # 6. Run tests # on localhost all tests are run against sglite backend # rest of the backends will be checked after push pytest -svv --cov = ormar --cov = tests --cov-fail-under = 100 --cov-report = term-missing # 7. Build documentation mkdocs build # if you have changed the documentation make sure it builds successfully # you can also use `mkdocs serve` to serve the documentation at localhost:8000 # ... commit, push, and create your pull request Tip For more information on how and why ormar works the way it works please see the API documentation","title":"Pull Requests"},{"location":"install/","text":"Installation Installation is as simple as: 1 pip install ormar Dependencies Ormar uses databases for connectivity issues, pydantic for validation and sqlalchemy-core for queries. All three should install along the installation of ormar if not present at your system before. databases pydantic>=1.5 sqlalchemy Optional dependencies ormar has three optional dependencies based on database backend you use: Postgresql 1 pip install ormar [ postgresql ] Will install also asyncpg and psycopg2 . Mysql 1 pip install ormar [ mysql ] Will install also aiomysql and pymysql . Sqlite 1 pip install ormar [ sqlite ] Will install also aiosqlite . Orjson 1 pip install ormar [ orjson ] Will install also orjson that is much faster than builtin json parser. Crypto 1 pip install ormar [ crypto ] Will install also cryptography that is required to work with encrypted columns. Manual installation of dependencies Of course, you can also install these requirements manually with pip install asyncpg etc.","title":"Installation"},{"location":"install/#installation","text":"Installation is as simple as: 1 pip install ormar","title":"Installation"},{"location":"install/#dependencies","text":"Ormar uses databases for connectivity issues, pydantic for validation and sqlalchemy-core for queries. All three should install along the installation of ormar if not present at your system before. databases pydantic>=1.5 sqlalchemy","title":"Dependencies"},{"location":"install/#optional-dependencies","text":"ormar has three optional dependencies based on database backend you use:","title":"Optional dependencies"},{"location":"install/#postgresql","text":"1 pip install ormar [ postgresql ] Will install also asyncpg and psycopg2 .","title":"Postgresql"},{"location":"install/#mysql","text":"1 pip install ormar [ mysql ] Will install also aiomysql and pymysql .","title":"Mysql"},{"location":"install/#sqlite","text":"1 pip install ormar [ sqlite ] Will install also aiosqlite .","title":"Sqlite"},{"location":"install/#orjson","text":"1 pip install ormar [ orjson ] Will install also orjson that is much faster than builtin json parser.","title":"Orjson"},{"location":"install/#crypto","text":"1 pip install ormar [ crypto ] Will install also cryptography that is required to work with encrypted columns.","title":"Crypto"},{"location":"install/#manual-installation-of-dependencies","text":"Of course, you can also install these requirements manually with pip install asyncpg etc.","title":"Manual installation of dependencies"},{"location":"mypy/","text":"To provide better errors check you should use mypy with pydantic plugin Note that legacy model declaration type will raise static type analyzers errors. So you cannot use the old notation like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () Instead switch to notation introduced in version 0.4.0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Note that above example is not using the type hints, so further operations with mypy might fail, depending on the context. Preferred notation should look liked this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Use with mypy"},{"location":"plugin/","text":"While ormar will work with any IDE there is a PyCharm pydantic plugin that enhances the user experience for this IDE. Plugin is available on the JetBrains Plugins Repository for PyCharm: plugin page . You can install the plugin for free from the plugin marketplace (PyCharm's Preferences -> Plugin -> Marketplace -> search \"pydantic\"). Note For plugin to work properly you need to provide valid type hints for model fields. Info Plugin supports type hints, argument inspection and more but mainly only for init methods More information can be found on the official plugin page and github repository .","title":"PyCharm plugin"},{"location":"releases/","text":"0.10.16 \u2728 Features Allow passing your own pydantic Config to ormar.Model that will be merged with the default one by @naturalethic (thanks!) #285 Add SmallInteger field type by @ProgrammerPlus1998 (thanks!) #297 \ud83d\udc1b Fixes Fix generating openapi schema by removing obsolete pydantic field parameters that were directly exposed in schema #291 Fix unnecessary warning for auto generated through models #295 0.10.15 \ud83d\udc1b Fixes Fix generating pydantic models tree with nested models (by @pawamoy - thanks!) #278 Fix missing f-string in warning about missing primary key field #274 Fix passing foreign key value as relation (additional guard, fixed already in the latest release) #270 0.10.14 \u2728 Features Allow passing timezone:bool = False parameter to DateTime and Time fields for timezone aware database columns #264 Allow passing datetime, date and time for filter on DateTime , Time and Date fields to allow filtering by datetimes instead of converting the value to string #79 \ud83d\udc1b Fixes Fix dependencies from psycopg2 to psycopg2-binary #255 0.10.13 \u2728 Features Allow passing field accessors in select_related and prefetch_related aka. python style select_related #225 . Previously: 1 2 await Post . objects . select_related ([ \"author\" , \"categories\" ]) . get () await Author . objects . prefetch_related ( \"posts__categories\" ) . get () Now also: 1 2 await Post . objects . select_related ([ Post . author , Post . categories ]) . get () await Author . objects . prefetch_related ( Author . posts . categories ) . get () \ud83d\udc1b Fixes Fix overwriting default value for inherited primary key #253 0.10.12 \ud83d\udc1b Fixes Fix QuerySet.create method not using init (if custom provided) #245 Fix ForwardRef ManyToMany relation setting wrong pydantic type #250 0.10.11 \u2728 Features Add values and values_list to QuerySet and QuerysetProxy that allows to return raw data from query #223 . Allow returning list of tuples or list of dictionaries from a query Skips parsing the data to ormar model so skips also the validation Allow excluding models in between in chain of relations, so you can extract only needed columns values_list allows you to flatten the result if you extract only one column. \ud83d\udc1b Fixes Fix creation of auto through model for m2m relation with ForwardRef #226 0.10.10 \u2728 Features Add get_pydantic flag that allows you to auto generate equivalent pydantic models tree from ormar.Model. This newly generated model tree can be used in requests and responses to exclude fields you do not want to include in the data. Add exclude_parent_fields parameter to model Meta that allows you to exclude fields from parent models during inheritance. Note that best practice is to combine models and mixins but if you have many similar models and just one that differs it might be useful tool to achieve that. \ud83d\udc1b Fixes Fix is null filter with pagination and relations (by @erichaydel) #214 Fix not saving child object on reverse side of the relation if not saved before #216 \ud83d\udcac Other Expand fastapi part of the documentation to show samples of using ormar in requests and responses in fastapi. Improve the docs in regard of default , ForeignKey.add etc. 0.10.9 Important security fix Update pin for pydantic to fix security vulnerability CVE-2021-29510 You are advised to update to version of pydantic that was patched. In 0.10.9 ormar excludes versions with vulnerability in pinned dependencies. \ud83d\udc1b Fixes Fix OpenAPi schema for LargeBinary #204 0.10.8 \ud83d\udc1b Fixes Fix populating default values in pk_only child models #202 Fix mypy for LargeBinary fields with base64 str representation #199 Fix OpenAPI schema format for LargeBinary fields with base64 str representation #199 Fix OpenAPI choices encoding for LargeBinary fields with base64 str representation 0.10.7 \u2728 Features Add exclude_primary_keys: bool = False flag to dict() method that allows to exclude all primary key columns in the resulting dictionaru. #164 Add exclude_through_models: bool = False flag to dict() that allows excluding all through models from ManyToMany relations #164 Add represent_as_base64_str: bool = False parameter that allows conversion of bytes LargeBinary field to base64 encoded string. String is returned in dict() , on access to attribute and string is converted to bytes on setting. Data in database is stored as bytes. #187 Add pk alias to allow field access by Model.pk in filters and order by clauses (python style) \ud83d\udc1b Fixes Remove default None option for max_length for LargeBinary field #186 Remove default None option for max_length for String field \ud83d\udcac Other Provide a guide and samples of dict() parameters in the docs Major refactor of getting/setting attributes from magic methods into descriptors -> noticeable performance improvement 0.10.6 \u2728 Features Add LargeBinary(max_length) field type #166 Add support for normal pydantic fields (including Models) instead of pydantic_only attribute which is now deprecated #160 . Pydantic fields should be declared normally as in pydantic model next to ormar fields, note that (obviously) ormar does not save and load the value for this field in database that mean that ONE of the following has to be true: pydantic field declared on ormar model has to be Optional (defaults to None) pydantic field has to have a default value set pydantic field has default_factory function set ormar.Model with pydantic field has to overwrite __init__() and provide the value there If none of the above ormar (or rather pydantic) will fail during loading data from the database, with missing required value for declared pydantic field. * Ormar provides now a meaningful examples in openapi schema, including nested models. The same algorithm is used to iterate related models without looks as with dict() and select/load_all . Examples appear also in fastapi . #157 \ud83d\udc1b Fixes By default pydantic is not validating fields during assignment, which is not a desirable setting for an ORM, now all ormar.Models have validation turned-on during assignment (like model.column = 'value' ) \ud83d\udcac Other Add connecting to the database in QuickStart in readme #180 OpenAPI schema does no longer include ormar.Model docstring as description, instead just model name is provided if you do not provide your own docstring. Some performance improvements. 0.10.5 \ud83d\udc1b Fixes Fix bug in fastapi-pagination #73 Remove unnecessary Optional in List[Optional[T]] in return value for QuerySet.all() and Querysetproxy.all() return values #174 Run tests coverage publish only on internal prs instead of all in github action. 0.10.4 \u2728 Features Add Python style to filter and order_by with field access instead of dunder separated strings. #51 Accessing a field with attribute access (chain of dot notation) can be used to construct FilterGroups ( ormar.and_ and ormar.or_ ) Field access overloads set of python operators and provide a set of functions to allow same functionality as with dunder separated param names in **kwargs , that means that querying from sample model Track related to model Album now you have more options: exact - exact match to value, sql column = <VALUE> OLD: album__name__exact='Malibu' NEW: can be also written as Track.album.name == 'Malibu iexact - exact match sql column = <VALUE> (case insensitive) OLD: album__name__iexact='malibu' NEW: can be also written as Track.album.name.iexact('malibu') contains - sql column LIKE '%<VALUE>%' OLD: album__name__contains='Mal' NEW: can be also written as Track.album.name % 'Mal') NEW: can be also written as Track.album.name.contains('Mal') icontains - sql column LIKE '%<VALUE>%' (case insensitive) OLD: album__name__icontains='mal' NEW: can be also written as Track.album.name.icontains('mal') in - sql column IN (<VALUE1>, <VALUE2>, ...) OLD: album__name__in=['Malibu', 'Barclay'] NEW: can be also written as Track.album.name << ['Malibu', 'Barclay'] NEW: can be also written as Track.album.name.in_(['Malibu', 'Barclay']) isnull - sql column IS NULL (and sql column IS NOT NULL ) OLD: album__name__isnull=True (isnotnull album__name__isnull=False ) NEW: can be also written as Track.album.name >> None NEW: can be also written as Track.album.name.isnull(True) NEW: not null can be also written as Track.album.name.isnull(False) NEW: not null can be also written as ~(Track.album.name >> None) NEW: not null can be also written as ~(Track.album.name.isnull(True)) gt - sql column > <VALUE> (greater than) OLD: position__gt=3 NEW: can be also written as Track.album.name > 3 gte - sql column >= <VALUE> (greater or equal than) OLD: position__gte=3 NEW: can be also written as Track.album.name >= 3 lt - sql column < <VALUE> (lower than) OLD: position__lt=3 NEW: can be also written as Track.album.name < 3 lte - sql column <= <VALUE> (lower equal than) OLD: position__lte=3 NEW: can be also written as Track.album.name <= 3 startswith - sql column LIKE '<VALUE>%' (exact start match) OLD: album__name__startswith='Mal' NEW: can be also written as Track.album.name.startswith('Mal') istartswith - sql column LIKE '<VALUE>%' (case insensitive) OLD: album__name__istartswith='mal' NEW: can be also written as Track.album.name.istartswith('mal') endswith - sql column LIKE '%<VALUE>' (exact end match) OLD: album__name__endswith='ibu' NEW: can be also written as Track.album.name.endswith('ibu') iendswith - sql column LIKE '%<VALUE>' (case insensitive) OLD: album__name__iendswith='IBU' NEW: can be also written as Track.album.name.iendswith('IBU') You can provide FilterGroups not only in filter() and exclude() but also in: get() get_or_none() get_or_create() first() all() delete() With FilterGroups ( ormar.and_ and ormar.or_ ) you can now use: & - as and_ instead of next level of nesting | - as `or_' instead of next level of nesting ~ - as negation of the filter group To combine groups of filters into one set of conditions use & (sql AND ) and | (sql OR ) 1 2 3 4 5 6 7 8 9 10 11 # Following queries are equivalent: # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) # ormar OPTION 1 - OLD one Product . objects . filter ( name = 'Test' , rating__gte = 3.0 ) . get () # ormar OPTION 2 - OLD one Product . objects . filter ( ormar . and_ ( name = 'Test' , rating__gte = 3.0 )) . get () # ormar OPTION 3 - NEW one (field access) Product . objects . filter (( Product . name == 'Test' ) & ( Product . rating >= 3.0 )) . get () Same applies to nested complicated filters 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Following queries are equivalent: # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) # OR (categories.name IN ('Toys', 'Books')) # ormar OPTION 1 - OLD one Product . objects . filter ( ormar . or_ ( ormar . and_ ( name = 'Test' , rating__gte = 3.0 ), categories__name__in = [ 'Toys' , 'Books' ]) ) . get () # ormar OPTION 2 - NEW one (instead of nested or use `|`) Product . objects . filter ( ormar . and_ ( name = 'Test' , rating__gte = 3.0 ) | ormar . and_ ( categories__name__in = [ 'Toys' , 'Books' ]) ) . get () # ormar OPTION 3 - NEW one (field access) Product . objects . filter ( (( Product . name = 'Test' ) & ( Product . rating >= 3.0 )) | ( Product . categories . name << [ 'Toys' , 'Books' ]) ) . get () Now you can also use field access to provide OrderActions to order_by() Order ascending: OLD: Product.objects.order_by(\"name\").all() NEW: Product.objects.order_by(Product.name.asc()).all() Order descending: OLD: Product.objects.order_by(\"-name\").all() NEW: Product.objects.order_by(Product.name.desc()).all() You can of course also combine different models and many order_bys: Product.objects.order_by([Product.category.name.asc(), Product.name.desc()]).all() \ud83d\udc1b Fixes Not really a bug but rather inconsistency. Providing a filter with nested model i.e. album__category__name = 'AA' is checking if album and category models are included in select_related() and if not it's auto-adding them there. The same functionality was not working for FilterGroups ( and_ and or_ ), now it works (also for python style filters which return FilterGroups ). 0.10.3 \u2728 Features ForeignKey and ManyToMany now support skip_reverse: bool = False flag #118 . If you set skip_reverse flag internally the field is still registered on the other side of the relationship so you can: filter by related models fields from reverse model order_by by related models fields from reverse model But you cannot: * access the related field from reverse model with related_name * even if you select_related from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can filter and order_by ) * the relation won't be populated in dict() and json() * you cannot pass the nested related objects when populating from dict() or json() (also through fastapi ). It will be either ignored or raise error depending on extra setting in pydantic Config . * Model.save_related() now can save whole data tree in once #148 meaning: * it knows if it should save main Model or related Model first to preserve the relation * it saves main Model if * it's not saved , * has no pk value * or save_all=True flag is set 1 in those cases you don't have to split save into two calls (`save()` and `save_related()`) it supports also ManyToMany relations it supports also optional Through model values for m2m relations Add possibility to customize Through model relation field names. By default Through model relation names default to related model name in lowercase. So in example like this: python ... # course declaration ommited class Student(ormar.Model): class Meta: database = database metadata = metadata id: int = ormar.Integer(primary_key=True) name: str = ormar.String(max_length=100) courses = ormar.ManyToMany(Course) # will produce default Through model like follows (example simplified) class StudentCourse(ormar.Model): class Meta: database = database metadata = metadata tablename = \"students_courses\" id: int = ormar.Integer(primary_key=True) student = ormar.ForeignKey(Student) # default name course = ormar.ForeignKey(Course) # default name To customize the names of fields/relation in Through model now you can use new parameters to ManyToMany : through_relation_name - name of the field leading to the model in which ManyToMany is declared through_reverse_relation_name - name of the field leading to the model to which ManyToMany leads to Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... # course declaration ommited class Student ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) courses = ormar . ManyToMany ( Course , through_relation_name = \"student_id\" , through_reverse_relation_name = \"course_id\" ) # will produce default Through model like follows (example simplified) class StudentCourse ( ormar . Model ): class Meta : database = database metadata = metadata tablename = \"students_courses\" id : int = ormar . Integer ( primary_key = True ) student_id = ormar . ForeignKey ( Student ) # set by through_relation_name course_id = ormar . ForeignKey ( Course ) # set by through_reverse_relation_name \ud83d\udc1b Fixes Fix weakref ReferenceError error #118 Fix error raised by Through fields when pydantic Config.extra=\"forbid\" is set Fix bug with pydantic.PrivateAttr not being initialized at __init__ #149 Fix bug with pydantic-type exclude in dict() with __all__ key not working \ud83d\udcac Other Introduce link to sqlalchemy-to-ormar auto-translator for models Provide links to fastapi ecosystem libraries that support ormar Add transactions to docs (supported with databases ) 0.10.2 \u2728 Features Model.save_related(follow=False) now accept also two additional arguments: Model.save_related(follow=False, save_all=False, exclude=None) . save_all:bool -> By default (so with save_all=False ) ormar only upserts models that are not saved (so new or updated ones), with save_all=True all related models are saved, regardless of saved status, which might be useful if updated models comes from api call, so are not changed in the backend. exclude: Union[Set, Dict, None] -> set/dict of relations to exclude from save, those relation won't be saved even with follow=True and save_all=True . To exclude nested relations pass a nested dictionary like: exclude={\"child\":{\"sub_child\": {\"exclude_sub_child_realtion\"}}} . The allowed values follow the fields/exclude_fields (from QuerySet ) methods schema so when in doubt you can refer to docs in queries -> selecting subset of fields -> fields. Model.update() method now accepts _columns: List[str] = None parameter, that accepts list of column names to update. If passed only those columns will be updated in database. Note that update() does not refresh the instance of the Model, so if you change more columns than you pass in _columns list your Model instance will have different values than the database! Model.dict() method previously included only directly related models or nested models if they were not nullable and not virtual, now all related models not previously visited without loops are included in dict() . This should be not breaking as just more data will be dumped to dict, but it should not be missing. QuerySet.delete(each=False, **kwargs) previously required that you either pass a filter (by **kwargs or as a separate filter() call) or set each=True now also accepts exclude() calls that generates NOT filter. So either each=True needs to be set to delete whole table or at least one of filter/exclude clauses. Same thing applies to QuerySet.update(each=False, **kwargs) which also previously required that you either pass a filter (by **kwargs or as a separate filter() call) or set each=True now also accepts exclude() calls that generates NOT filter. So either each=True needs to be set to update whole table or at least one of filter/exclude clauses. Same thing applies to QuerysetProxy.update(each=False, **kwargs) which also previously required that you either pass a filter (by **kwargs or as a separate filter() call) or set each=True now also accepts exclude() calls that generates NOT filter. So either each=True needs to be set to update whole table or at least one of filter/exclude clauses. \ud83d\udc1b Fixes Fix improper relation field resolution in QuerysetProxy if fk column has different database alias. Fix hitting recursion error with very complicated models structure with loops when calling dict() . Fix bug when two non-relation fields were merged (appended) in query result when they were not relation fields (i.e. JSON) Fix bug when during translation to dict from list the same relation name is used in chain but leads to different models Fix bug when bulk_create would try to save also property_field decorated methods and pydantic fields Fix wrong merging of deeply nested chain of reversed relations \ud83d\udcac Other Performance optimizations Split tests into packages based on tested area 0.10.1 Features add get_or_none(**kwargs) method to QuerySet and QuerysetProxy . It is exact equivalent of get(**kwargs) but instead of raising ormar.NoMatch exception if there is no db record matching the criteria, get_or_none simply returns None . Fixes Fix dialect dependent quoting of column and table names in order_by clauses not working properly in postgres. 0.10.0 Breaking Dropped supported for long deprecated notation of field definition in which you use ormar fields as type hints i.e. test_field: ormar.Integger() = None Improved type hints -> mypy can properly resolve related models fields ( ForeignKey and ManyToMany ) as well as return types of QuerySet methods. Those mentioned are now returning proper model (i.e. Book ) instead or ormar.Model type. There is still problem with reverse sides of relation and QuerysetProxy methods, to ease type hints now those return Any . Partially fixes #112. Features add select_all(follow: bool = False) method to QuerySet and QuerysetProxy . It is kind of equivalent of the Model's load_all() method but can be used directly in a query. By default select_all() adds only directly related models, with follow=True also related models of related models are added without loops in relations. Note that it's not and end async model so you still have to issue get() , all() etc. as select_all() returns a QuerySet (or proxy) like fields() or order_by() . Internals ormar fields are no longer stored as classes in Meta.model_fields dictionary but instead they are stored as instances. 0.9.9 Features Add possibility to change default ordering of relations and models. To change model sorting pass orders_by = [columns] where columns: List[str] to model Meta class To change relation order_by pass orders_by = [columns] where columns: List[str] To change reverse relation order_by pass related_orders_by = [columns] where columns: List[str] Arguments can be column names or -{col_name} to sort descending In relations you can sort only by directly related model columns or for ManyToMany columns also Through model columns \"{through_field_name}__{column_name}\" Order in which order_by clauses are applied is as follows: Explicitly passed order_by() calls in query Relation passed orders_by if exists Model Meta class orders_by Model primary key column asc (fallback, used if none of above provided) Add 4 new aggregated functions -> min , max , sum and avg that are their corresponding sql equivalents. You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) You cannot sum and avg non numeric columns If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned Add 4 new signals -> pre_relation_add , post_relation_add , pre_relation_remove and post_relation_remove The newly added signals are emitted for ManyToMany relations (both sides) and reverse side of ForeignKey relation (same as QuerysetProxy is exposed). Signals recieve following args: sender: Type[Model] - sender class, instance: Model - instance to which related model is added, child: Model - model being added, relation_name: str - name of the relation to which child is added, for add signals also passed_kwargs: Dict - dict of kwargs passed to add() Changes Through models for ManyToMany relations are now instantiated on creation, deletion and update, so you can provide not only autoincrement int as a primary key but any column type with default function provided. Since Through models are now instantiated you can also subscribe to Through model pre/post save/update/delete signals pre_update signals receivers now get also passed_args argument which is a dict of values passed to update function if any (else empty dict) Fixes pre_update signal now is sent before the extraction of values so you can modify the passed instance in place and modified fields values will be reflected in database bulk_update now works correctly also with UUID primary key column type 0.9.8 Features Add possibility to encrypt the selected field(s) in the database As minimum you need to provide encrypt_secret and encrypt_backend encrypt_backend can be one of the ormar.EncryptBackends enum ( NONE, FERNET, HASH, CUSTOM ) - default: NONE When custom backend is selected you need to provide your backend class that subclasses ormar.fields.EncryptBackend You cannot encrypt primary_key column and relation columns (FK and M2M). Provided are 2 backends: HASH and FERNET HASH is a one-way hash (like for password), never decrypted on retrieval FERNET is a two-way encrypt/decrypt backend Note that in FERNET backend you loose filtering possibility altogether as part of the encrypted value is a timestamp. Note that in HASH backend you can filter by full value but filters like contain will not work as comparison is make on encrypted values Note that adding encrypt_backend changes the database column type to TEXT , which needs to be reflected in db either by migration or manual change Fixes (Advanced/ Internal) Restore custom sqlalchemy types (by types.TypeDecorator subclass) functionality that ceased to working so process_result_value was never called 0.9.7 Features Add isnull operator to filter and exclude methods. 1 2 album__name__isnull = True #(sql: album.name is null) album__name__isnull = False #(sql: album.name is not null)) Add ormar.or_ and ormar.and_ functions that can be used to compose complex queries with nested conditions. Sample query: 1 2 3 4 5 6 7 8 9 10 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . and_ ( ormar . or_ ( year__gt = 1960 , year__lt = 1940 ), author__name = \"J.R.R. Tolkien\" , ) ) . all () ) Check the updated docs in Queries -> Filtering and sorting -> Complex filters Other Setting default on ForeignKey or ManyToMany raises and ModelDefinition exception as it is (and was) not supported 0.9.6 Important Through model for ManyToMany relations now becomes optional . It's not a breaking change since if you provide it everything works just fine as it used to. So if you don't want or need any additional fields on Through model you can skip it. Note that it's going to be created for you automatically and still has to be included in example in alembic migrations. If you want to delete existing one check the default naming convention to adjust your existing database structure. Note that you still need to provide it if you want to customize the Through model name or the database table name. Features Add update method to QuerysetProxy so now it's possible to update related models directly from parent model in ManyToMany relations and in reverse ForeignKey relations. Note that update like in QuerySet update returns number of updated models and does not update related models in place on parent model. To get the refreshed data on parent model you need to refresh the related models (i.e. await model_instance.related.all() ) Add load_all(follow=False, exclude=None) model method that allows to load current instance of the model with all related models in one call. By default it loads only directly related models but setting follow=True causes traversing the tree (avoiding loops). You can also pass exclude parameter that works the same as QuerySet.exclude_fields() method. Added possibility to add more fields on Through model for ManyToMany relationships: name of the through model field is the lowercase name of the Through class you can pass additional fields when calling add(child, **kwargs) on relation (on QuerysetProxy ) you can pass additional fields when calling create(**kwargs) on relation (on QuerysetProxy ) when one of the keyword arguments should be the through model name with a dict of values you can order by on through model fields you can filter on through model fields you can include and exclude fields on through models through models are attached only to related models (i.e. if you query from A to B -> only on B) note that through models are explicitly loaded without relations -> relation is already populated in ManyToMany field. note that just like before you cannot declare the relation fields on through model, they will be populated for you by ormar , but now if you try to do so ModelDefinitionError will be thrown check the updated ManyToMany relation docs for more information Other Updated docs and api docs Refactors and optimisations mainly related to filters, exclusions and order bys 0.9.5 Fixes Fix creation of pydantic FieldInfo after update of pydantic to version >=1.8 Pin required dependency versions to avoid such situations in the future 0.9.4 Fixes Fix fastapi OpenAPI schema generation for automatic docs when multiple models refer to the same related one 0.9.3 Fixes Fix JSON field being double escaped when setting value after initialization Fix JSON field not respecting nullable field setting due to pydantic internals Fix choices verification for JSON field Fix choices not being verified when setting the attribute after initialization Fix choices not being verified during update call from QuerySet 0.9.2 Other Updated the Quick Start in docs/readme Updated docs with links to queries subpage Added badges for code climate and pepy downloads 0.9.1 Features Add choices values to OpenAPI specs, so it looks like native Enum field in the result schema. Fixes Fix choices behavior with fastapi usage when special fields can be not initialized yet but passed as strings etc. 0.9.0 Important Braking Fix: Version 0.8.0 introduced a bug that prevents generation of foreign_keys constraint in the database, both in alembic and during creation through sqlalchemy.engine, this is fixed now. THEREFORE IF YOU USE VERSION >=0.8.0 YOU ARE STRONGLY ADVISED TO UPDATE cause despite that most of the ormar functions are working your database CREATED with ormar (or ormar + alembic) does not have relations and suffer from perspective of performance and data integrity. If you were using ormar to connect to existing database your performance and integrity should be fine nevertheless you should update to reflect all future schema updates in your models. Breaking Breaking: All foreign_keys and unique constraints now have a name so alembic can identify them in db and not depend on db Breaking: During model construction if Meta class of the Model does not include metadata or database now ModelDefinitionError will be raised instead of generic AttributeError . Breaking: encode/databases used for running the queries does not have a connection pool for sqlite backend, meaning that each querry is run with a new connection and there is no way to enable enforcing ForeignKeys constraints as those are by default turned off on every connection. This is changed in ormar since >=0.9.0 and by default each sqlite3 query has \"PRAGMA foreign_keys=1;\" run so now each sqlite3 connection by default enforces ForeignKey constraints including cascades. Other Update api docs. Add tests for fk creation in db and for cascades in db 0.8.1 Features Introduce processing of ForwardRef in relations. Now you can create self-referencing models - both ForeignKey and ManyToMany relations. ForwardRef can be used both for to and through Models . Introduce the possibility to perform two same relation joins in one query, so to process complex relations like: 1 2 3 4 5 6 7 B = X = Y // A \\ C = X = Y <= before you could link from X to Y only once in one query unless two different relation were used (two relation fields with different names) Introduce the paginate method that allows to limit/offset by page and page_size . Available for QuerySet and QuerysetProxy . Other Refactoring and performance optimization in queries and joins. Add python 3.9 to tests and pypi setup. Update API docs and docs -> i.e. split of queries documentation. 0.8.0 Breaking Breaking: remove() parent from child side in reverse ForeignKey relation now requires passing a relation name , as the same model can be registered multiple times and ormar needs to know from which relation on the parent you want to remove the child. Breaking: applying limit and offset with select_related is by default applied only on the main table before the join -> meaning that not the total number of rows is limited but just number of main models (first one in the query, the one used to construct it). You can still limit all rows from db response with limit_raw_sql=True flag on either limit or offset (or both) Breaking: issuing first() now fetches the first row ordered by the primary key asc (so first one inserted (can be different for non number primary keys - i.e. alphabetical order of string)) Breaking: issuing get() without any filters now fetches the first row ordered by the primary key desc (so should be last one inserted (can be different for non number primary keys - i.e. alphabetical order of string)) Breaking (internal): sqlalchemy columns kept at Meta.columns are no longer bind to table, so you cannot get the column straight from there Features Introduce inheritance . For now two types of inheritance are possible: Mixins - don't subclass ormar.Model , just define fields that are later used on different models (like created_date and updated_date on each child model), only actual models create tables, but those fields from mixins are added Concrete table inheritance - means that parent is marked as abstract=True in Meta class and each child has its own table with columns from the parent and own child columns, kind of similar to Mixins but parent also is a (an abstract) Model To read more check the docs on models -> inheritance section. QuerySet first() can be used with prefetch_related Fixes Fix minor bug in order_by for primary model order bys Fix in prefetch_query for multiple related_names for the same model. Fix using same related_name on different models leading to the same related Model overwriting each other, now ModelDefinitionError is raised and you need to change the name. Fix order_by overwriting conditions when multiple joins to the same table applied. Docs Split and cleanup in docs: Divide models section into subsections Divide relations section into subsections Divide fields section into subsections Add model inheritance section Add API (BETA) documentation 0.7.5 Fix for wrong relation column name in many_to_many relation joins (fix #73 ) 0.7.4 Allow multiple relations to the same related model/table. Fix for wrong relation column used in many_to_many relation joins (fix #73 ) Fix for wrong relation population for m2m relations when also fk relation present for same model. Add check if user provide related_name if there are multiple relations to same table on one model. More eager cleaning of the dead weak proxy models. 0.7.3 Fix for setting fetching related model with UUDI pk, which is a string in raw (fix #71 ) 0.7.2 Fix for overwriting related models with pk only in Model.update() with fields passed as parameters (fix #70 ) 0.7.1 Fix for overwriting related models with pk only in Model.save() (fix #68 ) 0.7.0 Breaking: QuerySet bulk_update method now raises ModelPersistenceError for unsaved models passed instead of QueryDefinitionError Breaking: Model initialization with unknown field name now raises ModelError instead of KeyError Added Signals , with pre-defined list signals and decorators: post_delete , post_save , post_update , pre_delete , pre_save , pre_update Add py.typed and modify setup.py for mypy support Performance optimization Updated docs 0.6.2 Performance optimization Fix for bug with pydantic_only fields being required Add property_field decorator that registers a function as a property that will be included in Model.dict() and in fastapi response Update docs 0.6.1 Explicitly set None to excluded nullable fields to avoid pydantic setting a default value (fix #60 ). 0.6.0 Breaking: calling instance.load() when the instance row was deleted from db now raises NoMatch instead of ValueError Breaking: calling add and remove on ReverseForeignKey relation now updates the child model in db setting/removing fk column Breaking: ReverseForeignKey relation now exposes QuerySetProxy API like ManyToMany relation Breaking: querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 Added get_or_create , update_or_create , fields , exclude_fields , exclude , prefetch_related and order_by to QuerySetProxy so now you can use those methods directly from relation Update docs 0.5.5 Fix for alembic autogenaration of migration UUID columns. It should just produce sqlalchemy CHAR(32) or CHAR(36) In order for this to work you have to set user_module_prefix='sa.' (must be equal to sqlalchemy_module_prefix option (default 'sa.')) 0.5.4 Allow to pass uuid_format (allowed 'hex'(default) or 'string') to UUID field to change the format in which it's saved. By default field is saved in hex format (trimmed to 32 chars (without dashes)), but you can pass format='string' to use 36 (with dashes) instead to adjust to existing db or other libraries. Sample: * hex value = c616ab438cce49dbbf4380d109251dce * string value = c616ab43-8cce-49db-bf43-80d109251dce 0.5.3 Fixed bug in Model.dict() method that was ignoring exclude parameter and not include dictionary argument. 0.5.2 Added prefetch_related method to load subsequent models in separate queries. Update docs 0.5.1 Switched to github actions instead of travis Update badges in the docs 0.5.0 Added save status -> you can check if model is saved with ModelInstance.saved property Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantation with __init__ (w/o QuerySet.create or before calling save ) Added Model.upsert(**kwargs) that performs save() if pk not set otherwise update(**kwargs) Added Model.save_related(follow=False) that iterates all related objects in all relations and checks if they are saved. If not it calls upsert() on each of them. Breaking: added raising exceptions if add -ing/ remove -ing not saved (pk is None) models to ManyToMany relation Allow passing dictionaries and sets to fields and exclude_fields Auto translate str and lists to dicts for fields and exclude_fields Breaking: passing nested models to fields and exclude_fields is now by related ForeignKey name and not by target model name Performance optimizations - in modelproxy, newbasemodel - > less queries, some properties are cached on models Cleanup of unused relations code Optional performance dependency orjson added ( strongly recommended ) Updated docs 0.4.4 add exclude_fields() method to exclude fields from sql refactor column names setting (aliases) fix ordering by for column with aliases additional tests for fields and exclude_fields update docs 0.4.3 include properties in models.dict() and model.json() 0.4.2 modify creation of pydantic models to allow returning related models with only pk populated 0.4.1 add order_by method to queryset to allow sorting update docs 0.4.0 Changed notation in Model definition -> now use name = ormar.Field() not name: ormar.Field() Note that old notation is still supported but deprecated and will not play nice with static checkers like mypy and pydantic pycharm plugin Type hint docs and test Use mypy for tests also not, only ormar package Fix scale and precision translation with max_digits and decimal_places pydantic Decimal field Update docs - add best practices for dependencies Refactor metaclass and model_fields to play nice with type hints Add mypy and pydantic plugin to docs Expand the docs on ManyToMany relation 0.3.11 Fix setting server_default as default field value in python 0.3.10 Fix postgresql check to avoid exceptions with drivers not installed if using different backend 0.3.9 Fix json schema generation as of #19 Fix for not initialized ManyToMany relations in fastapi copies of ormar.Models Update docs in regard of fastapi use Add tests to verify fastapi/docs proper generation 0.3.8 Added possibility to provide alternative database column names with name parameter to all fields. Fix bug with selecting related ManyToMany fields with fields() if they are empty. Updated documentation 0.3.7 Publish documentation and update readme 0.3.6 Add fields() method to limit the selected columns from database - only nullable columns can be excluded. Added UniqueColumns and constraints list in model Meta to build unique constraints on list of columns. Added UUID field type based on Char(32) column type. 0.3.5 Added bulk_create and bulk_update for operations on multiple objects. 0.3.4 Add queryset level methods * delete * update * get_or_create * update_or_create 0.3.3 Add additional filters - startswith and endswith 0.3.2 Add choices parameter to all fields - limiting the accepted values to ones provided 0.3.1 Added exclude to filter where not conditions. Added tests for mysql and postgres with fixes for postgres. Rafactors and cleanup. 0.3.0 Added ManyToMany field and support for many to many relations","title":"Release Notes"},{"location":"releases/#01016","text":"","title":"0.10.16"},{"location":"releases/#features","text":"Allow passing your own pydantic Config to ormar.Model that will be merged with the default one by @naturalethic (thanks!) #285 Add SmallInteger field type by @ProgrammerPlus1998 (thanks!) #297","title":"\u2728 Features"},{"location":"releases/#fixes","text":"Fix generating openapi schema by removing obsolete pydantic field parameters that were directly exposed in schema #291 Fix unnecessary warning for auto generated through models #295","title":"\ud83d\udc1b Fixes"},{"location":"releases/#01015","text":"","title":"0.10.15"},{"location":"releases/#fixes_1","text":"Fix generating pydantic models tree with nested models (by @pawamoy - thanks!) #278 Fix missing f-string in warning about missing primary key field #274 Fix passing foreign key value as relation (additional guard, fixed already in the latest release) #270","title":"\ud83d\udc1b Fixes"},{"location":"releases/#01014","text":"","title":"0.10.14"},{"location":"releases/#features_1","text":"Allow passing timezone:bool = False parameter to DateTime and Time fields for timezone aware database columns #264 Allow passing datetime, date and time for filter on DateTime , Time and Date fields to allow filtering by datetimes instead of converting the value to string #79","title":"\u2728 Features"},{"location":"releases/#fixes_2","text":"Fix dependencies from psycopg2 to psycopg2-binary #255","title":"\ud83d\udc1b Fixes"},{"location":"releases/#01013","text":"","title":"0.10.13"},{"location":"releases/#features_2","text":"Allow passing field accessors in select_related and prefetch_related aka. python style select_related #225 . Previously: 1 2 await Post . objects . select_related ([ \"author\" , \"categories\" ]) . get () await Author . objects . prefetch_related ( \"posts__categories\" ) . get () Now also: 1 2 await Post . objects . select_related ([ Post . author , Post . categories ]) . get () await Author . objects . prefetch_related ( Author . posts . categories ) . get ()","title":"\u2728 Features"},{"location":"releases/#fixes_3","text":"Fix overwriting default value for inherited primary key #253","title":"\ud83d\udc1b Fixes"},{"location":"releases/#01012","text":"","title":"0.10.12"},{"location":"releases/#fixes_4","text":"Fix QuerySet.create method not using init (if custom provided) #245 Fix ForwardRef ManyToMany relation setting wrong pydantic type #250","title":"\ud83d\udc1b Fixes"},{"location":"releases/#01011","text":"","title":"0.10.11"},{"location":"releases/#features_3","text":"Add values and values_list to QuerySet and QuerysetProxy that allows to return raw data from query #223 . Allow returning list of tuples or list of dictionaries from a query Skips parsing the data to ormar model so skips also the validation Allow excluding models in between in chain of relations, so you can extract only needed columns values_list allows you to flatten the result if you extract only one column.","title":"\u2728 Features"},{"location":"releases/#fixes_5","text":"Fix creation of auto through model for m2m relation with ForwardRef #226","title":"\ud83d\udc1b Fixes"},{"location":"releases/#01010","text":"","title":"0.10.10"},{"location":"releases/#features_4","text":"Add get_pydantic flag that allows you to auto generate equivalent pydantic models tree from ormar.Model. This newly generated model tree can be used in requests and responses to exclude fields you do not want to include in the data. Add exclude_parent_fields parameter to model Meta that allows you to exclude fields from parent models during inheritance. Note that best practice is to combine models and mixins but if you have many similar models and just one that differs it might be useful tool to achieve that.","title":"\u2728 Features"},{"location":"releases/#fixes_6","text":"Fix is null filter with pagination and relations (by @erichaydel) #214 Fix not saving child object on reverse side of the relation if not saved before #216","title":"\ud83d\udc1b Fixes"},{"location":"releases/#other","text":"Expand fastapi part of the documentation to show samples of using ormar in requests and responses in fastapi. Improve the docs in regard of default , ForeignKey.add etc.","title":"\ud83d\udcac Other"},{"location":"releases/#0109","text":"","title":"0.10.9"},{"location":"releases/#important-security-fix","text":"Update pin for pydantic to fix security vulnerability CVE-2021-29510 You are advised to update to version of pydantic that was patched. In 0.10.9 ormar excludes versions with vulnerability in pinned dependencies.","title":"Important security fix"},{"location":"releases/#fixes_7","text":"Fix OpenAPi schema for LargeBinary #204","title":"\ud83d\udc1b Fixes"},{"location":"releases/#0108","text":"","title":"0.10.8"},{"location":"releases/#fixes_8","text":"Fix populating default values in pk_only child models #202 Fix mypy for LargeBinary fields with base64 str representation #199 Fix OpenAPI schema format for LargeBinary fields with base64 str representation #199 Fix OpenAPI choices encoding for LargeBinary fields with base64 str representation","title":"\ud83d\udc1b Fixes"},{"location":"releases/#0107","text":"","title":"0.10.7"},{"location":"releases/#features_5","text":"Add exclude_primary_keys: bool = False flag to dict() method that allows to exclude all primary key columns in the resulting dictionaru. #164 Add exclude_through_models: bool = False flag to dict() that allows excluding all through models from ManyToMany relations #164 Add represent_as_base64_str: bool = False parameter that allows conversion of bytes LargeBinary field to base64 encoded string. String is returned in dict() , on access to attribute and string is converted to bytes on setting. Data in database is stored as bytes. #187 Add pk alias to allow field access by Model.pk in filters and order by clauses (python style)","title":"\u2728 Features"},{"location":"releases/#fixes_9","text":"Remove default None option for max_length for LargeBinary field #186 Remove default None option for max_length for String field","title":"\ud83d\udc1b Fixes"},{"location":"releases/#other_1","text":"Provide a guide and samples of dict() parameters in the docs Major refactor of getting/setting attributes from magic methods into descriptors -> noticeable performance improvement","title":"\ud83d\udcac Other"},{"location":"releases/#0106","text":"","title":"0.10.6"},{"location":"releases/#features_6","text":"Add LargeBinary(max_length) field type #166 Add support for normal pydantic fields (including Models) instead of pydantic_only attribute which is now deprecated #160 . Pydantic fields should be declared normally as in pydantic model next to ormar fields, note that (obviously) ormar does not save and load the value for this field in database that mean that ONE of the following has to be true: pydantic field declared on ormar model has to be Optional (defaults to None) pydantic field has to have a default value set pydantic field has default_factory function set ormar.Model with pydantic field has to overwrite __init__() and provide the value there If none of the above ormar (or rather pydantic) will fail during loading data from the database, with missing required value for declared pydantic field. * Ormar provides now a meaningful examples in openapi schema, including nested models. The same algorithm is used to iterate related models without looks as with dict() and select/load_all . Examples appear also in fastapi . #157","title":"\u2728 Features"},{"location":"releases/#fixes_10","text":"By default pydantic is not validating fields during assignment, which is not a desirable setting for an ORM, now all ormar.Models have validation turned-on during assignment (like model.column = 'value' )","title":"\ud83d\udc1b Fixes"},{"location":"releases/#other_2","text":"Add connecting to the database in QuickStart in readme #180 OpenAPI schema does no longer include ormar.Model docstring as description, instead just model name is provided if you do not provide your own docstring. Some performance improvements.","title":"\ud83d\udcac Other"},{"location":"releases/#0105","text":"","title":"0.10.5"},{"location":"releases/#fixes_11","text":"Fix bug in fastapi-pagination #73 Remove unnecessary Optional in List[Optional[T]] in return value for QuerySet.all() and Querysetproxy.all() return values #174 Run tests coverage publish only on internal prs instead of all in github action.","title":"\ud83d\udc1b Fixes"},{"location":"releases/#0104","text":"","title":"0.10.4"},{"location":"releases/#features_7","text":"Add Python style to filter and order_by with field access instead of dunder separated strings. #51 Accessing a field with attribute access (chain of dot notation) can be used to construct FilterGroups ( ormar.and_ and ormar.or_ ) Field access overloads set of python operators and provide a set of functions to allow same functionality as with dunder separated param names in **kwargs , that means that querying from sample model Track related to model Album now you have more options: exact - exact match to value, sql column = <VALUE> OLD: album__name__exact='Malibu' NEW: can be also written as Track.album.name == 'Malibu iexact - exact match sql column = <VALUE> (case insensitive) OLD: album__name__iexact='malibu' NEW: can be also written as Track.album.name.iexact('malibu') contains - sql column LIKE '%<VALUE>%' OLD: album__name__contains='Mal' NEW: can be also written as Track.album.name % 'Mal') NEW: can be also written as Track.album.name.contains('Mal') icontains - sql column LIKE '%<VALUE>%' (case insensitive) OLD: album__name__icontains='mal' NEW: can be also written as Track.album.name.icontains('mal') in - sql column IN (<VALUE1>, <VALUE2>, ...) OLD: album__name__in=['Malibu', 'Barclay'] NEW: can be also written as Track.album.name << ['Malibu', 'Barclay'] NEW: can be also written as Track.album.name.in_(['Malibu', 'Barclay']) isnull - sql column IS NULL (and sql column IS NOT NULL ) OLD: album__name__isnull=True (isnotnull album__name__isnull=False ) NEW: can be also written as Track.album.name >> None NEW: can be also written as Track.album.name.isnull(True) NEW: not null can be also written as Track.album.name.isnull(False) NEW: not null can be also written as ~(Track.album.name >> None) NEW: not null can be also written as ~(Track.album.name.isnull(True)) gt - sql column > <VALUE> (greater than) OLD: position__gt=3 NEW: can be also written as Track.album.name > 3 gte - sql column >= <VALUE> (greater or equal than) OLD: position__gte=3 NEW: can be also written as Track.album.name >= 3 lt - sql column < <VALUE> (lower than) OLD: position__lt=3 NEW: can be also written as Track.album.name < 3 lte - sql column <= <VALUE> (lower equal than) OLD: position__lte=3 NEW: can be also written as Track.album.name <= 3 startswith - sql column LIKE '<VALUE>%' (exact start match) OLD: album__name__startswith='Mal' NEW: can be also written as Track.album.name.startswith('Mal') istartswith - sql column LIKE '<VALUE>%' (case insensitive) OLD: album__name__istartswith='mal' NEW: can be also written as Track.album.name.istartswith('mal') endswith - sql column LIKE '%<VALUE>' (exact end match) OLD: album__name__endswith='ibu' NEW: can be also written as Track.album.name.endswith('ibu') iendswith - sql column LIKE '%<VALUE>' (case insensitive) OLD: album__name__iendswith='IBU' NEW: can be also written as Track.album.name.iendswith('IBU') You can provide FilterGroups not only in filter() and exclude() but also in: get() get_or_none() get_or_create() first() all() delete() With FilterGroups ( ormar.and_ and ormar.or_ ) you can now use: & - as and_ instead of next level of nesting | - as `or_' instead of next level of nesting ~ - as negation of the filter group To combine groups of filters into one set of conditions use & (sql AND ) and | (sql OR ) 1 2 3 4 5 6 7 8 9 10 11 # Following queries are equivalent: # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) # ormar OPTION 1 - OLD one Product . objects . filter ( name = 'Test' , rating__gte = 3.0 ) . get () # ormar OPTION 2 - OLD one Product . objects . filter ( ormar . and_ ( name = 'Test' , rating__gte = 3.0 )) . get () # ormar OPTION 3 - NEW one (field access) Product . objects . filter (( Product . name == 'Test' ) & ( Product . rating >= 3.0 )) . get () Same applies to nested complicated filters 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Following queries are equivalent: # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) # OR (categories.name IN ('Toys', 'Books')) # ormar OPTION 1 - OLD one Product . objects . filter ( ormar . or_ ( ormar . and_ ( name = 'Test' , rating__gte = 3.0 ), categories__name__in = [ 'Toys' , 'Books' ]) ) . get () # ormar OPTION 2 - NEW one (instead of nested or use `|`) Product . objects . filter ( ormar . and_ ( name = 'Test' , rating__gte = 3.0 ) | ormar . and_ ( categories__name__in = [ 'Toys' , 'Books' ]) ) . get () # ormar OPTION 3 - NEW one (field access) Product . objects . filter ( (( Product . name = 'Test' ) & ( Product . rating >= 3.0 )) | ( Product . categories . name << [ 'Toys' , 'Books' ]) ) . get () Now you can also use field access to provide OrderActions to order_by() Order ascending: OLD: Product.objects.order_by(\"name\").all() NEW: Product.objects.order_by(Product.name.asc()).all() Order descending: OLD: Product.objects.order_by(\"-name\").all() NEW: Product.objects.order_by(Product.name.desc()).all() You can of course also combine different models and many order_bys: Product.objects.order_by([Product.category.name.asc(), Product.name.desc()]).all()","title":"\u2728 Features"},{"location":"releases/#fixes_12","text":"Not really a bug but rather inconsistency. Providing a filter with nested model i.e. album__category__name = 'AA' is checking if album and category models are included in select_related() and if not it's auto-adding them there. The same functionality was not working for FilterGroups ( and_ and or_ ), now it works (also for python style filters which return FilterGroups ).","title":"\ud83d\udc1b Fixes"},{"location":"releases/#0103","text":"","title":"0.10.3"},{"location":"releases/#features_8","text":"ForeignKey and ManyToMany now support skip_reverse: bool = False flag #118 . If you set skip_reverse flag internally the field is still registered on the other side of the relationship so you can: filter by related models fields from reverse model order_by by related models fields from reverse model But you cannot: * access the related field from reverse model with related_name * even if you select_related from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can filter and order_by ) * the relation won't be populated in dict() and json() * you cannot pass the nested related objects when populating from dict() or json() (also through fastapi ). It will be either ignored or raise error depending on extra setting in pydantic Config . * Model.save_related() now can save whole data tree in once #148 meaning: * it knows if it should save main Model or related Model first to preserve the relation * it saves main Model if * it's not saved , * has no pk value * or save_all=True flag is set 1 in those cases you don't have to split save into two calls (`save()` and `save_related()`) it supports also ManyToMany relations it supports also optional Through model values for m2m relations Add possibility to customize Through model relation field names. By default Through model relation names default to related model name in lowercase. So in example like this: python ... # course declaration ommited class Student(ormar.Model): class Meta: database = database metadata = metadata id: int = ormar.Integer(primary_key=True) name: str = ormar.String(max_length=100) courses = ormar.ManyToMany(Course) # will produce default Through model like follows (example simplified) class StudentCourse(ormar.Model): class Meta: database = database metadata = metadata tablename = \"students_courses\" id: int = ormar.Integer(primary_key=True) student = ormar.ForeignKey(Student) # default name course = ormar.ForeignKey(Course) # default name To customize the names of fields/relation in Through model now you can use new parameters to ManyToMany : through_relation_name - name of the field leading to the model in which ManyToMany is declared through_reverse_relation_name - name of the field leading to the model to which ManyToMany leads to Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... # course declaration ommited class Student ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) courses = ormar . ManyToMany ( Course , through_relation_name = \"student_id\" , through_reverse_relation_name = \"course_id\" ) # will produce default Through model like follows (example simplified) class StudentCourse ( ormar . Model ): class Meta : database = database metadata = metadata tablename = \"students_courses\" id : int = ormar . Integer ( primary_key = True ) student_id = ormar . ForeignKey ( Student ) # set by through_relation_name course_id = ormar . ForeignKey ( Course ) # set by through_reverse_relation_name","title":"\u2728 Features"},{"location":"releases/#fixes_13","text":"Fix weakref ReferenceError error #118 Fix error raised by Through fields when pydantic Config.extra=\"forbid\" is set Fix bug with pydantic.PrivateAttr not being initialized at __init__ #149 Fix bug with pydantic-type exclude in dict() with __all__ key not working","title":"\ud83d\udc1b Fixes"},{"location":"releases/#other_3","text":"Introduce link to sqlalchemy-to-ormar auto-translator for models Provide links to fastapi ecosystem libraries that support ormar Add transactions to docs (supported with databases )","title":"\ud83d\udcac Other"},{"location":"releases/#0102","text":"","title":"0.10.2"},{"location":"releases/#features_9","text":"Model.save_related(follow=False) now accept also two additional arguments: Model.save_related(follow=False, save_all=False, exclude=None) . save_all:bool -> By default (so with save_all=False ) ormar only upserts models that are not saved (so new or updated ones), with save_all=True all related models are saved, regardless of saved status, which might be useful if updated models comes from api call, so are not changed in the backend. exclude: Union[Set, Dict, None] -> set/dict of relations to exclude from save, those relation won't be saved even with follow=True and save_all=True . To exclude nested relations pass a nested dictionary like: exclude={\"child\":{\"sub_child\": {\"exclude_sub_child_realtion\"}}} . The allowed values follow the fields/exclude_fields (from QuerySet ) methods schema so when in doubt you can refer to docs in queries -> selecting subset of fields -> fields. Model.update() method now accepts _columns: List[str] = None parameter, that accepts list of column names to update. If passed only those columns will be updated in database. Note that update() does not refresh the instance of the Model, so if you change more columns than you pass in _columns list your Model instance will have different values than the database! Model.dict() method previously included only directly related models or nested models if they were not nullable and not virtual, now all related models not previously visited without loops are included in dict() . This should be not breaking as just more data will be dumped to dict, but it should not be missing. QuerySet.delete(each=False, **kwargs) previously required that you either pass a filter (by **kwargs or as a separate filter() call) or set each=True now also accepts exclude() calls that generates NOT filter. So either each=True needs to be set to delete whole table or at least one of filter/exclude clauses. Same thing applies to QuerySet.update(each=False, **kwargs) which also previously required that you either pass a filter (by **kwargs or as a separate filter() call) or set each=True now also accepts exclude() calls that generates NOT filter. So either each=True needs to be set to update whole table or at least one of filter/exclude clauses. Same thing applies to QuerysetProxy.update(each=False, **kwargs) which also previously required that you either pass a filter (by **kwargs or as a separate filter() call) or set each=True now also accepts exclude() calls that generates NOT filter. So either each=True needs to be set to update whole table or at least one of filter/exclude clauses.","title":"\u2728 Features"},{"location":"releases/#fixes_14","text":"Fix improper relation field resolution in QuerysetProxy if fk column has different database alias. Fix hitting recursion error with very complicated models structure with loops when calling dict() . Fix bug when two non-relation fields were merged (appended) in query result when they were not relation fields (i.e. JSON) Fix bug when during translation to dict from list the same relation name is used in chain but leads to different models Fix bug when bulk_create would try to save also property_field decorated methods and pydantic fields Fix wrong merging of deeply nested chain of reversed relations","title":"\ud83d\udc1b Fixes"},{"location":"releases/#other_4","text":"Performance optimizations Split tests into packages based on tested area","title":"\ud83d\udcac Other"},{"location":"releases/#0101","text":"","title":"0.10.1"},{"location":"releases/#features_10","text":"add get_or_none(**kwargs) method to QuerySet and QuerysetProxy . It is exact equivalent of get(**kwargs) but instead of raising ormar.NoMatch exception if there is no db record matching the criteria, get_or_none simply returns None .","title":"Features"},{"location":"releases/#fixes_15","text":"Fix dialect dependent quoting of column and table names in order_by clauses not working properly in postgres.","title":"Fixes"},{"location":"releases/#0100","text":"","title":"0.10.0"},{"location":"releases/#breaking","text":"Dropped supported for long deprecated notation of field definition in which you use ormar fields as type hints i.e. test_field: ormar.Integger() = None Improved type hints -> mypy can properly resolve related models fields ( ForeignKey and ManyToMany ) as well as return types of QuerySet methods. Those mentioned are now returning proper model (i.e. Book ) instead or ormar.Model type. There is still problem with reverse sides of relation and QuerysetProxy methods, to ease type hints now those return Any . Partially fixes #112.","title":"Breaking"},{"location":"releases/#features_11","text":"add select_all(follow: bool = False) method to QuerySet and QuerysetProxy . It is kind of equivalent of the Model's load_all() method but can be used directly in a query. By default select_all() adds only directly related models, with follow=True also related models of related models are added without loops in relations. Note that it's not and end async model so you still have to issue get() , all() etc. as select_all() returns a QuerySet (or proxy) like fields() or order_by() .","title":"Features"},{"location":"releases/#internals","text":"ormar fields are no longer stored as classes in Meta.model_fields dictionary but instead they are stored as instances.","title":"Internals"},{"location":"releases/#099","text":"","title":"0.9.9"},{"location":"releases/#features_12","text":"Add possibility to change default ordering of relations and models. To change model sorting pass orders_by = [columns] where columns: List[str] to model Meta class To change relation order_by pass orders_by = [columns] where columns: List[str] To change reverse relation order_by pass related_orders_by = [columns] where columns: List[str] Arguments can be column names or -{col_name} to sort descending In relations you can sort only by directly related model columns or for ManyToMany columns also Through model columns \"{through_field_name}__{column_name}\" Order in which order_by clauses are applied is as follows: Explicitly passed order_by() calls in query Relation passed orders_by if exists Model Meta class orders_by Model primary key column asc (fallback, used if none of above provided) Add 4 new aggregated functions -> min , max , sum and avg that are their corresponding sql equivalents. You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) You cannot sum and avg non numeric columns If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned Add 4 new signals -> pre_relation_add , post_relation_add , pre_relation_remove and post_relation_remove The newly added signals are emitted for ManyToMany relations (both sides) and reverse side of ForeignKey relation (same as QuerysetProxy is exposed). Signals recieve following args: sender: Type[Model] - sender class, instance: Model - instance to which related model is added, child: Model - model being added, relation_name: str - name of the relation to which child is added, for add signals also passed_kwargs: Dict - dict of kwargs passed to add()","title":"Features"},{"location":"releases/#changes","text":"Through models for ManyToMany relations are now instantiated on creation, deletion and update, so you can provide not only autoincrement int as a primary key but any column type with default function provided. Since Through models are now instantiated you can also subscribe to Through model pre/post save/update/delete signals pre_update signals receivers now get also passed_args argument which is a dict of values passed to update function if any (else empty dict)","title":"Changes"},{"location":"releases/#fixes_16","text":"pre_update signal now is sent before the extraction of values so you can modify the passed instance in place and modified fields values will be reflected in database bulk_update now works correctly also with UUID primary key column type","title":"Fixes"},{"location":"releases/#098","text":"","title":"0.9.8"},{"location":"releases/#features_13","text":"Add possibility to encrypt the selected field(s) in the database As minimum you need to provide encrypt_secret and encrypt_backend encrypt_backend can be one of the ormar.EncryptBackends enum ( NONE, FERNET, HASH, CUSTOM ) - default: NONE When custom backend is selected you need to provide your backend class that subclasses ormar.fields.EncryptBackend You cannot encrypt primary_key column and relation columns (FK and M2M). Provided are 2 backends: HASH and FERNET HASH is a one-way hash (like for password), never decrypted on retrieval FERNET is a two-way encrypt/decrypt backend Note that in FERNET backend you loose filtering possibility altogether as part of the encrypted value is a timestamp. Note that in HASH backend you can filter by full value but filters like contain will not work as comparison is make on encrypted values Note that adding encrypt_backend changes the database column type to TEXT , which needs to be reflected in db either by migration or manual change","title":"Features"},{"location":"releases/#fixes_17","text":"(Advanced/ Internal) Restore custom sqlalchemy types (by types.TypeDecorator subclass) functionality that ceased to working so process_result_value was never called","title":"Fixes"},{"location":"releases/#097","text":"","title":"0.9.7"},{"location":"releases/#features_14","text":"Add isnull operator to filter and exclude methods. 1 2 album__name__isnull = True #(sql: album.name is null) album__name__isnull = False #(sql: album.name is not null)) Add ormar.or_ and ormar.and_ functions that can be used to compose complex queries with nested conditions. Sample query: 1 2 3 4 5 6 7 8 9 10 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . and_ ( ormar . or_ ( year__gt = 1960 , year__lt = 1940 ), author__name = \"J.R.R. Tolkien\" , ) ) . all () ) Check the updated docs in Queries -> Filtering and sorting -> Complex filters","title":"Features"},{"location":"releases/#other_5","text":"Setting default on ForeignKey or ManyToMany raises and ModelDefinition exception as it is (and was) not supported","title":"Other"},{"location":"releases/#096","text":"","title":"0.9.6"},{"location":"releases/#important","text":"Through model for ManyToMany relations now becomes optional . It's not a breaking change since if you provide it everything works just fine as it used to. So if you don't want or need any additional fields on Through model you can skip it. Note that it's going to be created for you automatically and still has to be included in example in alembic migrations. If you want to delete existing one check the default naming convention to adjust your existing database structure. Note that you still need to provide it if you want to customize the Through model name or the database table name.","title":"Important"},{"location":"releases/#features_15","text":"Add update method to QuerysetProxy so now it's possible to update related models directly from parent model in ManyToMany relations and in reverse ForeignKey relations. Note that update like in QuerySet update returns number of updated models and does not update related models in place on parent model. To get the refreshed data on parent model you need to refresh the related models (i.e. await model_instance.related.all() ) Add load_all(follow=False, exclude=None) model method that allows to load current instance of the model with all related models in one call. By default it loads only directly related models but setting follow=True causes traversing the tree (avoiding loops). You can also pass exclude parameter that works the same as QuerySet.exclude_fields() method. Added possibility to add more fields on Through model for ManyToMany relationships: name of the through model field is the lowercase name of the Through class you can pass additional fields when calling add(child, **kwargs) on relation (on QuerysetProxy ) you can pass additional fields when calling create(**kwargs) on relation (on QuerysetProxy ) when one of the keyword arguments should be the through model name with a dict of values you can order by on through model fields you can filter on through model fields you can include and exclude fields on through models through models are attached only to related models (i.e. if you query from A to B -> only on B) note that through models are explicitly loaded without relations -> relation is already populated in ManyToMany field. note that just like before you cannot declare the relation fields on through model, they will be populated for you by ormar , but now if you try to do so ModelDefinitionError will be thrown check the updated ManyToMany relation docs for more information","title":"Features"},{"location":"releases/#other_6","text":"Updated docs and api docs Refactors and optimisations mainly related to filters, exclusions and order bys","title":"Other"},{"location":"releases/#095","text":"","title":"0.9.5"},{"location":"releases/#fixes_18","text":"Fix creation of pydantic FieldInfo after update of pydantic to version >=1.8 Pin required dependency versions to avoid such situations in the future","title":"Fixes"},{"location":"releases/#094","text":"","title":"0.9.4"},{"location":"releases/#fixes_19","text":"Fix fastapi OpenAPI schema generation for automatic docs when multiple models refer to the same related one","title":"Fixes"},{"location":"releases/#093","text":"","title":"0.9.3"},{"location":"releases/#fixes_20","text":"Fix JSON field being double escaped when setting value after initialization Fix JSON field not respecting nullable field setting due to pydantic internals Fix choices verification for JSON field Fix choices not being verified when setting the attribute after initialization Fix choices not being verified during update call from QuerySet","title":"Fixes"},{"location":"releases/#092","text":"","title":"0.9.2"},{"location":"releases/#other_7","text":"Updated the Quick Start in docs/readme Updated docs with links to queries subpage Added badges for code climate and pepy downloads","title":"Other"},{"location":"releases/#091","text":"","title":"0.9.1"},{"location":"releases/#features_16","text":"Add choices values to OpenAPI specs, so it looks like native Enum field in the result schema.","title":"Features"},{"location":"releases/#fixes_21","text":"Fix choices behavior with fastapi usage when special fields can be not initialized yet but passed as strings etc.","title":"Fixes"},{"location":"releases/#090","text":"","title":"0.9.0"},{"location":"releases/#important_1","text":"Braking Fix: Version 0.8.0 introduced a bug that prevents generation of foreign_keys constraint in the database, both in alembic and during creation through sqlalchemy.engine, this is fixed now. THEREFORE IF YOU USE VERSION >=0.8.0 YOU ARE STRONGLY ADVISED TO UPDATE cause despite that most of the ormar functions are working your database CREATED with ormar (or ormar + alembic) does not have relations and suffer from perspective of performance and data integrity. If you were using ormar to connect to existing database your performance and integrity should be fine nevertheless you should update to reflect all future schema updates in your models.","title":"Important"},{"location":"releases/#breaking_1","text":"Breaking: All foreign_keys and unique constraints now have a name so alembic can identify them in db and not depend on db Breaking: During model construction if Meta class of the Model does not include metadata or database now ModelDefinitionError will be raised instead of generic AttributeError . Breaking: encode/databases used for running the queries does not have a connection pool for sqlite backend, meaning that each querry is run with a new connection and there is no way to enable enforcing ForeignKeys constraints as those are by default turned off on every connection. This is changed in ormar since >=0.9.0 and by default each sqlite3 query has \"PRAGMA foreign_keys=1;\" run so now each sqlite3 connection by default enforces ForeignKey constraints including cascades.","title":"Breaking"},{"location":"releases/#other_8","text":"Update api docs. Add tests for fk creation in db and for cascades in db","title":"Other"},{"location":"releases/#081","text":"","title":"0.8.1"},{"location":"releases/#features_17","text":"Introduce processing of ForwardRef in relations. Now you can create self-referencing models - both ForeignKey and ManyToMany relations. ForwardRef can be used both for to and through Models . Introduce the possibility to perform two same relation joins in one query, so to process complex relations like: 1 2 3 4 5 6 7 B = X = Y // A \\ C = X = Y <= before you could link from X to Y only once in one query unless two different relation were used (two relation fields with different names) Introduce the paginate method that allows to limit/offset by page and page_size . Available for QuerySet and QuerysetProxy .","title":"Features"},{"location":"releases/#other_9","text":"Refactoring and performance optimization in queries and joins. Add python 3.9 to tests and pypi setup. Update API docs and docs -> i.e. split of queries documentation.","title":"Other"},{"location":"releases/#080","text":"","title":"0.8.0"},{"location":"releases/#breaking_2","text":"Breaking: remove() parent from child side in reverse ForeignKey relation now requires passing a relation name , as the same model can be registered multiple times and ormar needs to know from which relation on the parent you want to remove the child. Breaking: applying limit and offset with select_related is by default applied only on the main table before the join -> meaning that not the total number of rows is limited but just number of main models (first one in the query, the one used to construct it). You can still limit all rows from db response with limit_raw_sql=True flag on either limit or offset (or both) Breaking: issuing first() now fetches the first row ordered by the primary key asc (so first one inserted (can be different for non number primary keys - i.e. alphabetical order of string)) Breaking: issuing get() without any filters now fetches the first row ordered by the primary key desc (so should be last one inserted (can be different for non number primary keys - i.e. alphabetical order of string)) Breaking (internal): sqlalchemy columns kept at Meta.columns are no longer bind to table, so you cannot get the column straight from there","title":"Breaking"},{"location":"releases/#features_18","text":"Introduce inheritance . For now two types of inheritance are possible: Mixins - don't subclass ormar.Model , just define fields that are later used on different models (like created_date and updated_date on each child model), only actual models create tables, but those fields from mixins are added Concrete table inheritance - means that parent is marked as abstract=True in Meta class and each child has its own table with columns from the parent and own child columns, kind of similar to Mixins but parent also is a (an abstract) Model To read more check the docs on models -> inheritance section. QuerySet first() can be used with prefetch_related","title":"Features"},{"location":"releases/#fixes_22","text":"Fix minor bug in order_by for primary model order bys Fix in prefetch_query for multiple related_names for the same model. Fix using same related_name on different models leading to the same related Model overwriting each other, now ModelDefinitionError is raised and you need to change the name. Fix order_by overwriting conditions when multiple joins to the same table applied.","title":"Fixes"},{"location":"releases/#docs","text":"Split and cleanup in docs: Divide models section into subsections Divide relations section into subsections Divide fields section into subsections Add model inheritance section Add API (BETA) documentation","title":"Docs"},{"location":"releases/#075","text":"Fix for wrong relation column name in many_to_many relation joins (fix #73 )","title":"0.7.5"},{"location":"releases/#074","text":"Allow multiple relations to the same related model/table. Fix for wrong relation column used in many_to_many relation joins (fix #73 ) Fix for wrong relation population for m2m relations when also fk relation present for same model. Add check if user provide related_name if there are multiple relations to same table on one model. More eager cleaning of the dead weak proxy models.","title":"0.7.4"},{"location":"releases/#073","text":"Fix for setting fetching related model with UUDI pk, which is a string in raw (fix #71 )","title":"0.7.3"},{"location":"releases/#072","text":"Fix for overwriting related models with pk only in Model.update() with fields passed as parameters (fix #70 )","title":"0.7.2"},{"location":"releases/#071","text":"Fix for overwriting related models with pk only in Model.save() (fix #68 )","title":"0.7.1"},{"location":"releases/#070","text":"Breaking: QuerySet bulk_update method now raises ModelPersistenceError for unsaved models passed instead of QueryDefinitionError Breaking: Model initialization with unknown field name now raises ModelError instead of KeyError Added Signals , with pre-defined list signals and decorators: post_delete , post_save , post_update , pre_delete , pre_save , pre_update Add py.typed and modify setup.py for mypy support Performance optimization Updated docs","title":"0.7.0"},{"location":"releases/#062","text":"Performance optimization Fix for bug with pydantic_only fields being required Add property_field decorator that registers a function as a property that will be included in Model.dict() and in fastapi response Update docs","title":"0.6.2"},{"location":"releases/#061","text":"Explicitly set None to excluded nullable fields to avoid pydantic setting a default value (fix #60 ).","title":"0.6.1"},{"location":"releases/#060","text":"Breaking: calling instance.load() when the instance row was deleted from db now raises NoMatch instead of ValueError Breaking: calling add and remove on ReverseForeignKey relation now updates the child model in db setting/removing fk column Breaking: ReverseForeignKey relation now exposes QuerySetProxy API like ManyToMany relation Breaking: querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 Added get_or_create , update_or_create , fields , exclude_fields , exclude , prefetch_related and order_by to QuerySetProxy so now you can use those methods directly from relation Update docs","title":"0.6.0"},{"location":"releases/#055","text":"Fix for alembic autogenaration of migration UUID columns. It should just produce sqlalchemy CHAR(32) or CHAR(36) In order for this to work you have to set user_module_prefix='sa.' (must be equal to sqlalchemy_module_prefix option (default 'sa.'))","title":"0.5.5"},{"location":"releases/#054","text":"Allow to pass uuid_format (allowed 'hex'(default) or 'string') to UUID field to change the format in which it's saved. By default field is saved in hex format (trimmed to 32 chars (without dashes)), but you can pass format='string' to use 36 (with dashes) instead to adjust to existing db or other libraries. Sample: * hex value = c616ab438cce49dbbf4380d109251dce * string value = c616ab43-8cce-49db-bf43-80d109251dce","title":"0.5.4"},{"location":"releases/#053","text":"Fixed bug in Model.dict() method that was ignoring exclude parameter and not include dictionary argument.","title":"0.5.3"},{"location":"releases/#052","text":"Added prefetch_related method to load subsequent models in separate queries. Update docs","title":"0.5.2"},{"location":"releases/#051","text":"Switched to github actions instead of travis Update badges in the docs","title":"0.5.1"},{"location":"releases/#050","text":"Added save status -> you can check if model is saved with ModelInstance.saved property Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantation with __init__ (w/o QuerySet.create or before calling save ) Added Model.upsert(**kwargs) that performs save() if pk not set otherwise update(**kwargs) Added Model.save_related(follow=False) that iterates all related objects in all relations and checks if they are saved. If not it calls upsert() on each of them. Breaking: added raising exceptions if add -ing/ remove -ing not saved (pk is None) models to ManyToMany relation Allow passing dictionaries and sets to fields and exclude_fields Auto translate str and lists to dicts for fields and exclude_fields Breaking: passing nested models to fields and exclude_fields is now by related ForeignKey name and not by target model name Performance optimizations - in modelproxy, newbasemodel - > less queries, some properties are cached on models Cleanup of unused relations code Optional performance dependency orjson added ( strongly recommended ) Updated docs","title":"0.5.0"},{"location":"releases/#044","text":"add exclude_fields() method to exclude fields from sql refactor column names setting (aliases) fix ordering by for column with aliases additional tests for fields and exclude_fields update docs","title":"0.4.4"},{"location":"releases/#043","text":"include properties in models.dict() and model.json()","title":"0.4.3"},{"location":"releases/#042","text":"modify creation of pydantic models to allow returning related models with only pk populated","title":"0.4.2"},{"location":"releases/#041","text":"add order_by method to queryset to allow sorting update docs","title":"0.4.1"},{"location":"releases/#040","text":"Changed notation in Model definition -> now use name = ormar.Field() not name: ormar.Field() Note that old notation is still supported but deprecated and will not play nice with static checkers like mypy and pydantic pycharm plugin Type hint docs and test Use mypy for tests also not, only ormar package Fix scale and precision translation with max_digits and decimal_places pydantic Decimal field Update docs - add best practices for dependencies Refactor metaclass and model_fields to play nice with type hints Add mypy and pydantic plugin to docs Expand the docs on ManyToMany relation","title":"0.4.0"},{"location":"releases/#0311","text":"Fix setting server_default as default field value in python","title":"0.3.11"},{"location":"releases/#0310","text":"Fix postgresql check to avoid exceptions with drivers not installed if using different backend","title":"0.3.10"},{"location":"releases/#039","text":"Fix json schema generation as of #19 Fix for not initialized ManyToMany relations in fastapi copies of ormar.Models Update docs in regard of fastapi use Add tests to verify fastapi/docs proper generation","title":"0.3.9"},{"location":"releases/#038","text":"Added possibility to provide alternative database column names with name parameter to all fields. Fix bug with selecting related ManyToMany fields with fields() if they are empty. Updated documentation","title":"0.3.8"},{"location":"releases/#037","text":"Publish documentation and update readme","title":"0.3.7"},{"location":"releases/#036","text":"Add fields() method to limit the selected columns from database - only nullable columns can be excluded. Added UniqueColumns and constraints list in model Meta to build unique constraints on list of columns. Added UUID field type based on Char(32) column type.","title":"0.3.6"},{"location":"releases/#035","text":"Added bulk_create and bulk_update for operations on multiple objects.","title":"0.3.5"},{"location":"releases/#034","text":"Add queryset level methods * delete * update * get_or_create * update_or_create","title":"0.3.4"},{"location":"releases/#033","text":"Add additional filters - startswith and endswith","title":"0.3.3"},{"location":"releases/#032","text":"Add choices parameter to all fields - limiting the accepted values to ones provided","title":"0.3.2"},{"location":"releases/#031","text":"Added exclude to filter where not conditions. Added tests for mysql and postgres with fixes for postgres. Rafactors and cleanup.","title":"0.3.1"},{"location":"releases/#030","text":"Added ManyToMany field and support for many to many relations","title":"0.3.0"},{"location":"signals/","text":"Signals Signals are a mechanism to fire your piece of code (function / method) whenever given type of event happens in ormar . To achieve this you need to register your receiver for a given type of signal for selected model(s). Defining receivers Given a sample model like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) You can for example define a trigger that will set album.is_best_seller status if it will be played more than 50 times. Import pre_update decorator, for list of currently available decorators/ signals check below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Define your function. Note that each receiver function: has to be callable has to accept first sender argument that receives the class of sending object has to accept **kwargs argument as the parameters send in each ormar.Signal can change at any time so your function has to serve them. has to be async cause callbacks are gathered and awaited. pre_update currently sends only one argument apart from sender and it's instance one. Note how pre_update decorator accepts a senders argument that can be a single model or a list of models, for which you want to run the signal receiver. Currently there is no way to set signal for all models at once without explicitly passing them all into registration of receiver. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Note Note that receivers are defined on a class level -> so even if you connect/disconnect function through instance it will run/ stop running for all operations on that ormar.Model class. Note that our newly created function has instance and class of the instance so you can easily run database queries inside your receivers if you want to. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller You can define same receiver for multiple models at once by passing a list of models to signal decorator. 1 2 3 4 # define a dummy debug function @pre_update ([ Album , Track ]) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) Of course you can also create multiple functions for the same signal and model. Each of them will run at each signal. 1 2 3 4 5 6 7 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) @pre_update ( Album ) async def before_update2 ( sender , instance , ** kwargs ): print ( f 'About to update { sender . get_name () } with pk: { instance . pk } ' ) Note that ormar decorators are the syntactic sugar, you can directly connect your function or method for given signal for given model. Connect accept only one parameter - your receiver function / method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class AlbumAuditor : def __init__ ( self ): self . event_type = \"ALBUM_INSTANCE\" async def before_save ( self , sender , instance , ** kwargs ): await AuditLog ( event_type = f \" { self . event_type } _SAVE\" , event_log = instance . json () ) . save () auditor = AlbumAuditor () pre_save ( Album )( auditor . before_save ) # call above has same result like the one below Album . Meta . signals . pre_save . connect ( auditor . before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . connect ( auditor . before_save ) Warning Note that signals keep the reference to your receiver (not a weakref ) so keep that in mind to avoid circular references. Disconnecting the receivers To disconnect the receiver and stop it for running for given model you need to disconnect it. 1 2 3 4 5 6 7 8 9 10 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # disconnect given function from signal for given Model Album . Meta . signals . pre_save . disconnect ( before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . disconnect ( before_save ) Available signals Warning Note that signals are not send for: bulk operations ( QuerySet.bulk_create and QuerySet.bulk_update ) as they are designed for speed. queyset table level operations ( QuerySet.update and QuerySet.delete ) as they run on the underlying tables (more lak raw sql update/delete operations) and do not have specific instance. pre_save pre_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be saved. post_save post_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model that was saved. pre_update pre_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model to be updated. post_update post_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was updated. pre_delete pre_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be deleted. post_delete post_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was deleted. pre_relation_add pre_relation_add(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\", relation_name: str, passed_args: Dict) Send for Model.relation_name.add() method for ManyToMany relations and reverse side of ForeignKey relation. sender - sender class, instance - instance to which related model is added, child - model being added, relation_name - name of the relation to which child is added, for add signals also passed_kwargs - dict of kwargs passed to add() post_relation_add post_relation_add(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\", relation_name: str, passed_args: Dict) Send for Model.relation_name.add() method for ManyToMany relations and reverse side of ForeignKey relation. sender - sender class, instance - instance to which related model is added, child - model being added, relation_name - name of the relation to which child is added, for add signals also passed_kwargs - dict of kwargs passed to add() pre_relation_remove pre_relation_remove(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\", relation_name: str) Send for Model.relation_name.remove() method for ManyToMany relations and reverse side of ForeignKey relation. sender - sender class, instance - instance to which related model is added, child - model being added, relation_name - name of the relation to which child is added. post_relation_remove post_relation_remove(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\", relation_name: str, passed_args: Dict) Send for Model.relation_name.remove() method for ManyToMany relations and reverse side of ForeignKey relation. sender - sender class, instance - instance to which related model is added, child - model being added, relation_name - name of the relation to which child is added. Defining your own signals Note that you can create your own signals although you will have to send them manually in your code or subclass ormar.Model and trigger your signals there. Creating new signal is super easy. Following example will set a new signal with name your_custom_signal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) Album . Meta . signals . your_custom_signal = ormar . Signal () Album . Meta . signals . your_custom_signal . connect ( your_receiver_name ) Actually under the hood signal is a SignalEmitter instance that keeps a dictionary of know signals, and allows you to access them as attributes. When you try to access a signal that does not exist SignalEmitter will create one for you. So example above can be simplified to. The Signal will be created for you. 1 Album.Meta.signals.your_custom_signal.connect(your_receiver_name) Now to trigger this signal you need to call send method of the Signal. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album ) Note that sender is the only required parameter and it should be ormar Model class. Additional parameters have to be passed as keyword arguments. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album , my_param = True )","title":"Signals"},{"location":"signals/#signals","text":"Signals are a mechanism to fire your piece of code (function / method) whenever given type of event happens in ormar . To achieve this you need to register your receiver for a given type of signal for selected model(s).","title":"Signals"},{"location":"signals/#defining-receivers","text":"Given a sample model like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) You can for example define a trigger that will set album.is_best_seller status if it will be played more than 50 times. Import pre_update decorator, for list of currently available decorators/ signals check below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Define your function. Note that each receiver function: has to be callable has to accept first sender argument that receives the class of sending object has to accept **kwargs argument as the parameters send in each ormar.Signal can change at any time so your function has to serve them. has to be async cause callbacks are gathered and awaited. pre_update currently sends only one argument apart from sender and it's instance one. Note how pre_update decorator accepts a senders argument that can be a single model or a list of models, for which you want to run the signal receiver. Currently there is no way to set signal for all models at once without explicitly passing them all into registration of receiver. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Note Note that receivers are defined on a class level -> so even if you connect/disconnect function through instance it will run/ stop running for all operations on that ormar.Model class. Note that our newly created function has instance and class of the instance so you can easily run database queries inside your receivers if you want to. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller You can define same receiver for multiple models at once by passing a list of models to signal decorator. 1 2 3 4 # define a dummy debug function @pre_update ([ Album , Track ]) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) Of course you can also create multiple functions for the same signal and model. Each of them will run at each signal. 1 2 3 4 5 6 7 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) @pre_update ( Album ) async def before_update2 ( sender , instance , ** kwargs ): print ( f 'About to update { sender . get_name () } with pk: { instance . pk } ' ) Note that ormar decorators are the syntactic sugar, you can directly connect your function or method for given signal for given model. Connect accept only one parameter - your receiver function / method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class AlbumAuditor : def __init__ ( self ): self . event_type = \"ALBUM_INSTANCE\" async def before_save ( self , sender , instance , ** kwargs ): await AuditLog ( event_type = f \" { self . event_type } _SAVE\" , event_log = instance . json () ) . save () auditor = AlbumAuditor () pre_save ( Album )( auditor . before_save ) # call above has same result like the one below Album . Meta . signals . pre_save . connect ( auditor . before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . connect ( auditor . before_save ) Warning Note that signals keep the reference to your receiver (not a weakref ) so keep that in mind to avoid circular references.","title":"Defining receivers"},{"location":"signals/#disconnecting-the-receivers","text":"To disconnect the receiver and stop it for running for given model you need to disconnect it. 1 2 3 4 5 6 7 8 9 10 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # disconnect given function from signal for given Model Album . Meta . signals . pre_save . disconnect ( before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . disconnect ( before_save )","title":"Disconnecting the receivers"},{"location":"signals/#available-signals","text":"Warning Note that signals are not send for: bulk operations ( QuerySet.bulk_create and QuerySet.bulk_update ) as they are designed for speed. queyset table level operations ( QuerySet.update and QuerySet.delete ) as they run on the underlying tables (more lak raw sql update/delete operations) and do not have specific instance.","title":"Available signals"},{"location":"signals/#pre_save","text":"pre_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be saved.","title":"pre_save"},{"location":"signals/#post_save","text":"post_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model that was saved.","title":"post_save"},{"location":"signals/#pre_update","text":"pre_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model to be updated.","title":"pre_update"},{"location":"signals/#post_update","text":"post_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was updated.","title":"post_update"},{"location":"signals/#pre_delete","text":"pre_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be deleted.","title":"pre_delete"},{"location":"signals/#post_delete","text":"post_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was deleted.","title":"post_delete"},{"location":"signals/#pre_relation_add","text":"pre_relation_add(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\", relation_name: str, passed_args: Dict) Send for Model.relation_name.add() method for ManyToMany relations and reverse side of ForeignKey relation. sender - sender class, instance - instance to which related model is added, child - model being added, relation_name - name of the relation to which child is added, for add signals also passed_kwargs - dict of kwargs passed to add()","title":"pre_relation_add"},{"location":"signals/#post_relation_add","text":"post_relation_add(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\", relation_name: str, passed_args: Dict) Send for Model.relation_name.add() method for ManyToMany relations and reverse side of ForeignKey relation. sender - sender class, instance - instance to which related model is added, child - model being added, relation_name - name of the relation to which child is added, for add signals also passed_kwargs - dict of kwargs passed to add()","title":"post_relation_add"},{"location":"signals/#pre_relation_remove","text":"pre_relation_remove(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\", relation_name: str) Send for Model.relation_name.remove() method for ManyToMany relations and reverse side of ForeignKey relation. sender - sender class, instance - instance to which related model is added, child - model being added, relation_name - name of the relation to which child is added.","title":"pre_relation_remove"},{"location":"signals/#post_relation_remove","text":"post_relation_remove(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\", relation_name: str, passed_args: Dict) Send for Model.relation_name.remove() method for ManyToMany relations and reverse side of ForeignKey relation. sender - sender class, instance - instance to which related model is added, child - model being added, relation_name - name of the relation to which child is added.","title":"post_relation_remove"},{"location":"signals/#defining-your-own-signals","text":"Note that you can create your own signals although you will have to send them manually in your code or subclass ormar.Model and trigger your signals there. Creating new signal is super easy. Following example will set a new signal with name your_custom_signal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) Album . Meta . signals . your_custom_signal = ormar . Signal () Album . Meta . signals . your_custom_signal . connect ( your_receiver_name ) Actually under the hood signal is a SignalEmitter instance that keeps a dictionary of know signals, and allows you to access them as attributes. When you try to access a signal that does not exist SignalEmitter will create one for you. So example above can be simplified to. The Signal will be created for you. 1 Album.Meta.signals.your_custom_signal.connect(your_receiver_name) Now to trigger this signal you need to call send method of the Signal. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album ) Note that sender is the only required parameter and it should be ormar Model class. Additional parameters have to be passed as keyword arguments. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album , my_param = True )","title":"Defining your own signals"},{"location":"transactions/","text":"Transactions Database transactions are supported thanks to encode/databases which is used to issue async queries. Basic usage To use transactions use database.transaction as async context manager: 1 2 3 4 5 async with database . transaction (): # everyting called here will be one transaction await Model1 () . save () await Model2 () . save () ... Note Note that it has to be the same database that the one used in Model's Meta class. To avoid passing database instance around in your code you can extract the instance from each Model . Database provided during declaration of ormar.Model is available through Meta.database and can be reached from both class and instance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import databases import sqlalchemy import ormar metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///\" ) class Author ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 255 ) # database is accessible from class database = Author . Meta . database # as well as from instance author = Author ( name = \"Stephen King\" ) database = author . Meta . database You can also use .transaction() as a function decorator on any async function: 1 2 3 @database . transaction () async def create_users ( request ): ... Transaction blocks are managed as task-local state. Nested transactions are fully supported, and are implemented using database savepoints. Manual commits/ rollbacks For a lower-level transaction API you can trigger it manually 1 2 3 4 5 6 7 8 transaction = await database . transaction () try : await transaction . start () ... except : await transaction . rollback () else : await transaction . commit () Testing Transactions can also be useful during testing when you can apply force rollback and you do not have to clean the data after each test. 1 2 3 4 5 6 @pytest . mark . asyncio async def sample_test (): async with database : async with database . transaction ( force_rollback = True ): # your test code here ...","title":"Transactions"},{"location":"transactions/#transactions","text":"Database transactions are supported thanks to encode/databases which is used to issue async queries.","title":"Transactions"},{"location":"transactions/#basic-usage","text":"To use transactions use database.transaction as async context manager: 1 2 3 4 5 async with database . transaction (): # everyting called here will be one transaction await Model1 () . save () await Model2 () . save () ... Note Note that it has to be the same database that the one used in Model's Meta class. To avoid passing database instance around in your code you can extract the instance from each Model . Database provided during declaration of ormar.Model is available through Meta.database and can be reached from both class and instance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import databases import sqlalchemy import ormar metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///\" ) class Author ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 255 ) # database is accessible from class database = Author . Meta . database # as well as from instance author = Author ( name = \"Stephen King\" ) database = author . Meta . database You can also use .transaction() as a function decorator on any async function: 1 2 3 @database . transaction () async def create_users ( request ): ... Transaction blocks are managed as task-local state. Nested transactions are fully supported, and are implemented using database savepoints.","title":"Basic usage"},{"location":"transactions/#manual-commits-rollbacks","text":"For a lower-level transaction API you can trigger it manually 1 2 3 4 5 6 7 8 transaction = await database . transaction () try : await transaction . start () ... except : await transaction . rollback () else : await transaction . commit ()","title":"Manual commits/ rollbacks"},{"location":"transactions/#testing","text":"Transactions can also be useful during testing when you can apply force rollback and you do not have to clean the data after each test. 1 2 3 4 5 6 @pytest . mark . asyncio async def sample_test (): async with database : async with database . transaction ( force_rollback = True ): # your test code here ...","title":"Testing"},{"location":"api/","text":"Contains documentation of the ormar internal API. Note that this is a technical part of the documentation intended for ormar contributors. Note For completeness as of now even the internal and special methods are documented and exposed in API docs. Warning The current API docs version is a beta and not all methods are documented, also some of redundant items are included since it was partially auto generated. Danger Ormar is still under development, and the internals can change at any moment . You shouldn't rely even on the \"public\" methods if they are not documented in the normal part of the docs. High level overview Ormar is divided into packages for maintainability and ease of development. Below you can find a short description of the structure of the whole project and individual packages. Models Contains the actual ormar.Model class, which is based on: ormar.NewBaseModel which in turns: inherits from pydantic.BaseModel , uses ormar.ModelMetaclass for all heavy lifting, relations declaration, parsing ormar fields, creating sqlalchemy columns and tables etc. There is a lot of tasks during class creation so ormar is using a lot of helpers methods separated by functionality: pydantic , sqlachemy , relations & models located in helpers submodule. inherits from ormar.ModelTableProxy that combines Mixins providing a special additional behavior for ormar.Models AliasMixin - handling of column aliases, which are names changed only in db ExcludableMixin - handling excluding and including fields in dict() and database calls MergeModelMixin - handling merging Models initialized from raw sql raws into Models that needs to be merged, in example parent models in join query that duplicates in raw response. PrefetchQueryMixin - handling resolving relations and ids of models to extract during issuing subsequent queries in prefetch_related RelationMixin - handling resolving relations names, related fields etc. SavePrepareMixin - handling converting related models to their pk values, translating ormar field names into aliases etc. Fields Contains ormar.BaseField that is a base for all fields. All basic types are declared in model_fields , while relation fields are located in: foreign_key : ForeignKey relation, expanding relations meaning initializing nested models, creating dummy models with pk only that skips validation etc. many_to_many : ManyToMany relation that do not have a lot of logic on its own. Related to fields is a @property_field decorator that is located in decorators.property_field . There is also a special UUID field declaration for sqlalchemy that is based on CHAR field type. Query Set Package that handles almost all interactions with db (some small parts are in ormar.Model and in ormar.QuerysetProxy ). Provides a QuerySet that is exposed on each Model as objects property. Have a vast number of methods to query, filter, create, update and delete database rows. Actual construction of the queries is delegated to Query class which in tern uses SqlJoin to construct joins Clause to convert filter and exclude conditions into sql FilterQuery to apply filter clauses on query OrderQuery to apply order by clauses on query LimitQuery to apply limit clause on query OffsetQuery to apply offset clause on query For prefetch_related the same is done by PrefetchQuery Common helpers functions are extracted into utils Relations Handles registering relations, adding/removing to relations as well as returning the actual related models instead of relation fields declared on Models. Each ormar.Model has its own RelationManager registered under _orm property. RelationManager handles Relations between two different models In case of reverse relations or m2m relations the RelationProxy is used which is basically a list with some special methods that keeps a reference to a list of related models Also, for reverse relations and m2m relations QuerySetProxy is exposed, that is used to query the already pre-filtered related models and handles Through models instances for m2m relations, while delegating actual queries to QuerySet AliasManager handles registration of aliases for relations that are used in queries. In order to be able to link multiple times to the same table in one query each link has to have unique alias to properly identify columns and extract proper values. Kind of global registry, aliases are randomly generated, so might differ on each run. Common helpers functions are extracted into utils Signals Handles sending signals on particular events. SignalEmitter is registered on each ormar.Model , that allows to register any number of receiver functions that will be notified on each event. For now only combination of (pre, post) (save, update, delete) events are pre populated for user although it's easy to register user Signal s. set of decorators is prepared, each corresponding to one of the builtin signals, that can be used to mark functions/methods that should become receivers, those decorators are located in decorators.signals . You can register same function to different ormar.Models but each Model has it's own Emitter that is independednt and issued on events for given Model. Currently, there is no way to register global Signal triggered for all models. Exceptions Gathers all exceptions specific to ormar . All ormar exceptions inherit from AsyncOrmException .","title":"Index"},{"location":"api/#high-level-overview","text":"Ormar is divided into packages for maintainability and ease of development. Below you can find a short description of the structure of the whole project and individual packages.","title":"High level overview"},{"location":"api/#models","text":"Contains the actual ormar.Model class, which is based on: ormar.NewBaseModel which in turns: inherits from pydantic.BaseModel , uses ormar.ModelMetaclass for all heavy lifting, relations declaration, parsing ormar fields, creating sqlalchemy columns and tables etc. There is a lot of tasks during class creation so ormar is using a lot of helpers methods separated by functionality: pydantic , sqlachemy , relations & models located in helpers submodule. inherits from ormar.ModelTableProxy that combines Mixins providing a special additional behavior for ormar.Models AliasMixin - handling of column aliases, which are names changed only in db ExcludableMixin - handling excluding and including fields in dict() and database calls MergeModelMixin - handling merging Models initialized from raw sql raws into Models that needs to be merged, in example parent models in join query that duplicates in raw response. PrefetchQueryMixin - handling resolving relations and ids of models to extract during issuing subsequent queries in prefetch_related RelationMixin - handling resolving relations names, related fields etc. SavePrepareMixin - handling converting related models to their pk values, translating ormar field names into aliases etc.","title":"Models"},{"location":"api/#fields","text":"Contains ormar.BaseField that is a base for all fields. All basic types are declared in model_fields , while relation fields are located in: foreign_key : ForeignKey relation, expanding relations meaning initializing nested models, creating dummy models with pk only that skips validation etc. many_to_many : ManyToMany relation that do not have a lot of logic on its own. Related to fields is a @property_field decorator that is located in decorators.property_field . There is also a special UUID field declaration for sqlalchemy that is based on CHAR field type.","title":"Fields"},{"location":"api/#query-set","text":"Package that handles almost all interactions with db (some small parts are in ormar.Model and in ormar.QuerysetProxy ). Provides a QuerySet that is exposed on each Model as objects property. Have a vast number of methods to query, filter, create, update and delete database rows. Actual construction of the queries is delegated to Query class which in tern uses SqlJoin to construct joins Clause to convert filter and exclude conditions into sql FilterQuery to apply filter clauses on query OrderQuery to apply order by clauses on query LimitQuery to apply limit clause on query OffsetQuery to apply offset clause on query For prefetch_related the same is done by PrefetchQuery Common helpers functions are extracted into utils","title":"Query Set"},{"location":"api/#relations","text":"Handles registering relations, adding/removing to relations as well as returning the actual related models instead of relation fields declared on Models. Each ormar.Model has its own RelationManager registered under _orm property. RelationManager handles Relations between two different models In case of reverse relations or m2m relations the RelationProxy is used which is basically a list with some special methods that keeps a reference to a list of related models Also, for reverse relations and m2m relations QuerySetProxy is exposed, that is used to query the already pre-filtered related models and handles Through models instances for m2m relations, while delegating actual queries to QuerySet AliasManager handles registration of aliases for relations that are used in queries. In order to be able to link multiple times to the same table in one query each link has to have unique alias to properly identify columns and extract proper values. Kind of global registry, aliases are randomly generated, so might differ on each run. Common helpers functions are extracted into utils","title":"Relations"},{"location":"api/#signals","text":"Handles sending signals on particular events. SignalEmitter is registered on each ormar.Model , that allows to register any number of receiver functions that will be notified on each event. For now only combination of (pre, post) (save, update, delete) events are pre populated for user although it's easy to register user Signal s. set of decorators is prepared, each corresponding to one of the builtin signals, that can be used to mark functions/methods that should become receivers, those decorators are located in decorators.signals . You can register same function to different ormar.Models but each Model has it's own Emitter that is independednt and issued on events for given Model. Currently, there is no way to register global Signal triggered for all models.","title":"Signals"},{"location":"api/#exceptions","text":"Gathers all exceptions specific to ormar . All ormar exceptions inherit from AsyncOrmException .","title":"Exceptions"},{"location":"api/exceptions/","text":"exceptions Gathers all exceptions thrown by ormar. AsyncOrmException Objects 1 class AsyncOrmException ( Exception ) Base ormar Exception ModelDefinitionError Objects 1 class ModelDefinitionError ( AsyncOrmException ) Raised for errors related to the model definition itself: setting @property_field on method with arguments other than func(self) defining a Field without required parameters defining a model with more than one primary_key defining a model without primary_key setting primary_key column as pydantic_only ModelError Objects 1 class ModelError ( AsyncOrmException ) Raised for initialization of model with non-existing field keyword. NoMatch Objects 1 class NoMatch ( AsyncOrmException ) Raised for database queries that has no matching result (empty result). MultipleMatches Objects 1 class MultipleMatches ( AsyncOrmException ) Raised for database queries that should return one row (i.e. get, first etc.) but has multiple matching results in response. QueryDefinitionError Objects 1 class QueryDefinitionError ( AsyncOrmException ) Raised for errors in query definition: using contains or icontains filter with instance of the Model using Queryset.update() without filter and setting each flag to True using Queryset.delete() without filter and setting each flag to True ModelPersistenceError Objects 1 class ModelPersistenceError ( AsyncOrmException ) Raised for update of models without primary_key set (cannot retrieve from db) or for saving a model with relation to unsaved model (cannot extract fk value). SignalDefinitionError Objects 1 class SignalDefinitionError ( AsyncOrmException ) Raised when non callable receiver is passed as signal callback.","title":"Exceptions"},{"location":"api/exceptions/#exceptions","text":"Gathers all exceptions thrown by ormar.","title":"exceptions"},{"location":"api/exceptions/#asyncormexception-objects","text":"1 class AsyncOrmException ( Exception ) Base ormar Exception","title":"AsyncOrmException Objects"},{"location":"api/exceptions/#modeldefinitionerror-objects","text":"1 class ModelDefinitionError ( AsyncOrmException ) Raised for errors related to the model definition itself: setting @property_field on method with arguments other than func(self) defining a Field without required parameters defining a model with more than one primary_key defining a model without primary_key setting primary_key column as pydantic_only","title":"ModelDefinitionError Objects"},{"location":"api/exceptions/#modelerror-objects","text":"1 class ModelError ( AsyncOrmException ) Raised for initialization of model with non-existing field keyword.","title":"ModelError Objects"},{"location":"api/exceptions/#nomatch-objects","text":"1 class NoMatch ( AsyncOrmException ) Raised for database queries that has no matching result (empty result).","title":"NoMatch Objects"},{"location":"api/exceptions/#multiplematches-objects","text":"1 class MultipleMatches ( AsyncOrmException ) Raised for database queries that should return one row (i.e. get, first etc.) but has multiple matching results in response.","title":"MultipleMatches Objects"},{"location":"api/exceptions/#querydefinitionerror-objects","text":"1 class QueryDefinitionError ( AsyncOrmException ) Raised for errors in query definition: using contains or icontains filter with instance of the Model using Queryset.update() without filter and setting each flag to True using Queryset.delete() without filter and setting each flag to True","title":"QueryDefinitionError Objects"},{"location":"api/exceptions/#modelpersistenceerror-objects","text":"1 class ModelPersistenceError ( AsyncOrmException ) Raised for update of models without primary_key set (cannot retrieve from db) or for saving a model with relation to unsaved model (cannot extract fk value).","title":"ModelPersistenceError Objects"},{"location":"api/exceptions/#signaldefinitionerror-objects","text":"1 class SignalDefinitionError ( AsyncOrmException ) Raised when non callable receiver is passed as signal callback.","title":"SignalDefinitionError Objects"},{"location":"api/fields/base-field/","text":"fields.base BaseField Objects 1 class BaseField ( FieldInfo ) BaseField serves as a parent class for all basic Fields in ormar. It keeps all common parameters available for all fields as well as set of useful functions. All values are kept as class variables, ormar Fields are never instantiated. Subclasses pydantic.FieldInfo to keep the fields related to pydantic field types like ConstrainedStr is_valid_uni_relation 1 | is_valid_uni_relation () -> bool Checks if field is a relation definition but only for ForeignKey relation, so excludes ManyToMany fields, as well as virtual ForeignKey (second side of FK relation). Is used to define if a field is a db ForeignKey column that should be saved/populated when dealing with internal/own Model columns only. Returns : result of the check :rtype: bool get_alias 1 | get_alias () -> str Used to translate Model column names to database column names during db queries. Returns : returns custom database column name if defined by user, otherwise field name in ormar/pydantic :rtype: str get_pydantic_default 1 | get_pydantic_default () -> Dict Generates base pydantic.FieldInfo with only default and optionally required to fix pydantic Json field being set to required=False. Used in an ormar Model Metaclass. Returns : instance of base pydantic.FieldInfo :rtype: pydantic.FieldInfo default_value 1 | default_value ( use_server : bool = False ) -> Optional [ Dict ] Returns a FieldInfo instance with populated default (static) or default_factory (function). If the field is a autoincrement primary key the default is None. Otherwise field have to has either default, or default_factory populated. If all default conditions fail None is returned. Used in converting to pydantic FieldInfo. Arguments : use_server : flag marking if server_default should be treated as default value, default False :type use_server: bool Returns : returns a call to pydantic.Field which is returning a FieldInfo instance :rtype: Optional[pydantic.FieldInfo] get_default 1 | get_default ( use_server : bool = False ) -> Any Return default value for a field. If the field is Callable the function is called and actual result is returned. Used to populate default_values for pydantic Model in ormar Model Metaclass. Arguments : use_server : flag marking if server_default should be treated as default value, default False :type use_server: bool Returns : default value for the field if set, otherwise implicit None :rtype: Any has_default 1 | has_default ( use_server : bool = True ) -> bool Checks if the field has default value set. Arguments : use_server : flag marking if server_default should be treated as default value, default False :type use_server: bool Returns : result of the check if default value is set :rtype: bool is_auto_primary_key 1 | is_auto_primary_key () -> bool Checks if field is first a primary key and if it, it's than check if it's set to autoincrement. Autoincrement primary_key is nullable/optional. Returns : result of the check for primary key and autoincrement :rtype: bool construct_constraints 1 | construct_constraints () -> List Converts list of ormar constraints into sqlalchemy ForeignKeys. Has to be done dynamically as sqlalchemy binds ForeignKey to the table. And we need a new ForeignKey for subclasses of current model Returns : List of sqlalchemy foreign keys - by default one. :rtype: List[sqlalchemy.schema.ForeignKey] get_column 1 | get_column ( name : str ) -> sqlalchemy . Column Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table. Populates name, column type constraints, as well as a number of parameters like primary_key, index, unique, nullable, default and server_default. Arguments : name : name of the db column - used if alias is not set :type name: str Returns : actual definition of the database column as sqlalchemy requires. :rtype: sqlalchemy.Column _get_encrypted_column 1 | _get_encrypted_column ( name : str ) -> sqlalchemy . Column Returns EncryptedString column type instead of actual column. Arguments : name : column name :type name: str Returns : newly defined column :rtype: sqlalchemy.Column expand_relationship 1 | expand_relationship ( value : Any , child : Union [ \"Model\" , \"NewBaseModel\" ], to_register : bool = True ) -> Any Function overwritten for relations, in basic field the value is returned as is. For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\". Arguments : value : a Model field value, returned untouched for non relation fields. :type value: Any child : a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : returns untouched value for normal fields, expands only for relations :rtype: Any set_self_reference_flag 1 | set_self_reference_flag () -> None Sets self_reference to True if field to and owner are same model. Returns : None :rtype: None has_unresolved_forward_refs 1 | has_unresolved_forward_refs () -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : result of the check :rtype: bool evaluate_forward_ref 1 | evaluate_forward_ref ( globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns : global namespace :type globalns: Any localns : local namespace :type localns: Any Returns : None :rtype: None get_related_name 1 | get_related_name () -> str Returns name to use for reverse relation. It's either set as related_name or by default it's owner model. get_name + 's' Returns : name of the related_name or default related name. :rtype: str","title":"Base Field"},{"location":"api/fields/base-field/#fieldsbase","text":"","title":"fields.base"},{"location":"api/fields/base-field/#basefield-objects","text":"1 class BaseField ( FieldInfo ) BaseField serves as a parent class for all basic Fields in ormar. It keeps all common parameters available for all fields as well as set of useful functions. All values are kept as class variables, ormar Fields are never instantiated. Subclasses pydantic.FieldInfo to keep the fields related to pydantic field types like ConstrainedStr","title":"BaseField Objects"},{"location":"api/fields/base-field/#is_valid_uni_relation","text":"1 | is_valid_uni_relation () -> bool Checks if field is a relation definition but only for ForeignKey relation, so excludes ManyToMany fields, as well as virtual ForeignKey (second side of FK relation). Is used to define if a field is a db ForeignKey column that should be saved/populated when dealing with internal/own Model columns only. Returns : result of the check :rtype: bool","title":"is_valid_uni_relation"},{"location":"api/fields/base-field/#get_alias","text":"1 | get_alias () -> str Used to translate Model column names to database column names during db queries. Returns : returns custom database column name if defined by user, otherwise field name in ormar/pydantic :rtype: str","title":"get_alias"},{"location":"api/fields/base-field/#get_pydantic_default","text":"1 | get_pydantic_default () -> Dict Generates base pydantic.FieldInfo with only default and optionally required to fix pydantic Json field being set to required=False. Used in an ormar Model Metaclass. Returns : instance of base pydantic.FieldInfo :rtype: pydantic.FieldInfo","title":"get_pydantic_default"},{"location":"api/fields/base-field/#default_value","text":"1 | default_value ( use_server : bool = False ) -> Optional [ Dict ] Returns a FieldInfo instance with populated default (static) or default_factory (function). If the field is a autoincrement primary key the default is None. Otherwise field have to has either default, or default_factory populated. If all default conditions fail None is returned. Used in converting to pydantic FieldInfo. Arguments : use_server : flag marking if server_default should be treated as default value, default False :type use_server: bool Returns : returns a call to pydantic.Field which is returning a FieldInfo instance :rtype: Optional[pydantic.FieldInfo]","title":"default_value"},{"location":"api/fields/base-field/#get_default","text":"1 | get_default ( use_server : bool = False ) -> Any Return default value for a field. If the field is Callable the function is called and actual result is returned. Used to populate default_values for pydantic Model in ormar Model Metaclass. Arguments : use_server : flag marking if server_default should be treated as default value, default False :type use_server: bool Returns : default value for the field if set, otherwise implicit None :rtype: Any","title":"get_default"},{"location":"api/fields/base-field/#has_default","text":"1 | has_default ( use_server : bool = True ) -> bool Checks if the field has default value set. Arguments : use_server : flag marking if server_default should be treated as default value, default False :type use_server: bool Returns : result of the check if default value is set :rtype: bool","title":"has_default"},{"location":"api/fields/base-field/#is_auto_primary_key","text":"1 | is_auto_primary_key () -> bool Checks if field is first a primary key and if it, it's than check if it's set to autoincrement. Autoincrement primary_key is nullable/optional. Returns : result of the check for primary key and autoincrement :rtype: bool","title":"is_auto_primary_key"},{"location":"api/fields/base-field/#construct_constraints","text":"1 | construct_constraints () -> List Converts list of ormar constraints into sqlalchemy ForeignKeys. Has to be done dynamically as sqlalchemy binds ForeignKey to the table. And we need a new ForeignKey for subclasses of current model Returns : List of sqlalchemy foreign keys - by default one. :rtype: List[sqlalchemy.schema.ForeignKey]","title":"construct_constraints"},{"location":"api/fields/base-field/#get_column","text":"1 | get_column ( name : str ) -> sqlalchemy . Column Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table. Populates name, column type constraints, as well as a number of parameters like primary_key, index, unique, nullable, default and server_default. Arguments : name : name of the db column - used if alias is not set :type name: str Returns : actual definition of the database column as sqlalchemy requires. :rtype: sqlalchemy.Column","title":"get_column"},{"location":"api/fields/base-field/#_get_encrypted_column","text":"1 | _get_encrypted_column ( name : str ) -> sqlalchemy . Column Returns EncryptedString column type instead of actual column. Arguments : name : column name :type name: str Returns : newly defined column :rtype: sqlalchemy.Column","title":"_get_encrypted_column"},{"location":"api/fields/base-field/#expand_relationship","text":"1 | expand_relationship ( value : Any , child : Union [ \"Model\" , \"NewBaseModel\" ], to_register : bool = True ) -> Any Function overwritten for relations, in basic field the value is returned as is. For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\". Arguments : value : a Model field value, returned untouched for non relation fields. :type value: Any child : a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : returns untouched value for normal fields, expands only for relations :rtype: Any","title":"expand_relationship"},{"location":"api/fields/base-field/#set_self_reference_flag","text":"1 | set_self_reference_flag () -> None Sets self_reference to True if field to and owner are same model. Returns : None :rtype: None","title":"set_self_reference_flag"},{"location":"api/fields/base-field/#has_unresolved_forward_refs","text":"1 | has_unresolved_forward_refs () -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : result of the check :rtype: bool","title":"has_unresolved_forward_refs"},{"location":"api/fields/base-field/#evaluate_forward_ref","text":"1 | evaluate_forward_ref ( globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns : global namespace :type globalns: Any localns : local namespace :type localns: Any Returns : None :rtype: None","title":"evaluate_forward_ref"},{"location":"api/fields/base-field/#get_related_name","text":"1 | get_related_name () -> str Returns name to use for reverse relation. It's either set as related_name or by default it's owner model. get_name + 's' Returns : name of the related_name or default related name. :rtype: str","title":"get_related_name"},{"location":"api/fields/decorators/","text":"decorators.property_field property_field 1 property_field ( func : Callable ) -> Union [ property , Callable ] Decorator to set a property like function on Model to be exposed as field in dict() and fastapi response. Although you can decorate a @property field like this and this will work, mypy validation will complain about this. Note that \"fields\" exposed like this do not go through validation. Raises : ModelDefinitionError : if method has any other argument than self. Arguments : func : decorated function to be exposed :type func: Callable Returns : decorated function passed in func param, with set property_field = True :rtype: Union[property, Callable]","title":"Decorators"},{"location":"api/fields/decorators/#decoratorsproperty_field","text":"","title":"decorators.property_field"},{"location":"api/fields/decorators/#property_field","text":"1 property_field ( func : Callable ) -> Union [ property , Callable ] Decorator to set a property like function on Model to be exposed as field in dict() and fastapi response. Although you can decorate a @property field like this and this will work, mypy validation will complain about this. Note that \"fields\" exposed like this do not go through validation. Raises : ModelDefinitionError : if method has any other argument than self. Arguments : func : decorated function to be exposed :type func: Callable Returns : decorated function passed in func param, with set property_field = True :rtype: Union[property, Callable]","title":"property_field"},{"location":"api/fields/foreign-key/","text":"fields.foreign_key create_dummy_instance 1 create_dummy_instance ( fk : Type [ \"T\" ], pk : Any = None ) -> \"T\" Ormar never returns you a raw data. So if you have a related field that has a value populated it will construct you a Model instance out of it. Creates a \"fake\" instance of passed Model from pk value. The instantiated Model has only pk value filled. To achieve this pk_only flag has to be passed as it skips the validation. If the nested related Models are required they are set with -1 as pk value. Arguments : fk : class of the related Model to which instance should be constructed :type fk: Model class pk : value of the primary_key column :type pk: Any Returns : Model instance populated with only pk :rtype: Model create_dummy_model 1 create_dummy_model ( base_model : Type [ \"T\" ], pk_field : Union [ BaseField , \"ForeignKeyField\" , \"ManyToManyField\" ]) -> Type [ \"BaseModel\" ] Used to construct a dummy pydantic model for type hints and pydantic validation. Populates only pk field and set it to desired type. Arguments : base_model : class of target dummy model :type base_model: Model class pk_field : ormar Field to be set on pydantic Model :type pk_field: Union[BaseField, \"ForeignKeyField\", \"ManyToManyField\"] Returns : constructed dummy model :rtype: pydantic.BaseModel populate_fk_params_based_on_to_model 1 populate_fk_params_based_on_to_model ( to : Type [ \"T\" ], nullable : bool , onupdate : str = None , ondelete : str = None ) -> Tuple [ Any , List , Any ] Based on target to model to which relation leads to populates the type of the pydantic field to use, ForeignKey constraint and type of the target column field. Arguments : to : target related ormar Model :type to: Model class nullable : marks field as optional/ required :type nullable: bool onupdate : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. :type onupdate: str ondelete : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. :type ondelete: str Returns : tuple with target pydantic type, list of fk constraints and target col type :rtype: Tuple[Any, List, Any] validate_not_allowed_fields 1 validate_not_allowed_fields ( kwargs : Dict ) -> None Verifies if not allowed parameters are set on relation models. Usually they are omitted later anyway but this way it's explicitly notify the user that it's not allowed/ supported. Raises : ModelDefinitionError : if any forbidden field is set Arguments : kwargs : dict of kwargs to verify passed to relation field :type kwargs: Dict UniqueColumns Objects 1 class UniqueColumns ( UniqueConstraint ) Subclass of sqlalchemy.UniqueConstraint. Used to avoid importing anything from sqlalchemy by user. ForeignKeyConstraint Objects 1 2 @dataclass class ForeignKeyConstraint () Internal container to store ForeignKey definitions used later to produce sqlalchemy.ForeignKeys ForeignKey 1 ForeignKey ( to : \"ToType\" , * , name : str = None , unique : bool = False , nullable : bool = True , related_name : str = None , virtual : bool = False , onupdate : str = None , ondelete : str = None , ** kwargs : Any , ,) -> \"T\" Despite a name it's a function that returns constructed ForeignKeyField. This function is actually used in model declaration (as ormar.ForeignKey(ToModel)). Accepts number of relation setting parameters as well as all BaseField ones. Arguments : to : target related ormar Model :type to: Model class name : name of the database field - later called alias :type name: str unique : parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool nullable : marks field as optional/ required :type nullable: bool related_name : name of reversed FK relation populated for you on to model :type related_name: str virtual : marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool onupdate : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. :type onupdate: str ondelete : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. :type ondelete: str kwargs : all other args to be populated by BaseField :type kwargs: Any Returns : ormar ForeignKeyField with relation to selected model :rtype: ForeignKeyField ForeignKeyField Objects 1 class ForeignKeyField ( BaseField ) Actual class returned from ForeignKey function call and stored in model_fields. get_source_related_name 1 | get_source_related_name () -> str Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as related_name or by default it's owner model. get_name + 's' Returns : name of the related_name or default related name. :rtype: str get_related_name 1 | get_related_name () -> str Returns name to use for reverse relation. It's either set as related_name or by default it's owner model. get_name + 's' Returns : name of the related_name or default related name. :rtype: str default_target_field_name 1 | default_target_field_name () -> str Returns default target model name on through model. Returns : name of the field :rtype: str default_source_field_name 1 | default_source_field_name () -> str Returns default target model name on through model. Returns : name of the field :rtype: str evaluate_forward_ref 1 | evaluate_forward_ref ( globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns : global namespace :type globalns: Any localns : local namespace :type localns: Any Returns : None :rtype: None _extract_model_from_sequence 1 | _extract_model_from_sequence ( value : List , child : \"Model\" , to_register : bool ) -> List [ \"Model\" ] Takes a list of Models and registers them on parent. Registration is mutual, so children have also reference to parent. Used in reverse FK relations. Arguments : value : list of Model :type value: List child : child/ related Model :type child: Model to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : list (if needed) registered Models :rtype: List[\"Model\"] _register_existing_model 1 | _register_existing_model ( value : \"Model\" , child : \"Model\" , to_register : bool ) -> \"Model\" Takes already created instance and registers it for parent. Registration is mutual, so children have also reference to parent. Used in reverse FK relations and normal FK for single models. Arguments : value : already instantiated Model :type value: Model child : child/ related Model :type child: Model to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : (if needed) registered Model :rtype: Model _construct_model_from_dict 1 | _construct_model_from_dict ( value : dict , child : \"Model\" , to_register : bool ) -> \"Model\" Takes a dictionary, creates a instance and registers it for parent. If dictionary contains only one field and it's a pk it is a pk_only model. Registration is mutual, so children have also reference to parent. Used in normal FK for dictionaries. Arguments : value : dictionary of a Model :type value: dict child : child/ related Model :type child: Model to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : (if needed) registered Model :rtype: Model _construct_model_from_pk 1 | _construct_model_from_pk ( value : Any , child : \"Model\" , to_register : bool ) -> \"Model\" Takes a pk value, creates a dummy instance and registers it for parent. Registration is mutual, so children have also reference to parent. Used in normal FK for dictionaries. Arguments : value : value of a related pk / fk column :type value: Any child : child/ related Model :type child: Model to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : (if needed) registered Model :rtype: Model register_relation 1 | register_relation ( model : \"Model\" , child : \"Model\" ) -> None Registers relation between parent and child in relation manager. Relation manager is kep on each model (different instance). Used in Metaclass and sometimes some relations are missing (i.e. cloned Models in fastapi might miss one). Arguments : model : parent model (with relation definition) :type model: Model class child : child model :type child: Model class has_unresolved_forward_refs 1 | has_unresolved_forward_refs () -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : result of the check :rtype: bool expand_relationship 1 | expand_relationship ( value : Any , child : Union [ \"Model\" , \"NewBaseModel\" ], to_register : bool = True ) -> Optional [ Union [ \"Model\" , List [ \"Model\" ]]] For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\". Selects the appropriate constructor based on a passed value. Arguments : value : a Model field value, returned untouched for non relation fields. :type value: Any child : a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : returns a Model or a list of Models :rtype: Optional[Union[\"Model\", List[\"Model\"]]] get_relation_name 1 | get_relation_name () -> str Returns name of the relation, which can be a own name or through model names for m2m models Returns : result of the check :rtype: bool get_source_model 1 | get_source_model () -> Type [ \"Model\" ] Returns model from which the relation comes -> either owner or through model Returns : source model :rtype: Type[\"Model\"]","title":"Foreign Key"},{"location":"api/fields/foreign-key/#fieldsforeign_key","text":"","title":"fields.foreign_key"},{"location":"api/fields/foreign-key/#create_dummy_instance","text":"1 create_dummy_instance ( fk : Type [ \"T\" ], pk : Any = None ) -> \"T\" Ormar never returns you a raw data. So if you have a related field that has a value populated it will construct you a Model instance out of it. Creates a \"fake\" instance of passed Model from pk value. The instantiated Model has only pk value filled. To achieve this pk_only flag has to be passed as it skips the validation. If the nested related Models are required they are set with -1 as pk value. Arguments : fk : class of the related Model to which instance should be constructed :type fk: Model class pk : value of the primary_key column :type pk: Any Returns : Model instance populated with only pk :rtype: Model","title":"create_dummy_instance"},{"location":"api/fields/foreign-key/#create_dummy_model","text":"1 create_dummy_model ( base_model : Type [ \"T\" ], pk_field : Union [ BaseField , \"ForeignKeyField\" , \"ManyToManyField\" ]) -> Type [ \"BaseModel\" ] Used to construct a dummy pydantic model for type hints and pydantic validation. Populates only pk field and set it to desired type. Arguments : base_model : class of target dummy model :type base_model: Model class pk_field : ormar Field to be set on pydantic Model :type pk_field: Union[BaseField, \"ForeignKeyField\", \"ManyToManyField\"] Returns : constructed dummy model :rtype: pydantic.BaseModel","title":"create_dummy_model"},{"location":"api/fields/foreign-key/#populate_fk_params_based_on_to_model","text":"1 populate_fk_params_based_on_to_model ( to : Type [ \"T\" ], nullable : bool , onupdate : str = None , ondelete : str = None ) -> Tuple [ Any , List , Any ] Based on target to model to which relation leads to populates the type of the pydantic field to use, ForeignKey constraint and type of the target column field. Arguments : to : target related ormar Model :type to: Model class nullable : marks field as optional/ required :type nullable: bool onupdate : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. :type onupdate: str ondelete : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. :type ondelete: str Returns : tuple with target pydantic type, list of fk constraints and target col type :rtype: Tuple[Any, List, Any]","title":"populate_fk_params_based_on_to_model"},{"location":"api/fields/foreign-key/#validate_not_allowed_fields","text":"1 validate_not_allowed_fields ( kwargs : Dict ) -> None Verifies if not allowed parameters are set on relation models. Usually they are omitted later anyway but this way it's explicitly notify the user that it's not allowed/ supported. Raises : ModelDefinitionError : if any forbidden field is set Arguments : kwargs : dict of kwargs to verify passed to relation field :type kwargs: Dict","title":"validate_not_allowed_fields"},{"location":"api/fields/foreign-key/#uniquecolumns-objects","text":"1 class UniqueColumns ( UniqueConstraint ) Subclass of sqlalchemy.UniqueConstraint. Used to avoid importing anything from sqlalchemy by user.","title":"UniqueColumns Objects"},{"location":"api/fields/foreign-key/#foreignkeyconstraint-objects","text":"1 2 @dataclass class ForeignKeyConstraint () Internal container to store ForeignKey definitions used later to produce sqlalchemy.ForeignKeys","title":"ForeignKeyConstraint Objects"},{"location":"api/fields/foreign-key/#foreignkey","text":"1 ForeignKey ( to : \"ToType\" , * , name : str = None , unique : bool = False , nullable : bool = True , related_name : str = None , virtual : bool = False , onupdate : str = None , ondelete : str = None , ** kwargs : Any , ,) -> \"T\" Despite a name it's a function that returns constructed ForeignKeyField. This function is actually used in model declaration (as ormar.ForeignKey(ToModel)). Accepts number of relation setting parameters as well as all BaseField ones. Arguments : to : target related ormar Model :type to: Model class name : name of the database field - later called alias :type name: str unique : parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool nullable : marks field as optional/ required :type nullable: bool related_name : name of reversed FK relation populated for you on to model :type related_name: str virtual : marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool onupdate : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. :type onupdate: str ondelete : parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. :type ondelete: str kwargs : all other args to be populated by BaseField :type kwargs: Any Returns : ormar ForeignKeyField with relation to selected model :rtype: ForeignKeyField","title":"ForeignKey"},{"location":"api/fields/foreign-key/#foreignkeyfield-objects","text":"1 class ForeignKeyField ( BaseField ) Actual class returned from ForeignKey function call and stored in model_fields.","title":"ForeignKeyField Objects"},{"location":"api/fields/foreign-key/#get_source_related_name","text":"1 | get_source_related_name () -> str Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as related_name or by default it's owner model. get_name + 's' Returns : name of the related_name or default related name. :rtype: str","title":"get_source_related_name"},{"location":"api/fields/foreign-key/#get_related_name","text":"1 | get_related_name () -> str Returns name to use for reverse relation. It's either set as related_name or by default it's owner model. get_name + 's' Returns : name of the related_name or default related name. :rtype: str","title":"get_related_name"},{"location":"api/fields/foreign-key/#default_target_field_name","text":"1 | default_target_field_name () -> str Returns default target model name on through model. Returns : name of the field :rtype: str","title":"default_target_field_name"},{"location":"api/fields/foreign-key/#default_source_field_name","text":"1 | default_source_field_name () -> str Returns default target model name on through model. Returns : name of the field :rtype: str","title":"default_source_field_name"},{"location":"api/fields/foreign-key/#evaluate_forward_ref","text":"1 | evaluate_forward_ref ( globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns : global namespace :type globalns: Any localns : local namespace :type localns: Any Returns : None :rtype: None","title":"evaluate_forward_ref"},{"location":"api/fields/foreign-key/#_extract_model_from_sequence","text":"1 | _extract_model_from_sequence ( value : List , child : \"Model\" , to_register : bool ) -> List [ \"Model\" ] Takes a list of Models and registers them on parent. Registration is mutual, so children have also reference to parent. Used in reverse FK relations. Arguments : value : list of Model :type value: List child : child/ related Model :type child: Model to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : list (if needed) registered Models :rtype: List[\"Model\"]","title":"_extract_model_from_sequence"},{"location":"api/fields/foreign-key/#_register_existing_model","text":"1 | _register_existing_model ( value : \"Model\" , child : \"Model\" , to_register : bool ) -> \"Model\" Takes already created instance and registers it for parent. Registration is mutual, so children have also reference to parent. Used in reverse FK relations and normal FK for single models. Arguments : value : already instantiated Model :type value: Model child : child/ related Model :type child: Model to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : (if needed) registered Model :rtype: Model","title":"_register_existing_model"},{"location":"api/fields/foreign-key/#_construct_model_from_dict","text":"1 | _construct_model_from_dict ( value : dict , child : \"Model\" , to_register : bool ) -> \"Model\" Takes a dictionary, creates a instance and registers it for parent. If dictionary contains only one field and it's a pk it is a pk_only model. Registration is mutual, so children have also reference to parent. Used in normal FK for dictionaries. Arguments : value : dictionary of a Model :type value: dict child : child/ related Model :type child: Model to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : (if needed) registered Model :rtype: Model","title":"_construct_model_from_dict"},{"location":"api/fields/foreign-key/#_construct_model_from_pk","text":"1 | _construct_model_from_pk ( value : Any , child : \"Model\" , to_register : bool ) -> \"Model\" Takes a pk value, creates a dummy instance and registers it for parent. Registration is mutual, so children have also reference to parent. Used in normal FK for dictionaries. Arguments : value : value of a related pk / fk column :type value: Any child : child/ related Model :type child: Model to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : (if needed) registered Model :rtype: Model","title":"_construct_model_from_pk"},{"location":"api/fields/foreign-key/#register_relation","text":"1 | register_relation ( model : \"Model\" , child : \"Model\" ) -> None Registers relation between parent and child in relation manager. Relation manager is kep on each model (different instance). Used in Metaclass and sometimes some relations are missing (i.e. cloned Models in fastapi might miss one). Arguments : model : parent model (with relation definition) :type model: Model class child : child model :type child: Model class","title":"register_relation"},{"location":"api/fields/foreign-key/#has_unresolved_forward_refs","text":"1 | has_unresolved_forward_refs () -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : result of the check :rtype: bool","title":"has_unresolved_forward_refs"},{"location":"api/fields/foreign-key/#expand_relationship","text":"1 | expand_relationship ( value : Any , child : Union [ \"Model\" , \"NewBaseModel\" ], to_register : bool = True ) -> Optional [ Union [ \"Model\" , List [ \"Model\" ]]] For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\". Selects the appropriate constructor based on a passed value. Arguments : value : a Model field value, returned untouched for non relation fields. :type value: Any child : a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] to_register : flag if the relation should be set in RelationshipManager :type to_register: bool Returns : returns a Model or a list of Models :rtype: Optional[Union[\"Model\", List[\"Model\"]]]","title":"expand_relationship"},{"location":"api/fields/foreign-key/#get_relation_name","text":"1 | get_relation_name () -> str Returns name of the relation, which can be a own name or through model names for m2m models Returns : result of the check :rtype: bool","title":"get_relation_name"},{"location":"api/fields/foreign-key/#get_source_model","text":"1 | get_source_model () -> Type [ \"Model\" ] Returns model from which the relation comes -> either owner or through model Returns : source model :rtype: Type[\"Model\"]","title":"get_source_model"},{"location":"api/fields/many-to-many/","text":"fields.many_to_many forbid_through_relations 1 forbid_through_relations ( through : Type [ \"Model\" ]) -> None Verifies if the through model does not have relations. Arguments : through : through Model to be checked :type through: Type['Model] populate_m2m_params_based_on_to_model 1 populate_m2m_params_based_on_to_model ( to : Type [ \"Model\" ], nullable : bool ) -> Tuple [ Any , Any ] Based on target to model to which relation leads to populates the type of the pydantic field to use and type of the target column field. Arguments : to : target related ormar Model :type to: Model class nullable : marks field as optional/ required :type nullable: bool Returns : Tuple[List, Any] :rtype: tuple with target pydantic type and target col type ManyToMany 1 ManyToMany ( to : \"ToType\" , through : Optional [ \"ToType\" ] = None , * , name : str = None , unique : bool = False , virtual : bool = False , ** kwargs : Any , ,) -> \"RelationProxy[T]\" Despite a name it's a function that returns constructed ManyToManyField. This function is actually used in model declaration (as ormar.ManyToMany(ToModel, through=ThroughModel)). Accepts number of relation setting parameters as well as all BaseField ones. Arguments : to : target related ormar Model :type to: Model class through : through model for m2m relation :type through: Model class name : name of the database field - later called alias :type name: str unique : parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool virtual : marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool kwargs : all other args to be populated by BaseField :type kwargs: Any Returns : ormar ManyToManyField with m2m relation to selected model :rtype: ManyToManyField ManyToManyField Objects 1 class ManyToManyField ( ForeignKeyField , ormar . QuerySetProtocol , ormar . RelationProtocol ) Actual class returned from ManyToMany function call and stored in model_fields. get_source_related_name 1 | get_source_related_name () -> str Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as related_name or by default it's field name. Returns : name of the related_name or default related name. :rtype: str has_unresolved_forward_refs 1 | has_unresolved_forward_refs () -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : result of the check :rtype: bool evaluate_forward_ref 1 | evaluate_forward_ref ( globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns : global namespace :type globalns: Any localns : local namespace :type localns: Any Returns : None :rtype: None get_relation_name 1 | get_relation_name () -> str Returns name of the relation, which can be a own name or through model names for m2m models Returns : result of the check :rtype: bool get_source_model 1 | get_source_model () -> Type [ \"Model\" ] Returns model from which the relation comes -> either owner or through model Returns : source model :rtype: Type[\"Model\"] create_default_through_model 1 | create_default_through_model () -> None Creates default empty through model if no additional fields are required.","title":"Many To Many"},{"location":"api/fields/many-to-many/#fieldsmany_to_many","text":"","title":"fields.many_to_many"},{"location":"api/fields/many-to-many/#forbid_through_relations","text":"1 forbid_through_relations ( through : Type [ \"Model\" ]) -> None Verifies if the through model does not have relations. Arguments : through : through Model to be checked :type through: Type['Model]","title":"forbid_through_relations"},{"location":"api/fields/many-to-many/#populate_m2m_params_based_on_to_model","text":"1 populate_m2m_params_based_on_to_model ( to : Type [ \"Model\" ], nullable : bool ) -> Tuple [ Any , Any ] Based on target to model to which relation leads to populates the type of the pydantic field to use and type of the target column field. Arguments : to : target related ormar Model :type to: Model class nullable : marks field as optional/ required :type nullable: bool Returns : Tuple[List, Any] :rtype: tuple with target pydantic type and target col type","title":"populate_m2m_params_based_on_to_model"},{"location":"api/fields/many-to-many/#manytomany","text":"1 ManyToMany ( to : \"ToType\" , through : Optional [ \"ToType\" ] = None , * , name : str = None , unique : bool = False , virtual : bool = False , ** kwargs : Any , ,) -> \"RelationProxy[T]\" Despite a name it's a function that returns constructed ManyToManyField. This function is actually used in model declaration (as ormar.ManyToMany(ToModel, through=ThroughModel)). Accepts number of relation setting parameters as well as all BaseField ones. Arguments : to : target related ormar Model :type to: Model class through : through model for m2m relation :type through: Model class name : name of the database field - later called alias :type name: str unique : parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool virtual : marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool kwargs : all other args to be populated by BaseField :type kwargs: Any Returns : ormar ManyToManyField with m2m relation to selected model :rtype: ManyToManyField","title":"ManyToMany"},{"location":"api/fields/many-to-many/#manytomanyfield-objects","text":"1 class ManyToManyField ( ForeignKeyField , ormar . QuerySetProtocol , ormar . RelationProtocol ) Actual class returned from ManyToMany function call and stored in model_fields.","title":"ManyToManyField Objects"},{"location":"api/fields/many-to-many/#get_source_related_name","text":"1 | get_source_related_name () -> str Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as related_name or by default it's field name. Returns : name of the related_name or default related name. :rtype: str","title":"get_source_related_name"},{"location":"api/fields/many-to-many/#has_unresolved_forward_refs","text":"1 | has_unresolved_forward_refs () -> bool Verifies if the filed has any ForwardRefs that require updating before the model can be used. Returns : result of the check :rtype: bool","title":"has_unresolved_forward_refs"},{"location":"api/fields/many-to-many/#evaluate_forward_ref","text":"1 | evaluate_forward_ref ( globalns : Any , localns : Any ) -> None Evaluates the ForwardRef to actual Field based on global and local namespaces Arguments : globalns : global namespace :type globalns: Any localns : local namespace :type localns: Any Returns : None :rtype: None","title":"evaluate_forward_ref"},{"location":"api/fields/many-to-many/#get_relation_name","text":"1 | get_relation_name () -> str Returns name of the relation, which can be a own name or through model names for m2m models Returns : result of the check :rtype: bool","title":"get_relation_name"},{"location":"api/fields/many-to-many/#get_source_model","text":"1 | get_source_model () -> Type [ \"Model\" ] Returns model from which the relation comes -> either owner or through model Returns : source model :rtype: Type[\"Model\"]","title":"get_source_model"},{"location":"api/fields/many-to-many/#create_default_through_model","text":"1 | create_default_through_model () -> None Creates default empty through model if no additional fields are required.","title":"create_default_through_model"},{"location":"api/fields/model-fields/","text":"fields.model_fields is_field_nullable 1 is_field_nullable ( nullable : Optional [ bool ], default : Any , server_default : Any , pydantic_only : Optional [ bool ]) -> bool Checks if the given field should be nullable/ optional based on parameters given. Arguments : nullable : flag explicit setting a column as nullable :type nullable: Optional[bool] default : value or function to be called as default in python :type default: Any server_default : function to be called as default by sql server :type server_default: Any pydantic_only : flag if fields should not be included in the sql table :type pydantic_only: Optional[bool] Returns : result of the check :rtype: bool is_auto_primary_key 1 is_auto_primary_key ( primary_key : bool , autoincrement : bool ) -> bool Checks if field is an autoincrement pk -> if yes it's optional. Arguments : primary_key : flag if field is a pk field :type primary_key: bool autoincrement : flag if field should be autoincrement :type autoincrement: bool Returns : result of the check :rtype: bool ModelFieldFactory Objects 1 class ModelFieldFactory () Default field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column validate 1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs : all params passed during construction :type kwargs: Any String Objects 1 class String ( ModelFieldFactory , str ) String field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column validate 1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs : all params passed during construction :type kwargs: Any Integer Objects 1 class Integer ( ModelFieldFactory , int ) Integer field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column Text Objects 1 class Text ( ModelFieldFactory , str ) Text field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column Float Objects 1 class Float ( ModelFieldFactory , float ) Float field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column DateTime Objects 1 class DateTime ( ModelFieldFactory , datetime . datetime ) DateTime field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column Date Objects 1 class Date ( ModelFieldFactory , datetime . date ) Date field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column Time Objects 1 class Time ( ModelFieldFactory , datetime . time ) Time field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column JSON Objects 1 class JSON ( ModelFieldFactory , pydantic . Json ) JSON field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column BigInteger Objects 1 class BigInteger ( Integer , int ) BigInteger field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column SmallInteger Objects 1 class SmallInteger ( Integer , int ) SmallInteger field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column Decimal Objects 1 class Decimal ( ModelFieldFactory , decimal . Decimal ) Decimal field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column validate 1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs : all params passed during construction :type kwargs: Any UUID Objects 1 class UUID ( ModelFieldFactory , uuid . UUID ) UUID field factory that construct Field classes and populated their values. get_column_type 1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"Model Fields"},{"location":"api/fields/model-fields/#fieldsmodel_fields","text":"","title":"fields.model_fields"},{"location":"api/fields/model-fields/#is_field_nullable","text":"1 is_field_nullable ( nullable : Optional [ bool ], default : Any , server_default : Any , pydantic_only : Optional [ bool ]) -> bool Checks if the given field should be nullable/ optional based on parameters given. Arguments : nullable : flag explicit setting a column as nullable :type nullable: Optional[bool] default : value or function to be called as default in python :type default: Any server_default : function to be called as default by sql server :type server_default: Any pydantic_only : flag if fields should not be included in the sql table :type pydantic_only: Optional[bool] Returns : result of the check :rtype: bool","title":"is_field_nullable"},{"location":"api/fields/model-fields/#is_auto_primary_key","text":"1 is_auto_primary_key ( primary_key : bool , autoincrement : bool ) -> bool Checks if field is an autoincrement pk -> if yes it's optional. Arguments : primary_key : flag if field is a pk field :type primary_key: bool autoincrement : flag if field should be autoincrement :type autoincrement: bool Returns : result of the check :rtype: bool","title":"is_auto_primary_key"},{"location":"api/fields/model-fields/#modelfieldfactory-objects","text":"1 class ModelFieldFactory () Default field factory that construct Field classes and populated their values.","title":"ModelFieldFactory Objects"},{"location":"api/fields/model-fields/#get_column_type","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#validate","text":"1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs : all params passed during construction :type kwargs: Any","title":"validate"},{"location":"api/fields/model-fields/#string-objects","text":"1 class String ( ModelFieldFactory , str ) String field factory that construct Field classes and populated their values.","title":"String Objects"},{"location":"api/fields/model-fields/#get_column_type_1","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#validate_1","text":"1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs : all params passed during construction :type kwargs: Any","title":"validate"},{"location":"api/fields/model-fields/#integer-objects","text":"1 class Integer ( ModelFieldFactory , int ) Integer field factory that construct Field classes and populated their values.","title":"Integer Objects"},{"location":"api/fields/model-fields/#get_column_type_2","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#text-objects","text":"1 class Text ( ModelFieldFactory , str ) Text field factory that construct Field classes and populated their values.","title":"Text Objects"},{"location":"api/fields/model-fields/#get_column_type_3","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#float-objects","text":"1 class Float ( ModelFieldFactory , float ) Float field factory that construct Field classes and populated their values.","title":"Float Objects"},{"location":"api/fields/model-fields/#get_column_type_4","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#datetime-objects","text":"1 class DateTime ( ModelFieldFactory , datetime . datetime ) DateTime field factory that construct Field classes and populated their values.","title":"DateTime Objects"},{"location":"api/fields/model-fields/#get_column_type_5","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#date-objects","text":"1 class Date ( ModelFieldFactory , datetime . date ) Date field factory that construct Field classes and populated their values.","title":"Date Objects"},{"location":"api/fields/model-fields/#get_column_type_6","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#time-objects","text":"1 class Time ( ModelFieldFactory , datetime . time ) Time field factory that construct Field classes and populated their values.","title":"Time Objects"},{"location":"api/fields/model-fields/#get_column_type_7","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#json-objects","text":"1 class JSON ( ModelFieldFactory , pydantic . Json ) JSON field factory that construct Field classes and populated their values.","title":"JSON Objects"},{"location":"api/fields/model-fields/#get_column_type_8","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#biginteger-objects","text":"1 class BigInteger ( Integer , int ) BigInteger field factory that construct Field classes and populated their values.","title":"BigInteger Objects"},{"location":"api/fields/model-fields/#get_column_type_9","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#smallinteger-objects","text":"1 class SmallInteger ( Integer , int ) SmallInteger field factory that construct Field classes and populated their values.","title":"SmallInteger Objects"},{"location":"api/fields/model-fields/#get_column_type_10","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#decimal-objects","text":"1 class Decimal ( ModelFieldFactory , decimal . Decimal ) Decimal field factory that construct Field classes and populated their values.","title":"Decimal Objects"},{"location":"api/fields/model-fields/#get_column_type_11","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/fields/model-fields/#validate_2","text":"1 2 | @classmethod | validate ( cls , ** kwargs : Any ) -> None Used to validate if all required parameters on a given field type are set. Arguments : kwargs : all params passed during construction :type kwargs: Any","title":"validate"},{"location":"api/fields/model-fields/#uuid-objects","text":"1 class UUID ( ModelFieldFactory , uuid . UUID ) UUID field factory that construct Field classes and populated their values.","title":"UUID Objects"},{"location":"api/fields/model-fields/#get_column_type_12","text":"1 2 | @classmethod | get_column_type ( cls , ** kwargs : Any ) -> Any Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts. Arguments : kwargs : key, value pairs of sqlalchemy options :type kwargs: Any Returns : initialized column with proper options :rtype: sqlalchemy Column","title":"get_column_type"},{"location":"api/models/excludable-items/","text":"models.excludable Excludable Objects 1 2 @dataclass class Excludable () Class that keeps sets of fields to exclude and include get_copy 1 | get_copy () -> \"Excludable\" Return copy of self to avoid in place modifications Returns : copy of self with copied sets :rtype: ormar.models.excludable.Excludable set_values 1 | set_values ( value : Set , is_exclude : bool ) -> None Appends the data to include/exclude sets. Arguments : value : set of values to add :type value: set is_exclude : flag if values are to be excluded or included :type is_exclude: bool is_included 1 | is_included ( key : str ) -> bool Check if field in included (in set or set is {...}) Arguments : key : key to check :type key: str Returns : result of the check :rtype: bool is_excluded 1 | is_excluded ( key : str ) -> bool Check if field in excluded (in set or set is {...}) Arguments : key : key to check :type key: str Returns : result of the check :rtype: bool ExcludableItems Objects 1 class ExcludableItems () Keeps a dictionary of Excludables by alias + model_name keys to allow quick lookup by nested models without need to travers deeply nested dictionaries and passing include/exclude around from_excludable 1 2 | @classmethod | from_excludable ( cls , other : \"ExcludableItems\" ) -> \"ExcludableItems\" Copy passed ExcludableItems to avoid inplace modifications. Arguments : other : other excludable items to be copied :type other: ormar.models.excludable.ExcludableItems Returns : copy of other :rtype: ormar.models.excludable.ExcludableItems include_entry_count 1 | include_entry_count () -> int Returns count of include items inside get 1 | get ( model_cls : Type [ \"Model\" ], alias : str = \"\" ) -> Excludable Return Excludable for given model and alias. Arguments : model_cls : target model to check :type model_cls: ormar.models.metaclass.ModelMetaclass alias : table alias from relation manager :type alias: str Returns : Excludable for given model and alias :rtype: ormar.models.excludable.Excludable build 1 | build ( items : Union [ List [ str ], str , Tuple [ str ], Set [ str ], Dict ], model_cls : Type [ \"Model\" ], is_exclude : bool = False ) -> None Receives the one of the types of items and parses them as to achieve a end situation with one excludable per alias/model in relation. Each excludable has two sets of values - one to include, one to exclude. Arguments : items : values to be included or excluded :type items: Union[List[str], str, Tuple[str], Set[str], Dict] model_cls : source model from which relations are constructed :type model_cls: ormar.models.metaclass.ModelMetaclass is_exclude : flag if items should be included or excluded :type is_exclude: bool _set_excludes 1 | _set_excludes ( items : Set , model_name : str , is_exclude : bool , alias : str = \"\" ) -> None Sets set of values to be included or excluded for given key and model. Arguments : items : items to include/exclude :type items: set model_name : name of model to construct key :type model_name: str is_exclude : flag if values should be included or excluded :type is_exclude: bool alias : :type alias: str _traverse_dict 1 | _traverse_dict ( values : Dict , source_model : Type [ \"Model\" ], model_cls : Type [ \"Model\" ], is_exclude : bool , related_items : List = None , alias : str = \"\" ) -> None Goes through dict of nested values and construct/update Excludables. Arguments : values : items to include/exclude :type values: Dict source_model : source model from which relations are constructed :type source_model: ormar.models.metaclass.ModelMetaclass model_cls : model from which current relation is constructed :type model_cls: ormar.models.metaclass.ModelMetaclass is_exclude : flag if values should be included or excluded :type is_exclude: bool related_items : list of names of related fields chain :type related_items: List alias : alias of relation :type alias: str _traverse_list 1 | _traverse_list ( values : Set [ str ], model_cls : Type [ \"Model\" ], is_exclude : bool ) -> None Goes through list of values and construct/update Excludables. Arguments : values : items to include/exclude :type values: set model_cls : model from which current relation is constructed :type model_cls: ormar.models.metaclass.ModelMetaclass is_exclude : flag if values should be included or excluded :type is_exclude: bool","title":"Excludable Items"},{"location":"api/models/excludable-items/#modelsexcludable","text":"","title":"models.excludable"},{"location":"api/models/excludable-items/#excludable-objects","text":"1 2 @dataclass class Excludable () Class that keeps sets of fields to exclude and include","title":"Excludable Objects"},{"location":"api/models/excludable-items/#get_copy","text":"1 | get_copy () -> \"Excludable\" Return copy of self to avoid in place modifications Returns : copy of self with copied sets :rtype: ormar.models.excludable.Excludable","title":"get_copy"},{"location":"api/models/excludable-items/#set_values","text":"1 | set_values ( value : Set , is_exclude : bool ) -> None Appends the data to include/exclude sets. Arguments : value : set of values to add :type value: set is_exclude : flag if values are to be excluded or included :type is_exclude: bool","title":"set_values"},{"location":"api/models/excludable-items/#is_included","text":"1 | is_included ( key : str ) -> bool Check if field in included (in set or set is {...}) Arguments : key : key to check :type key: str Returns : result of the check :rtype: bool","title":"is_included"},{"location":"api/models/excludable-items/#is_excluded","text":"1 | is_excluded ( key : str ) -> bool Check if field in excluded (in set or set is {...}) Arguments : key : key to check :type key: str Returns : result of the check :rtype: bool","title":"is_excluded"},{"location":"api/models/excludable-items/#excludableitems-objects","text":"1 class ExcludableItems () Keeps a dictionary of Excludables by alias + model_name keys to allow quick lookup by nested models without need to travers deeply nested dictionaries and passing include/exclude around","title":"ExcludableItems Objects"},{"location":"api/models/excludable-items/#from_excludable","text":"1 2 | @classmethod | from_excludable ( cls , other : \"ExcludableItems\" ) -> \"ExcludableItems\" Copy passed ExcludableItems to avoid inplace modifications. Arguments : other : other excludable items to be copied :type other: ormar.models.excludable.ExcludableItems Returns : copy of other :rtype: ormar.models.excludable.ExcludableItems","title":"from_excludable"},{"location":"api/models/excludable-items/#include_entry_count","text":"1 | include_entry_count () -> int Returns count of include items inside","title":"include_entry_count"},{"location":"api/models/excludable-items/#get","text":"1 | get ( model_cls : Type [ \"Model\" ], alias : str = \"\" ) -> Excludable Return Excludable for given model and alias. Arguments : model_cls : target model to check :type model_cls: ormar.models.metaclass.ModelMetaclass alias : table alias from relation manager :type alias: str Returns : Excludable for given model and alias :rtype: ormar.models.excludable.Excludable","title":"get"},{"location":"api/models/excludable-items/#build","text":"1 | build ( items : Union [ List [ str ], str , Tuple [ str ], Set [ str ], Dict ], model_cls : Type [ \"Model\" ], is_exclude : bool = False ) -> None Receives the one of the types of items and parses them as to achieve a end situation with one excludable per alias/model in relation. Each excludable has two sets of values - one to include, one to exclude. Arguments : items : values to be included or excluded :type items: Union[List[str], str, Tuple[str], Set[str], Dict] model_cls : source model from which relations are constructed :type model_cls: ormar.models.metaclass.ModelMetaclass is_exclude : flag if items should be included or excluded :type is_exclude: bool","title":"build"},{"location":"api/models/excludable-items/#_set_excludes","text":"1 | _set_excludes ( items : Set , model_name : str , is_exclude : bool , alias : str = \"\" ) -> None Sets set of values to be included or excluded for given key and model. Arguments : items : items to include/exclude :type items: set model_name : name of model to construct key :type model_name: str is_exclude : flag if values should be included or excluded :type is_exclude: bool alias : :type alias: str","title":"_set_excludes"},{"location":"api/models/excludable-items/#_traverse_dict","text":"1 | _traverse_dict ( values : Dict , source_model : Type [ \"Model\" ], model_cls : Type [ \"Model\" ], is_exclude : bool , related_items : List = None , alias : str = \"\" ) -> None Goes through dict of nested values and construct/update Excludables. Arguments : values : items to include/exclude :type values: Dict source_model : source model from which relations are constructed :type source_model: ormar.models.metaclass.ModelMetaclass model_cls : model from which current relation is constructed :type model_cls: ormar.models.metaclass.ModelMetaclass is_exclude : flag if values should be included or excluded :type is_exclude: bool related_items : list of names of related fields chain :type related_items: List alias : alias of relation :type alias: str","title":"_traverse_dict"},{"location":"api/models/excludable-items/#_traverse_list","text":"1 | _traverse_list ( values : Set [ str ], model_cls : Type [ \"Model\" ], is_exclude : bool ) -> None Goes through list of values and construct/update Excludables. Arguments : values : items to include/exclude :type values: set model_cls : model from which current relation is constructed :type model_cls: ormar.models.metaclass.ModelMetaclass is_exclude : flag if values should be included or excluded :type is_exclude: bool","title":"_traverse_list"},{"location":"api/models/model-metaclass/","text":"models.metaclass ModelMeta Objects 1 class ModelMeta () Class used for type hinting. Users can subclass this one for convenience but it's not required. The only requirement is that ormar.Model has to have inner class with name Meta. add_cached_properties 1 add_cached_properties ( new_model : Type [ \"Model\" ]) -> None Sets cached properties for both pydantic and ormar models. Quick access fields are fields grabbed in getattribute to skip all checks. Related fields and names are populated to None as they can change later. When children models are constructed they can modify parent to register itself. All properties here are used as \"cache\" to not recalculate them constantly. Arguments : new_model : newly constructed Model :type new_model: Model class add_property_fields 1 add_property_fields ( new_model : Type [ \"Model\" ], attrs : Dict ) -> None Checks class namespace for properties or functions with property_field . If attribute have property_field it was decorated with @property_field. Functions like this are exposed in dict() (therefore also fastapi result). Names of property fields are cached for quicker access / extraction. Arguments : new_model : newly constructed model :type new_model: Model class attrs : :type attrs: Dict[str, str] register_signals 1 register_signals ( new_model : Type [ \"Model\" ]) -> None Registers on model's SignalEmmiter and sets pre defined signals. Predefined signals are (pre/post) + (save/update/delete). Signals are emitted in both model own methods and in selected queryset ones. Arguments : new_model : newly constructed model :type new_model: Model class verify_constraint_names 1 verify_constraint_names ( base_class : \"Model\" , model_fields : Dict , parent_value : List ) -> None Verifies if redefined fields that are overwritten in subclasses did not remove any name of the column that is used in constraint as it will fail in sqlalchemy Table creation. Arguments : base_class : one of the parent classes :type base_class: Model or model parent class model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] parent_value : list of base class constraints :type parent_value: List update_attrs_from_base_meta 1 update_attrs_from_base_meta ( base_class : \"Model\" , attrs : Dict , model_fields : Dict ) -> None Updates Meta parameters in child from parent if needed. Arguments : base_class : one of the parent classes :type base_class: Model or model parent class attrs : new namespace for class being constructed :type attrs: Dict model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] copy_and_replace_m2m_through_model 1 copy_and_replace_m2m_through_model ( field : ManyToManyField , field_name : str , table_name : str , parent_fields : Dict , attrs : Dict , meta : ModelMeta , base_class : Type [ \"Model\" ]) -> None Clones class with Through model for m2m relations, appends child name to the name of the cloned class. Clones non foreign keys fields from parent model, the same with database columns. Modifies related_name with appending child table name after '_' For table name, the table name of child is appended after '_'. Removes the original sqlalchemy table from metadata if it was not removed. Arguments : base_class : base class model :type base_class: Type[\"Model\"] field : field with relations definition :type field: ManyToManyField field_name : name of the relation field :type field_name: str table_name : name of the table :type table_name: str parent_fields : dictionary of fields to copy to new models from parent :type parent_fields: Dict attrs : new namespace for class being constructed :type attrs: Dict meta : metaclass of currently created model :type meta: ModelMeta copy_data_from_parent_model 1 copy_data_from_parent_model ( base_class : Type [ \"Model\" ], curr_class : type , attrs : Dict , model_fields : Dict [ str , Union [ BaseField , ForeignKeyField , ManyToManyField ]]) -> Tuple [ Dict , Dict ] Copy the key parameters [database, metadata, property_fields and constraints] and fields from parent models. Overwrites them if needed. Only abstract classes can be subclassed. Since relation fields requires different related_name for different children Raises : ModelDefinitionError : if non abstract model is subclassed Arguments : base_class : one of the parent classes :type base_class: Model or model parent class curr_class : current constructed class :type curr_class: Model or model parent class attrs : new namespace for class being constructed :type attrs: Dict model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] Returns : updated attrs and model_fields :rtype: Tuple[Dict, Dict] extract_from_parents_definition 1 extract_from_parents_definition ( base_class : type , curr_class : type , attrs : Dict , model_fields : Dict [ str , Union [ BaseField , ForeignKeyField , ManyToManyField ]]) -> Tuple [ Dict , Dict ] Extracts fields from base classes if they have valid ormar fields. If model was already parsed -> fields definitions need to be removed from class cause pydantic complains about field re-definition so after first child we need to extract from parsed_fields not the class itself. If the class is parsed first time annotations and field definition is parsed from the class. dict . If the class is a ormar.Model it is skipped. Arguments : base_class : one of the parent classes :type base_class: Model or model parent class curr_class : current constructed class :type curr_class: Model or model parent class attrs : new namespace for class being constructed :type attrs: Dict model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] Returns : updated attrs and model_fields :rtype: Tuple[Dict, Dict] update_attrs_and_fields 1 update_attrs_and_fields ( attrs : Dict , new_attrs : Dict , model_fields : Dict , new_model_fields : Dict , new_fields : Set ) -> Dict Updates annotations , values of model fields (so pydantic FieldInfos) as well as model.Meta.model_fields definitions from parents. Arguments : attrs : new namespace for class being constructed :type attrs: Dict new_attrs : related of the namespace extracted from parent class :type new_attrs: Dict model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] new_model_fields : ormar fields defined in parent classes :type new_model_fields: Dict[str, BaseField] new_fields : set of new fields names :type new_fields: Set[str] add_field_descriptor 1 add_field_descriptor ( name : str , field : \"BaseField\" , new_model : Type [ \"Model\" ]) -> None Sets appropriate descriptor for each model field. There are 5 main types of descriptors, for bytes, json, pure pydantic fields, and 2 ormar ones - one for relation and one for pk shortcut Arguments : name : name of the field :type name: str field : model field to add descriptor for :type field: BaseField new_model : model with fields :type new_model: Type[\"Model] ModelMetaclass Objects 1 class ModelMetaclass ( pydantic . main . ModelMetaclass ) __new__ 1 | __new__ ( mcs : \"ModelMetaclass\" , name : str , bases : Any , attrs : dict ) -> \"ModelMetaclass\" Metaclass used by ormar Models that performs configuration and build of ormar Models. Sets pydantic configuration. Extract model_fields and convert them to pydantic FieldInfo, updates class namespace. Extracts settings and fields from parent classes. Fetches methods decorated with @property_field decorator to expose them later in dict(). Construct parent pydantic Metaclass/ Model. If class has Meta class declared (so actual ormar Models) it also: populate sqlalchemy columns, pkname and tables from model_fields register reverse relationships on related models registers all relations in alias manager that populates table_prefixes exposes alias manager on each Model creates QuerySet for each model and exposes it on a class Arguments : name : name of current class :type name: str bases : base classes :type bases: Tuple attrs : class namespace :type attrs: Dict __getattr__ 1 | __getattr__ ( item : str ) -> Any Returns FieldAccessors on access to model fields from a class, that way it can be used in python style filters and order_by. Arguments : item : name of the field :type item: str Returns : FieldAccessor for given field :rtype: FieldAccessor","title":"Model Metaclass"},{"location":"api/models/model-metaclass/#modelsmetaclass","text":"","title":"models.metaclass"},{"location":"api/models/model-metaclass/#modelmeta-objects","text":"1 class ModelMeta () Class used for type hinting. Users can subclass this one for convenience but it's not required. The only requirement is that ormar.Model has to have inner class with name Meta.","title":"ModelMeta Objects"},{"location":"api/models/model-metaclass/#add_cached_properties","text":"1 add_cached_properties ( new_model : Type [ \"Model\" ]) -> None Sets cached properties for both pydantic and ormar models. Quick access fields are fields grabbed in getattribute to skip all checks. Related fields and names are populated to None as they can change later. When children models are constructed they can modify parent to register itself. All properties here are used as \"cache\" to not recalculate them constantly. Arguments : new_model : newly constructed Model :type new_model: Model class","title":"add_cached_properties"},{"location":"api/models/model-metaclass/#add_property_fields","text":"1 add_property_fields ( new_model : Type [ \"Model\" ], attrs : Dict ) -> None Checks class namespace for properties or functions with property_field . If attribute have property_field it was decorated with @property_field. Functions like this are exposed in dict() (therefore also fastapi result). Names of property fields are cached for quicker access / extraction. Arguments : new_model : newly constructed model :type new_model: Model class attrs : :type attrs: Dict[str, str]","title":"add_property_fields"},{"location":"api/models/model-metaclass/#register_signals","text":"1 register_signals ( new_model : Type [ \"Model\" ]) -> None Registers on model's SignalEmmiter and sets pre defined signals. Predefined signals are (pre/post) + (save/update/delete). Signals are emitted in both model own methods and in selected queryset ones. Arguments : new_model : newly constructed model :type new_model: Model class","title":"register_signals"},{"location":"api/models/model-metaclass/#verify_constraint_names","text":"1 verify_constraint_names ( base_class : \"Model\" , model_fields : Dict , parent_value : List ) -> None Verifies if redefined fields that are overwritten in subclasses did not remove any name of the column that is used in constraint as it will fail in sqlalchemy Table creation. Arguments : base_class : one of the parent classes :type base_class: Model or model parent class model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] parent_value : list of base class constraints :type parent_value: List","title":"verify_constraint_names"},{"location":"api/models/model-metaclass/#update_attrs_from_base_meta","text":"1 update_attrs_from_base_meta ( base_class : \"Model\" , attrs : Dict , model_fields : Dict ) -> None Updates Meta parameters in child from parent if needed. Arguments : base_class : one of the parent classes :type base_class: Model or model parent class attrs : new namespace for class being constructed :type attrs: Dict model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField]","title":"update_attrs_from_base_meta"},{"location":"api/models/model-metaclass/#copy_and_replace_m2m_through_model","text":"1 copy_and_replace_m2m_through_model ( field : ManyToManyField , field_name : str , table_name : str , parent_fields : Dict , attrs : Dict , meta : ModelMeta , base_class : Type [ \"Model\" ]) -> None Clones class with Through model for m2m relations, appends child name to the name of the cloned class. Clones non foreign keys fields from parent model, the same with database columns. Modifies related_name with appending child table name after '_' For table name, the table name of child is appended after '_'. Removes the original sqlalchemy table from metadata if it was not removed. Arguments : base_class : base class model :type base_class: Type[\"Model\"] field : field with relations definition :type field: ManyToManyField field_name : name of the relation field :type field_name: str table_name : name of the table :type table_name: str parent_fields : dictionary of fields to copy to new models from parent :type parent_fields: Dict attrs : new namespace for class being constructed :type attrs: Dict meta : metaclass of currently created model :type meta: ModelMeta","title":"copy_and_replace_m2m_through_model"},{"location":"api/models/model-metaclass/#copy_data_from_parent_model","text":"1 copy_data_from_parent_model ( base_class : Type [ \"Model\" ], curr_class : type , attrs : Dict , model_fields : Dict [ str , Union [ BaseField , ForeignKeyField , ManyToManyField ]]) -> Tuple [ Dict , Dict ] Copy the key parameters [database, metadata, property_fields and constraints] and fields from parent models. Overwrites them if needed. Only abstract classes can be subclassed. Since relation fields requires different related_name for different children Raises : ModelDefinitionError : if non abstract model is subclassed Arguments : base_class : one of the parent classes :type base_class: Model or model parent class curr_class : current constructed class :type curr_class: Model or model parent class attrs : new namespace for class being constructed :type attrs: Dict model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] Returns : updated attrs and model_fields :rtype: Tuple[Dict, Dict]","title":"copy_data_from_parent_model"},{"location":"api/models/model-metaclass/#extract_from_parents_definition","text":"1 extract_from_parents_definition ( base_class : type , curr_class : type , attrs : Dict , model_fields : Dict [ str , Union [ BaseField , ForeignKeyField , ManyToManyField ]]) -> Tuple [ Dict , Dict ] Extracts fields from base classes if they have valid ormar fields. If model was already parsed -> fields definitions need to be removed from class cause pydantic complains about field re-definition so after first child we need to extract from parsed_fields not the class itself. If the class is parsed first time annotations and field definition is parsed from the class. dict . If the class is a ormar.Model it is skipped. Arguments : base_class : one of the parent classes :type base_class: Model or model parent class curr_class : current constructed class :type curr_class: Model or model parent class attrs : new namespace for class being constructed :type attrs: Dict model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] Returns : updated attrs and model_fields :rtype: Tuple[Dict, Dict]","title":"extract_from_parents_definition"},{"location":"api/models/model-metaclass/#update_attrs_and_fields","text":"1 update_attrs_and_fields ( attrs : Dict , new_attrs : Dict , model_fields : Dict , new_model_fields : Dict , new_fields : Set ) -> Dict Updates annotations , values of model fields (so pydantic FieldInfos) as well as model.Meta.model_fields definitions from parents. Arguments : attrs : new namespace for class being constructed :type attrs: Dict new_attrs : related of the namespace extracted from parent class :type new_attrs: Dict model_fields : ormar fields in defined in current class :type model_fields: Dict[str, BaseField] new_model_fields : ormar fields defined in parent classes :type new_model_fields: Dict[str, BaseField] new_fields : set of new fields names :type new_fields: Set[str]","title":"update_attrs_and_fields"},{"location":"api/models/model-metaclass/#add_field_descriptor","text":"1 add_field_descriptor ( name : str , field : \"BaseField\" , new_model : Type [ \"Model\" ]) -> None Sets appropriate descriptor for each model field. There are 5 main types of descriptors, for bytes, json, pure pydantic fields, and 2 ormar ones - one for relation and one for pk shortcut Arguments : name : name of the field :type name: str field : model field to add descriptor for :type field: BaseField new_model : model with fields :type new_model: Type[\"Model]","title":"add_field_descriptor"},{"location":"api/models/model-metaclass/#modelmetaclass-objects","text":"1 class ModelMetaclass ( pydantic . main . ModelMetaclass )","title":"ModelMetaclass Objects"},{"location":"api/models/model-metaclass/#__new__","text":"1 | __new__ ( mcs : \"ModelMetaclass\" , name : str , bases : Any , attrs : dict ) -> \"ModelMetaclass\" Metaclass used by ormar Models that performs configuration and build of ormar Models. Sets pydantic configuration. Extract model_fields and convert them to pydantic FieldInfo, updates class namespace. Extracts settings and fields from parent classes. Fetches methods decorated with @property_field decorator to expose them later in dict(). Construct parent pydantic Metaclass/ Model. If class has Meta class declared (so actual ormar Models) it also: populate sqlalchemy columns, pkname and tables from model_fields register reverse relationships on related models registers all relations in alias manager that populates table_prefixes exposes alias manager on each Model creates QuerySet for each model and exposes it on a class Arguments : name : name of current class :type name: str bases : base classes :type bases: Tuple attrs : class namespace :type attrs: Dict","title":"__new__"},{"location":"api/models/model-metaclass/#__getattr__","text":"1 | __getattr__ ( item : str ) -> Any Returns FieldAccessors on access to model fields from a class, that way it can be used in python style filters and order_by. Arguments : item : name of the field :type item: str Returns : FieldAccessor for given field :rtype: FieldAccessor","title":"__getattr__"},{"location":"api/models/model-row/","text":"models.model_row ModelRow Objects 1 class ModelRow ( NewBaseModel ) from_row 1 2 | @classmethod | from_row ( cls , row : sqlalchemy . engine . ResultProxy , source_model : Type [ \"Model\" ], select_related : List = None , related_models : Any = None , related_field : \"ForeignKeyField\" = None , excludable : ExcludableItems = None , current_relation_str : str = \"\" , proxy_source_model : Optional [ Type [ \"Model\" ]] = None , used_prefixes : List [ str ] = None ) -> Optional [ \"Model\" ] Model method to convert raw sql row from database into ormar.Model instance. Traverses nested models if they were specified in select_related for query. Called recurrently and returns model instance if it's present in the row. Note that it's processing one row at a time, so if there are duplicates of parent row that needs to be joined/combined (like parent row in sql join with 2+ child rows) instances populated in this method are later combined in the QuerySet. Other method working directly on raw database results is in prefetch_query, where rows are populated in a different way as they do not have nested models in result. Arguments : used_prefixes : list of already extracted prefixes :type used_prefixes: List[str] proxy_source_model : source model from which querysetproxy is constructed :type proxy_source_model: Optional[Type[\"ModelRow\"]] excludable : structure of fields to include and exclude :type excludable: ExcludableItems current_relation_str : name of the relation field :type current_relation_str: str source_model : model on which relation was defined :type source_model: Type[Model] row : raw result row from the database :type row: sqlalchemy.engine.result.ResultProxy select_related : list of names of related models fetched from database :type select_related: List related_models : list or dict of related models :type related_models: Union[List, Dict] related_field : field with relation declaration :type related_field: ForeignKeyField Returns : returns model if model is populated from database :rtype: Optional[Model] _process_table_prefix 1 2 | @classmethod | _process_table_prefix ( cls , source_model : Type [ \"Model\" ], current_relation_str : str , related_field : \"ForeignKeyField\" , used_prefixes : List [ str ]) -> str Arguments : source_model : model on which relation was defined :type source_model: Type[Model] current_relation_str : current relation string :type current_relation_str: str related_field : field with relation declaration :type related_field: \"ForeignKeyField\" used_prefixes : list of already extracted prefixes :type used_prefixes: List[str] Returns : table_prefix to use :rtype: str _populate_nested_models_from_row 1 2 | @classmethod | _populate_nested_models_from_row ( cls , item : dict , row : sqlalchemy . engine . ResultProxy , source_model : Type [ \"Model\" ], related_models : Any , excludable : ExcludableItems , table_prefix : str , used_prefixes : List [ str ], current_relation_str : str = None , proxy_source_model : Type [ \"Model\" ] = None ) -> dict Traverses structure of related models and populates the nested models from the database row. Related models can be a list if only directly related models are to be populated, converted to dict if related models also have their own related models to be populated. Recurrently calls from_row method on nested instances and create nested instances. In the end those instances are added to the final model dictionary. Arguments : proxy_source_model : source model from which querysetproxy is constructed :type proxy_source_model: Optional[Type[\"ModelRow\"]] excludable : structure of fields to include and exclude :type excludable: ExcludableItems source_model : source model from which relation started :type source_model: Type[Model] current_relation_str : joined related parts into one string :type current_relation_str: str item : dictionary of already populated nested models, otherwise empty dict :type item: Dict row : raw result row from the database :type row: sqlalchemy.engine.result.ResultProxy related_models : list or dict of related models :type related_models: Union[Dict, List] Returns : dictionary with keys corresponding to model fields names and values are database values :rtype: Dict _process_remainder_and_relation_string 1 2 | @staticmethod | _process_remainder_and_relation_string ( related_models : Union [ Dict , List ], current_relation_str : Optional [ str ], related : str ) -> Tuple [ str , Optional [ Union [ Dict , List ]]] Process remainder models and relation string Arguments : related_models : list or dict of related models :type related_models: Union[Dict, List] current_relation_str : current relation string :type current_relation_str: Optional[str] related : name of the relation :type related: str _populate_through_instance 1 2 | @classmethod | _populate_through_instance ( cls , row : sqlalchemy . engine . ResultProxy , item : Dict , related : str , excludable : ExcludableItems , child : \"Model\" , proxy_source_model : Optional [ Type [ \"Model\" ]]) -> None Populates the through model on reverse side of current query. Normally it's child class, unless the query is from queryset. Arguments : row : row from db result :type row: sqlalchemy.engine.ResultProxy item : parent item dict :type item: Dict related : current relation name :type related: str excludable : structure of fields to include and exclude :type excludable: ExcludableItems child : child item of parent :type child: \"Model\" proxy_source_model : source model from which querysetproxy is constructed :type proxy_source_model: Type[\"Model\"] _create_through_instance 1 2 | @classmethod | _create_through_instance ( cls , row : sqlalchemy . engine . ResultProxy , through_name : str , related : str , excludable : ExcludableItems ) -> \"ModelRow\" Initialize the through model from db row. Excluded all relation fields and other exclude/include set in excludable. Arguments : row : loaded row from database :type row: sqlalchemy.engine.ResultProxy through_name : name of the through field :type through_name: str related : name of the relation :type related: str excludable : structure of fields to include and exclude :type excludable: ExcludableItems Returns : initialized through model without relation :rtype: \"ModelRow\" extract_prefixed_table_columns 1 2 | @classmethod | extract_prefixed_table_columns ( cls , item : dict , row : sqlalchemy . engine . result . ResultProxy , table_prefix : str , excludable : ExcludableItems ) -> Dict Extracts own fields from raw sql result, using a given prefix. Prefix changes depending on the table's position in a join. If the table is a main table, there is no prefix. All joined tables have prefixes to allow duplicate column names, as well as duplicated joins to the same table from multiple different tables. Extracted fields populates the related dict later used to construct a Model. Used in Model.from_row and PrefetchQuery._populate_rows methods. Arguments : excludable : structure of fields to include and exclude :type excludable: ExcludableItems item : dictionary of already populated nested models, otherwise empty dict :type item: Dict row : raw result row from the database :type row: sqlalchemy.engine.result.ResultProxy table_prefix : prefix of the table from AliasManager each pair of tables have own prefix (two of them depending on direction) - used in joins to allow multiple joins to the same table. :type table_prefix: str Returns : dictionary with keys corresponding to model fields names and values are database values :rtype: Dict","title":"Model Row"},{"location":"api/models/model-row/#modelsmodel_row","text":"","title":"models.model_row"},{"location":"api/models/model-row/#modelrow-objects","text":"1 class ModelRow ( NewBaseModel )","title":"ModelRow Objects"},{"location":"api/models/model-row/#from_row","text":"1 2 | @classmethod | from_row ( cls , row : sqlalchemy . engine . ResultProxy , source_model : Type [ \"Model\" ], select_related : List = None , related_models : Any = None , related_field : \"ForeignKeyField\" = None , excludable : ExcludableItems = None , current_relation_str : str = \"\" , proxy_source_model : Optional [ Type [ \"Model\" ]] = None , used_prefixes : List [ str ] = None ) -> Optional [ \"Model\" ] Model method to convert raw sql row from database into ormar.Model instance. Traverses nested models if they were specified in select_related for query. Called recurrently and returns model instance if it's present in the row. Note that it's processing one row at a time, so if there are duplicates of parent row that needs to be joined/combined (like parent row in sql join with 2+ child rows) instances populated in this method are later combined in the QuerySet. Other method working directly on raw database results is in prefetch_query, where rows are populated in a different way as they do not have nested models in result. Arguments : used_prefixes : list of already extracted prefixes :type used_prefixes: List[str] proxy_source_model : source model from which querysetproxy is constructed :type proxy_source_model: Optional[Type[\"ModelRow\"]] excludable : structure of fields to include and exclude :type excludable: ExcludableItems current_relation_str : name of the relation field :type current_relation_str: str source_model : model on which relation was defined :type source_model: Type[Model] row : raw result row from the database :type row: sqlalchemy.engine.result.ResultProxy select_related : list of names of related models fetched from database :type select_related: List related_models : list or dict of related models :type related_models: Union[List, Dict] related_field : field with relation declaration :type related_field: ForeignKeyField Returns : returns model if model is populated from database :rtype: Optional[Model]","title":"from_row"},{"location":"api/models/model-row/#_process_table_prefix","text":"1 2 | @classmethod | _process_table_prefix ( cls , source_model : Type [ \"Model\" ], current_relation_str : str , related_field : \"ForeignKeyField\" , used_prefixes : List [ str ]) -> str Arguments : source_model : model on which relation was defined :type source_model: Type[Model] current_relation_str : current relation string :type current_relation_str: str related_field : field with relation declaration :type related_field: \"ForeignKeyField\" used_prefixes : list of already extracted prefixes :type used_prefixes: List[str] Returns : table_prefix to use :rtype: str","title":"_process_table_prefix"},{"location":"api/models/model-row/#_populate_nested_models_from_row","text":"1 2 | @classmethod | _populate_nested_models_from_row ( cls , item : dict , row : sqlalchemy . engine . ResultProxy , source_model : Type [ \"Model\" ], related_models : Any , excludable : ExcludableItems , table_prefix : str , used_prefixes : List [ str ], current_relation_str : str = None , proxy_source_model : Type [ \"Model\" ] = None ) -> dict Traverses structure of related models and populates the nested models from the database row. Related models can be a list if only directly related models are to be populated, converted to dict if related models also have their own related models to be populated. Recurrently calls from_row method on nested instances and create nested instances. In the end those instances are added to the final model dictionary. Arguments : proxy_source_model : source model from which querysetproxy is constructed :type proxy_source_model: Optional[Type[\"ModelRow\"]] excludable : structure of fields to include and exclude :type excludable: ExcludableItems source_model : source model from which relation started :type source_model: Type[Model] current_relation_str : joined related parts into one string :type current_relation_str: str item : dictionary of already populated nested models, otherwise empty dict :type item: Dict row : raw result row from the database :type row: sqlalchemy.engine.result.ResultProxy related_models : list or dict of related models :type related_models: Union[Dict, List] Returns : dictionary with keys corresponding to model fields names and values are database values :rtype: Dict","title":"_populate_nested_models_from_row"},{"location":"api/models/model-row/#_process_remainder_and_relation_string","text":"1 2 | @staticmethod | _process_remainder_and_relation_string ( related_models : Union [ Dict , List ], current_relation_str : Optional [ str ], related : str ) -> Tuple [ str , Optional [ Union [ Dict , List ]]] Process remainder models and relation string Arguments : related_models : list or dict of related models :type related_models: Union[Dict, List] current_relation_str : current relation string :type current_relation_str: Optional[str] related : name of the relation :type related: str","title":"_process_remainder_and_relation_string"},{"location":"api/models/model-row/#_populate_through_instance","text":"1 2 | @classmethod | _populate_through_instance ( cls , row : sqlalchemy . engine . ResultProxy , item : Dict , related : str , excludable : ExcludableItems , child : \"Model\" , proxy_source_model : Optional [ Type [ \"Model\" ]]) -> None Populates the through model on reverse side of current query. Normally it's child class, unless the query is from queryset. Arguments : row : row from db result :type row: sqlalchemy.engine.ResultProxy item : parent item dict :type item: Dict related : current relation name :type related: str excludable : structure of fields to include and exclude :type excludable: ExcludableItems child : child item of parent :type child: \"Model\" proxy_source_model : source model from which querysetproxy is constructed :type proxy_source_model: Type[\"Model\"]","title":"_populate_through_instance"},{"location":"api/models/model-row/#_create_through_instance","text":"1 2 | @classmethod | _create_through_instance ( cls , row : sqlalchemy . engine . ResultProxy , through_name : str , related : str , excludable : ExcludableItems ) -> \"ModelRow\" Initialize the through model from db row. Excluded all relation fields and other exclude/include set in excludable. Arguments : row : loaded row from database :type row: sqlalchemy.engine.ResultProxy through_name : name of the through field :type through_name: str related : name of the relation :type related: str excludable : structure of fields to include and exclude :type excludable: ExcludableItems Returns : initialized through model without relation :rtype: \"ModelRow\"","title":"_create_through_instance"},{"location":"api/models/model-row/#extract_prefixed_table_columns","text":"1 2 | @classmethod | extract_prefixed_table_columns ( cls , item : dict , row : sqlalchemy . engine . result . ResultProxy , table_prefix : str , excludable : ExcludableItems ) -> Dict Extracts own fields from raw sql result, using a given prefix. Prefix changes depending on the table's position in a join. If the table is a main table, there is no prefix. All joined tables have prefixes to allow duplicate column names, as well as duplicated joins to the same table from multiple different tables. Extracted fields populates the related dict later used to construct a Model. Used in Model.from_row and PrefetchQuery._populate_rows methods. Arguments : excludable : structure of fields to include and exclude :type excludable: ExcludableItems item : dictionary of already populated nested models, otherwise empty dict :type item: Dict row : raw result row from the database :type row: sqlalchemy.engine.result.ResultProxy table_prefix : prefix of the table from AliasManager each pair of tables have own prefix (two of them depending on direction) - used in joins to allow multiple joins to the same table. :type table_prefix: str Returns : dictionary with keys corresponding to model fields names and values are database values :rtype: Dict","title":"extract_prefixed_table_columns"},{"location":"api/models/model-table-proxy/","text":"models.modelproxy ModelTableProxy Objects 1 2 3 4 5 6 class ModelTableProxy ( PrefetchQueryMixin , MergeModelMixin , SavePrepareMixin , ExcludableMixin , PydanticMixin ) Used to combine all mixins with different set of functionalities. One of the bases of the ormar Model class.","title":"Model Table Proxy"},{"location":"api/models/model-table-proxy/#modelsmodelproxy","text":"","title":"models.modelproxy"},{"location":"api/models/model-table-proxy/#modeltableproxy-objects","text":"1 2 3 4 5 6 class ModelTableProxy ( PrefetchQueryMixin , MergeModelMixin , SavePrepareMixin , ExcludableMixin , PydanticMixin ) Used to combine all mixins with different set of functionalities. One of the bases of the ormar Model class.","title":"ModelTableProxy Objects"},{"location":"api/models/model/","text":"models.model Model Objects 1 class Model ( ModelRow ) upsert 1 | async upsert ( ** kwargs : Any ) -> T Performs either a save or an update depending on the presence of the pk. If the pk field is filled it's an update, otherwise the save is performed. For save kwargs are ignored, used only in update if provided. Arguments : kwargs : list of fields to update :type kwargs: Any Returns : saved Model :rtype: Model save 1 | async save () -> T Performs a save of given Model instance. If primary key is already saved, db backend will throw integrity error. Related models are saved by pk number, reverse relation and many to many fields are not saved - use corresponding relations methods. If there are fields with server_default set and those fields are not already filled save will trigger also a second query to refreshed the fields populated server side. Does not recognize if model was previously saved. If you want to perform update or insert depending on the pk fields presence use upsert. Sends pre_save and post_save signals. Sets model save status to True. Returns : saved Model :rtype: Model save_related 1 | async save_related ( follow : bool = False , save_all : bool = False , relation_map : Dict = None , exclude : Union [ Set , Dict ] = None , update_count : int = 0 , previous_model : \"Model\" = None , relation_field : Optional [ \"ForeignKeyField\" ] = None ) -> int Triggers a upsert method on all related models if the instances are not already saved. By default saves only the directly related ones. If follow=True is set it saves also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are saved, but the save do not follow them inside. So Model A -> Model B -> Model A -> Model C will save second Model A but will never follow into Model C. Nested relations of those kind need to be persisted manually. Arguments : relation_field : field with relation leading to this model :type relation_field: Optional[ForeignKeyField] previous_model : previous model from which method came :type previous_model: Model exclude : items to exclude during saving of relations :type exclude: Union[Set, Dict] relation_map : map of relations to follow :type relation_map: Dict save_all : flag if all models should be saved or only not saved ones :type save_all: bool follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool update_count : internal parameter for recursive calls - number of updated instances :type update_count: int Returns : number of updated/saved models :rtype: int update 1 | async update ( _columns : List [ str ] = None , ** kwargs : Any ) -> T Performs update of Model instance in the database. Fields can be updated before or you can pass them as kwargs. Sends pre_update and post_update signals. Sets model save status to True. Arguments : _columns : list of columns to update, if None all are updated :type _columns: List kwargs : list of fields to update as field=value pairs :type kwargs: Any Raises : ModelPersistenceError : If the pk column is not set Returns : updated Model :rtype: Model delete 1 | async delete () -> int Removes the Model instance from the database. Sends pre_delete and post_delete signals. Sets model save status to False. Note it does not delete the Model itself (python object). So you can delete and later save (since pk is deleted no conflict will arise) or update and the Model will be saved in database again. Returns : number of deleted rows (for some backends) :rtype: int load 1 | async load () -> T Allow to refresh existing Models fields from database. Be careful as the related models can be overwritten by pk_only models in load. Does NOT refresh the related models fields if they were loaded before. Raises : NoMatch : If given pk is not found in database. Returns : reloaded Model :rtype: Model load_all 1 | async load_all ( follow : bool = False , exclude : Union [ List , str , Set , Dict ] = None , order_by : Union [ List , str ] = None ) -> T Allow to refresh existing Models fields from database. Performs refresh of the related models fields. By default loads only self and the directly related ones. If follow=True is set it loads also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -> Model B -> Model C -> Model A -> Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually. Arguments : order_by : columns by which models should be sorted :type order_by: Union[List, str] exclude : related models to exclude :type exclude: Union[List, str, Set, Dict] follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool Raises : NoMatch : If given pk is not found in database. Returns : reloaded Model :rtype: Model","title":"Model"},{"location":"api/models/model/#modelsmodel","text":"","title":"models.model"},{"location":"api/models/model/#model-objects","text":"1 class Model ( ModelRow )","title":"Model Objects"},{"location":"api/models/model/#upsert","text":"1 | async upsert ( ** kwargs : Any ) -> T Performs either a save or an update depending on the presence of the pk. If the pk field is filled it's an update, otherwise the save is performed. For save kwargs are ignored, used only in update if provided. Arguments : kwargs : list of fields to update :type kwargs: Any Returns : saved Model :rtype: Model","title":"upsert"},{"location":"api/models/model/#save","text":"1 | async save () -> T Performs a save of given Model instance. If primary key is already saved, db backend will throw integrity error. Related models are saved by pk number, reverse relation and many to many fields are not saved - use corresponding relations methods. If there are fields with server_default set and those fields are not already filled save will trigger also a second query to refreshed the fields populated server side. Does not recognize if model was previously saved. If you want to perform update or insert depending on the pk fields presence use upsert. Sends pre_save and post_save signals. Sets model save status to True. Returns : saved Model :rtype: Model","title":"save"},{"location":"api/models/model/#save_related","text":"1 | async save_related ( follow : bool = False , save_all : bool = False , relation_map : Dict = None , exclude : Union [ Set , Dict ] = None , update_count : int = 0 , previous_model : \"Model\" = None , relation_field : Optional [ \"ForeignKeyField\" ] = None ) -> int Triggers a upsert method on all related models if the instances are not already saved. By default saves only the directly related ones. If follow=True is set it saves also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are saved, but the save do not follow them inside. So Model A -> Model B -> Model A -> Model C will save second Model A but will never follow into Model C. Nested relations of those kind need to be persisted manually. Arguments : relation_field : field with relation leading to this model :type relation_field: Optional[ForeignKeyField] previous_model : previous model from which method came :type previous_model: Model exclude : items to exclude during saving of relations :type exclude: Union[Set, Dict] relation_map : map of relations to follow :type relation_map: Dict save_all : flag if all models should be saved or only not saved ones :type save_all: bool follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool update_count : internal parameter for recursive calls - number of updated instances :type update_count: int Returns : number of updated/saved models :rtype: int","title":"save_related"},{"location":"api/models/model/#update","text":"1 | async update ( _columns : List [ str ] = None , ** kwargs : Any ) -> T Performs update of Model instance in the database. Fields can be updated before or you can pass them as kwargs. Sends pre_update and post_update signals. Sets model save status to True. Arguments : _columns : list of columns to update, if None all are updated :type _columns: List kwargs : list of fields to update as field=value pairs :type kwargs: Any Raises : ModelPersistenceError : If the pk column is not set Returns : updated Model :rtype: Model","title":"update"},{"location":"api/models/model/#delete","text":"1 | async delete () -> int Removes the Model instance from the database. Sends pre_delete and post_delete signals. Sets model save status to False. Note it does not delete the Model itself (python object). So you can delete and later save (since pk is deleted no conflict will arise) or update and the Model will be saved in database again. Returns : number of deleted rows (for some backends) :rtype: int","title":"delete"},{"location":"api/models/model/#load","text":"1 | async load () -> T Allow to refresh existing Models fields from database. Be careful as the related models can be overwritten by pk_only models in load. Does NOT refresh the related models fields if they were loaded before. Raises : NoMatch : If given pk is not found in database. Returns : reloaded Model :rtype: Model","title":"load"},{"location":"api/models/model/#load_all","text":"1 | async load_all ( follow : bool = False , exclude : Union [ List , str , Set , Dict ] = None , order_by : Union [ List , str ] = None ) -> T Allow to refresh existing Models fields from database. Performs refresh of the related models fields. By default loads only self and the directly related ones. If follow=True is set it loads also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -> Model B -> Model C -> Model A -> Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually. Arguments : order_by : columns by which models should be sorted :type order_by: Union[List, str] exclude : related models to exclude :type exclude: Union[List, str, Set, Dict] follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool Raises : NoMatch : If given pk is not found in database. Returns : reloaded Model :rtype: Model","title":"load_all"},{"location":"api/models/new-basemodel/","text":"models.newbasemodel NewBaseModel Objects 1 class NewBaseModel ( pydantic . BaseModel , ModelTableProxy , metaclass = ModelMetaclass ) Main base class of ormar Model. Inherits from pydantic BaseModel and has all mixins combined in ModelTableProxy. Constructed with ModelMetaclass which in turn also inherits pydantic metaclass. Abstracts away all internals and helper functions, so final Model class has only the logic concerned with database connection and data persistance. __init__ 1 | __init__ ( * args : Any , ** kwargs : Any ) -> None Initializer that creates a new ormar Model that is also pydantic Model at the same time. Passed keyword arguments can be only field names and their corresponding values as those will be passed to pydantic validation that will complain if extra params are passed. If relations are defined each relation is expanded and children models are also initialized and validated. Relation from both sides is registered so you can access related models from both sides. Json fields are automatically loaded/dumped if needed. Models marked as abstract=True in internal Meta class cannot be initialized. Accepts also special pk_only flag that indicates that Model is constructed only with primary key value (so no other fields, it's a child model on other Model), that causes skipping the validation, that's the only case when the validation can be skipped. Accepts also special excluded parameter that contains a set of fields that should be explicitly set to None, as otherwise pydantic will try to populate them with their default values if default is set. Raises : ModelError : if abstract model is initialized, model has ForwardRefs that has not been updated or unknown field is passed Arguments : args : ignored args :type args: Any kwargs : keyword arguments - all fields values and some special params :type kwargs: Any __setattr__ 1 | __setattr__ ( name : str , value : Any ) -> None Overwrites setattr in pydantic parent as otherwise descriptors are not called. Arguments : name : name of the attribute to set :type name: str value : value of the attribute to set :type value: Any Returns : None :rtype: None __getattr__ 1 | __getattr__ ( item : str ) -> Any Used only to silence mypy errors for Through models and reverse relations. Not used in real life as in practice calls are intercepted by RelationDescriptors Arguments : item : name of attribute :type item: str Returns : Any :rtype: Any _internal_set 1 | _internal_set ( name : str , value : Any ) -> None Delegates call to pydantic. Arguments : name : name of param :type name: str value : value to set :type value: Any _verify_model_can_be_initialized 1 | _verify_model_can_be_initialized () -> None Raises exception if model is abstract or has ForwardRefs in relation fields. Returns : None :rtype: None _process_kwargs 1 | _process_kwargs ( kwargs : Dict ) -> Tuple [ Dict , Dict ] Initializes nested models. Removes property_fields Checks if field is in the model fields or pydatnic fields. Nullifies fields that should be excluded. Extracts through models from kwargs into temporary dict. Arguments : kwargs : passed to init keyword arguments :type kwargs: Dict Returns : modified kwargs :rtype: Tuple[Dict, Dict] _initialize_internal_attributes 1 | _initialize_internal_attributes () -> None Initializes internal attributes during init () :rtype: None __eq__ 1 | __eq__ ( other : object ) -> bool Compares other model to this model. when == is called. Arguments : other : other model to compare :type other: object Returns : result of comparison :rtype: bool __same__ 1 | __same__ ( other : \"NewBaseModel\" ) -> bool Used by eq , compares other model to this model. Compares: * _orm_ids, * primary key values if it's set * dictionary of own fields (excluding relations) Arguments : other : model to compare to :type other: NewBaseModel Returns : result of comparison :rtype: bool get_name 1 2 | @classmethod | get_name ( cls , lower : bool = True ) -> str Returns name of the Model class, by default lowercase. Arguments : lower : flag if name should be set to lowercase :type lower: bool Returns : name of the model :rtype: str pk_column 1 2 | @property | pk_column () -> sqlalchemy . Column Retrieves primary key sqlalchemy column from models Meta.table. Each model has to have primary key. Only one primary key column is allowed. Returns : primary key sqlalchemy column :rtype: sqlalchemy.Column saved 1 2 | @property | saved () -> bool Saved status of the model. Changed by setattr and loading from db signals 1 2 | @property | signals () -> \"SignalEmitter\" Exposes signals from model Meta pk_type 1 2 | @classmethod | pk_type ( cls ) -> Any Shortcut to models primary key field type db_backend_name 1 2 | @classmethod | db_backend_name ( cls ) -> str Shortcut to database dialect, cause some dialect require different treatment remove 1 | remove ( parent : \"Model\" , name : str ) -> None Removes child from relation with given name in RelationshipManager set_save_status 1 | set_save_status ( status : bool ) -> None Sets value of the save status get_properties 1 2 | @classmethod | get_properties ( cls , include : Union [ Set , Dict , None ], exclude : Union [ Set , Dict , None ]) -> Set [ str ] Returns a set of names of functions/fields decorated with @property_field decorator. They are added to dictionary when called directly and therefore also are present in fastapi responses. Arguments : include : fields to include :type include: Union[Set, Dict, None] exclude : fields to exclude :type exclude: Union[Set, Dict, None] Returns : set of property fields names :rtype: Set[str] update_forward_refs 1 2 | @classmethod | update_forward_refs ( cls , ** localns : Any ) -> None Processes fields that are ForwardRef and need to be evaluated into actual models. Expands relationships, register relation in alias manager and substitutes sqlalchemy columns with new ones with proper column type (null before). Populates Meta table of the Model which is left empty before. Sets self_reference flag on models that links to themselves. Calls the pydantic method to evaluate pydantic fields. Arguments : localns : local namespace :type localns: Any Returns : None :rtype: None _get_not_excluded_fields 1 2 | @staticmethod | _get_not_excluded_fields ( fields : Union [ List , Set ], include : Optional [ Dict ], exclude : Optional [ Dict ]) -> List Returns related field names applying on them include and exclude set. Arguments : include : fields to include :type include: Union[Set, Dict, None] exclude : fields to exclude :type exclude: Union[Set, Dict, None] Returns : :rtype: List of fields with relations that is not excluded _extract_nested_models_from_list 1 2 | @staticmethod | _extract_nested_models_from_list ( relation_map : Dict , models : MutableSequence , include : Union [ Set , Dict , None ], exclude : Union [ Set , Dict , None ], exclude_primary_keys : bool , exclude_through_models : bool ) -> List Converts list of models into list of dictionaries. Arguments : models : List of models :type models: List include : fields to include :type include: Union[Set, Dict, None] exclude : fields to exclude :type exclude: Union[Set, Dict, None] Returns : list of models converted to dictionaries :rtype: List[Dict] _skip_ellipsis 1 2 | @classmethod | _skip_ellipsis ( cls , items : Union [ Set , Dict , None ], key : str , default_return : Any = None ) -> Union [ Set , Dict , None ] Helper to traverse the include/exclude dictionaries. In dict() Ellipsis should be skipped as it indicates all fields required and not the actual set/dict with fields names. Arguments : items : current include/exclude value :type items: Union[Set, Dict, None] key : key for nested relations to check :type key: str Returns : nested value of the items :rtype: Union[Set, Dict, None] _convert_all 1 2 | @staticmethod | _convert_all ( items : Union [ Set , Dict , None ]) -> Union [ Set , Dict , None ] Helper to convert all pydantic special index to ormar which does not support index based exclusions. Arguments : items : current include/exclude value :type items: Union[Set, Dict, None] _extract_nested_models 1 | _extract_nested_models ( relation_map : Dict , dict_instance : Dict , include : Optional [ Dict ], exclude : Optional [ Dict ], exclude_primary_keys : bool , exclude_through_models : bool ) -> Dict Traverse nested models and converts them into dictionaries. Calls itself recursively if needed. Arguments : nested : flag if current instance is nested :type nested: bool dict_instance : current instance dict :type dict_instance: Dict include : fields to include :type include: Optional[Dict] exclude : fields to exclude :type exclude: Optional[Dict] Returns : current model dict with child models converted to dictionaries :rtype: Dict dict 1 | dict ( * , include : Union [ Set , Dict ] = None , exclude : Union [ Set , Dict ] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , exclude_primary_keys : bool = False , exclude_through_models : bool = False , relation_map : Dict = None ) -> \"DictStrAny\" Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Nested models are also parsed to dictionaries. Additionally fields decorated with @property_field are also added. Arguments : exclude_through_models : flag to exclude through models from dict :type exclude_through_models: bool exclude_primary_keys : flag to exclude primary keys from dict :type exclude_primary_keys: bool include : fields to include :type include: Union[Set, Dict, None] exclude : fields to exclude :type exclude: Union[Set, Dict, None] by_alias : flag to get values by alias - passed to pydantic :type by_alias: bool skip_defaults : flag to not set values - passed to pydantic :type skip_defaults: bool exclude_unset : flag to exclude not set values - passed to pydantic :type exclude_unset: bool exclude_defaults : flag to exclude default values - passed to pydantic :type exclude_defaults: bool exclude_none : flag to exclude None values - passed to pydantic :type exclude_none: bool relation_map : map of the relations to follow to avoid circural deps :type relation_map: Dict Returns : :rtype: json 1 | json ( * , include : Union [ Set , Dict ] = None , exclude : Union [ Set , Dict ] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , exclude_primary_keys : bool = False , exclude_through_models : bool = False , ** dumps_kwargs : Any , ,) -> str Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . update_from_dict 1 | update_from_dict ( value_dict : Dict ) -> \"NewBaseModel\" Updates self with values of fields passed in the dictionary. Arguments : value_dict : dictionary of fields names and values :type value_dict: Dict Returns : self :rtype: NewBaseModel _convert_to_bytes 1 | _convert_to_bytes ( column_name : str , value : Any ) -> Union [ str , Dict ] Converts value to bytes from string Arguments : column_name : name of the field :type column_name: str value : value fo the field :type value: Any Returns : converted value if needed, else original value :rtype: Any _convert_bytes_to_str 1 | _convert_bytes_to_str ( column_name : str , value : Any ) -> Union [ str , Dict ] Converts value to str from bytes for represent_as_base64_str columns. Arguments : column_name : name of the field :type column_name: str value : value fo the field :type value: Any Returns : converted value if needed, else original value :rtype: Any _convert_json 1 | _convert_json ( column_name : str , value : Any ) -> Union [ str , Dict ] Converts value to/from json if needed (for Json columns). Arguments : column_name : name of the field :type column_name: str value : value fo the field :type value: Any Returns : converted value if needed, else original value :rtype: Any _extract_own_model_fields 1 | _extract_own_model_fields () -> Dict Returns a dictionary with field names and values for fields that are not relations fields (ForeignKey, ManyToMany etc.) Returns : dictionary of fields names and values. :rtype: Dict _extract_model_db_fields 1 | _extract_model_db_fields () -> Dict Returns a dictionary with field names and values for fields that are stored in current model's table. That includes own non-relational fields ang foreign key fields. Returns : dictionary of fields names and values. :rtype: Dict get_relation_model_id 1 | get_relation_model_id ( target_field : \"BaseField\" ) -> Optional [ int ] Returns an id of the relation side model to use in prefetch query. Arguments : target_field : field with relation definition :type target_field: \"BaseField\" Returns : value of pk if set :rtype: Optional[int]","title":"New BaseModel"},{"location":"api/models/new-basemodel/#modelsnewbasemodel","text":"","title":"models.newbasemodel"},{"location":"api/models/new-basemodel/#newbasemodel-objects","text":"1 class NewBaseModel ( pydantic . BaseModel , ModelTableProxy , metaclass = ModelMetaclass ) Main base class of ormar Model. Inherits from pydantic BaseModel and has all mixins combined in ModelTableProxy. Constructed with ModelMetaclass which in turn also inherits pydantic metaclass. Abstracts away all internals and helper functions, so final Model class has only the logic concerned with database connection and data persistance.","title":"NewBaseModel Objects"},{"location":"api/models/new-basemodel/#__init__","text":"1 | __init__ ( * args : Any , ** kwargs : Any ) -> None Initializer that creates a new ormar Model that is also pydantic Model at the same time. Passed keyword arguments can be only field names and their corresponding values as those will be passed to pydantic validation that will complain if extra params are passed. If relations are defined each relation is expanded and children models are also initialized and validated. Relation from both sides is registered so you can access related models from both sides. Json fields are automatically loaded/dumped if needed. Models marked as abstract=True in internal Meta class cannot be initialized. Accepts also special pk_only flag that indicates that Model is constructed only with primary key value (so no other fields, it's a child model on other Model), that causes skipping the validation, that's the only case when the validation can be skipped. Accepts also special excluded parameter that contains a set of fields that should be explicitly set to None, as otherwise pydantic will try to populate them with their default values if default is set. Raises : ModelError : if abstract model is initialized, model has ForwardRefs that has not been updated or unknown field is passed Arguments : args : ignored args :type args: Any kwargs : keyword arguments - all fields values and some special params :type kwargs: Any","title":"__init__"},{"location":"api/models/new-basemodel/#__setattr__","text":"1 | __setattr__ ( name : str , value : Any ) -> None Overwrites setattr in pydantic parent as otherwise descriptors are not called. Arguments : name : name of the attribute to set :type name: str value : value of the attribute to set :type value: Any Returns : None :rtype: None","title":"__setattr__"},{"location":"api/models/new-basemodel/#__getattr__","text":"1 | __getattr__ ( item : str ) -> Any Used only to silence mypy errors for Through models and reverse relations. Not used in real life as in practice calls are intercepted by RelationDescriptors Arguments : item : name of attribute :type item: str Returns : Any :rtype: Any","title":"__getattr__"},{"location":"api/models/new-basemodel/#_internal_set","text":"1 | _internal_set ( name : str , value : Any ) -> None Delegates call to pydantic. Arguments : name : name of param :type name: str value : value to set :type value: Any","title":"_internal_set"},{"location":"api/models/new-basemodel/#_verify_model_can_be_initialized","text":"1 | _verify_model_can_be_initialized () -> None Raises exception if model is abstract or has ForwardRefs in relation fields. Returns : None :rtype: None","title":"_verify_model_can_be_initialized"},{"location":"api/models/new-basemodel/#_process_kwargs","text":"1 | _process_kwargs ( kwargs : Dict ) -> Tuple [ Dict , Dict ] Initializes nested models. Removes property_fields Checks if field is in the model fields or pydatnic fields. Nullifies fields that should be excluded. Extracts through models from kwargs into temporary dict. Arguments : kwargs : passed to init keyword arguments :type kwargs: Dict Returns : modified kwargs :rtype: Tuple[Dict, Dict]","title":"_process_kwargs"},{"location":"api/models/new-basemodel/#_initialize_internal_attributes","text":"1 | _initialize_internal_attributes () -> None Initializes internal attributes during init () :rtype: None","title":"_initialize_internal_attributes"},{"location":"api/models/new-basemodel/#__eq__","text":"1 | __eq__ ( other : object ) -> bool Compares other model to this model. when == is called. Arguments : other : other model to compare :type other: object Returns : result of comparison :rtype: bool","title":"__eq__"},{"location":"api/models/new-basemodel/#__same__","text":"1 | __same__ ( other : \"NewBaseModel\" ) -> bool Used by eq , compares other model to this model. Compares: * _orm_ids, * primary key values if it's set * dictionary of own fields (excluding relations) Arguments : other : model to compare to :type other: NewBaseModel Returns : result of comparison :rtype: bool","title":"__same__"},{"location":"api/models/new-basemodel/#get_name","text":"1 2 | @classmethod | get_name ( cls , lower : bool = True ) -> str Returns name of the Model class, by default lowercase. Arguments : lower : flag if name should be set to lowercase :type lower: bool Returns : name of the model :rtype: str","title":"get_name"},{"location":"api/models/new-basemodel/#pk_column","text":"1 2 | @property | pk_column () -> sqlalchemy . Column Retrieves primary key sqlalchemy column from models Meta.table. Each model has to have primary key. Only one primary key column is allowed. Returns : primary key sqlalchemy column :rtype: sqlalchemy.Column","title":"pk_column"},{"location":"api/models/new-basemodel/#saved","text":"1 2 | @property | saved () -> bool Saved status of the model. Changed by setattr and loading from db","title":"saved"},{"location":"api/models/new-basemodel/#signals","text":"1 2 | @property | signals () -> \"SignalEmitter\" Exposes signals from model Meta","title":"signals"},{"location":"api/models/new-basemodel/#pk_type","text":"1 2 | @classmethod | pk_type ( cls ) -> Any Shortcut to models primary key field type","title":"pk_type"},{"location":"api/models/new-basemodel/#db_backend_name","text":"1 2 | @classmethod | db_backend_name ( cls ) -> str Shortcut to database dialect, cause some dialect require different treatment","title":"db_backend_name"},{"location":"api/models/new-basemodel/#remove","text":"1 | remove ( parent : \"Model\" , name : str ) -> None Removes child from relation with given name in RelationshipManager","title":"remove"},{"location":"api/models/new-basemodel/#set_save_status","text":"1 | set_save_status ( status : bool ) -> None Sets value of the save status","title":"set_save_status"},{"location":"api/models/new-basemodel/#get_properties","text":"1 2 | @classmethod | get_properties ( cls , include : Union [ Set , Dict , None ], exclude : Union [ Set , Dict , None ]) -> Set [ str ] Returns a set of names of functions/fields decorated with @property_field decorator. They are added to dictionary when called directly and therefore also are present in fastapi responses. Arguments : include : fields to include :type include: Union[Set, Dict, None] exclude : fields to exclude :type exclude: Union[Set, Dict, None] Returns : set of property fields names :rtype: Set[str]","title":"get_properties"},{"location":"api/models/new-basemodel/#update_forward_refs","text":"1 2 | @classmethod | update_forward_refs ( cls , ** localns : Any ) -> None Processes fields that are ForwardRef and need to be evaluated into actual models. Expands relationships, register relation in alias manager and substitutes sqlalchemy columns with new ones with proper column type (null before). Populates Meta table of the Model which is left empty before. Sets self_reference flag on models that links to themselves. Calls the pydantic method to evaluate pydantic fields. Arguments : localns : local namespace :type localns: Any Returns : None :rtype: None","title":"update_forward_refs"},{"location":"api/models/new-basemodel/#_get_not_excluded_fields","text":"1 2 | @staticmethod | _get_not_excluded_fields ( fields : Union [ List , Set ], include : Optional [ Dict ], exclude : Optional [ Dict ]) -> List Returns related field names applying on them include and exclude set. Arguments : include : fields to include :type include: Union[Set, Dict, None] exclude : fields to exclude :type exclude: Union[Set, Dict, None] Returns : :rtype: List of fields with relations that is not excluded","title":"_get_not_excluded_fields"},{"location":"api/models/new-basemodel/#_extract_nested_models_from_list","text":"1 2 | @staticmethod | _extract_nested_models_from_list ( relation_map : Dict , models : MutableSequence , include : Union [ Set , Dict , None ], exclude : Union [ Set , Dict , None ], exclude_primary_keys : bool , exclude_through_models : bool ) -> List Converts list of models into list of dictionaries. Arguments : models : List of models :type models: List include : fields to include :type include: Union[Set, Dict, None] exclude : fields to exclude :type exclude: Union[Set, Dict, None] Returns : list of models converted to dictionaries :rtype: List[Dict]","title":"_extract_nested_models_from_list"},{"location":"api/models/new-basemodel/#_skip_ellipsis","text":"1 2 | @classmethod | _skip_ellipsis ( cls , items : Union [ Set , Dict , None ], key : str , default_return : Any = None ) -> Union [ Set , Dict , None ] Helper to traverse the include/exclude dictionaries. In dict() Ellipsis should be skipped as it indicates all fields required and not the actual set/dict with fields names. Arguments : items : current include/exclude value :type items: Union[Set, Dict, None] key : key for nested relations to check :type key: str Returns : nested value of the items :rtype: Union[Set, Dict, None]","title":"_skip_ellipsis"},{"location":"api/models/new-basemodel/#_convert_all","text":"1 2 | @staticmethod | _convert_all ( items : Union [ Set , Dict , None ]) -> Union [ Set , Dict , None ] Helper to convert all pydantic special index to ormar which does not support index based exclusions. Arguments : items : current include/exclude value :type items: Union[Set, Dict, None]","title":"_convert_all"},{"location":"api/models/new-basemodel/#_extract_nested_models","text":"1 | _extract_nested_models ( relation_map : Dict , dict_instance : Dict , include : Optional [ Dict ], exclude : Optional [ Dict ], exclude_primary_keys : bool , exclude_through_models : bool ) -> Dict Traverse nested models and converts them into dictionaries. Calls itself recursively if needed. Arguments : nested : flag if current instance is nested :type nested: bool dict_instance : current instance dict :type dict_instance: Dict include : fields to include :type include: Optional[Dict] exclude : fields to exclude :type exclude: Optional[Dict] Returns : current model dict with child models converted to dictionaries :rtype: Dict","title":"_extract_nested_models"},{"location":"api/models/new-basemodel/#dict","text":"1 | dict ( * , include : Union [ Set , Dict ] = None , exclude : Union [ Set , Dict ] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , exclude_primary_keys : bool = False , exclude_through_models : bool = False , relation_map : Dict = None ) -> \"DictStrAny\" Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Nested models are also parsed to dictionaries. Additionally fields decorated with @property_field are also added. Arguments : exclude_through_models : flag to exclude through models from dict :type exclude_through_models: bool exclude_primary_keys : flag to exclude primary keys from dict :type exclude_primary_keys: bool include : fields to include :type include: Union[Set, Dict, None] exclude : fields to exclude :type exclude: Union[Set, Dict, None] by_alias : flag to get values by alias - passed to pydantic :type by_alias: bool skip_defaults : flag to not set values - passed to pydantic :type skip_defaults: bool exclude_unset : flag to exclude not set values - passed to pydantic :type exclude_unset: bool exclude_defaults : flag to exclude default values - passed to pydantic :type exclude_defaults: bool exclude_none : flag to exclude None values - passed to pydantic :type exclude_none: bool relation_map : map of the relations to follow to avoid circural deps :type relation_map: Dict Returns : :rtype:","title":"dict"},{"location":"api/models/new-basemodel/#json","text":"1 | json ( * , include : Union [ Set , Dict ] = None , exclude : Union [ Set , Dict ] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , exclude_primary_keys : bool = False , exclude_through_models : bool = False , ** dumps_kwargs : Any , ,) -> str Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/models/new-basemodel/#update_from_dict","text":"1 | update_from_dict ( value_dict : Dict ) -> \"NewBaseModel\" Updates self with values of fields passed in the dictionary. Arguments : value_dict : dictionary of fields names and values :type value_dict: Dict Returns : self :rtype: NewBaseModel","title":"update_from_dict"},{"location":"api/models/new-basemodel/#_convert_to_bytes","text":"1 | _convert_to_bytes ( column_name : str , value : Any ) -> Union [ str , Dict ] Converts value to bytes from string Arguments : column_name : name of the field :type column_name: str value : value fo the field :type value: Any Returns : converted value if needed, else original value :rtype: Any","title":"_convert_to_bytes"},{"location":"api/models/new-basemodel/#_convert_bytes_to_str","text":"1 | _convert_bytes_to_str ( column_name : str , value : Any ) -> Union [ str , Dict ] Converts value to str from bytes for represent_as_base64_str columns. Arguments : column_name : name of the field :type column_name: str value : value fo the field :type value: Any Returns : converted value if needed, else original value :rtype: Any","title":"_convert_bytes_to_str"},{"location":"api/models/new-basemodel/#_convert_json","text":"1 | _convert_json ( column_name : str , value : Any ) -> Union [ str , Dict ] Converts value to/from json if needed (for Json columns). Arguments : column_name : name of the field :type column_name: str value : value fo the field :type value: Any Returns : converted value if needed, else original value :rtype: Any","title":"_convert_json"},{"location":"api/models/new-basemodel/#_extract_own_model_fields","text":"1 | _extract_own_model_fields () -> Dict Returns a dictionary with field names and values for fields that are not relations fields (ForeignKey, ManyToMany etc.) Returns : dictionary of fields names and values. :rtype: Dict","title":"_extract_own_model_fields"},{"location":"api/models/new-basemodel/#_extract_model_db_fields","text":"1 | _extract_model_db_fields () -> Dict Returns a dictionary with field names and values for fields that are stored in current model's table. That includes own non-relational fields ang foreign key fields. Returns : dictionary of fields names and values. :rtype: Dict","title":"_extract_model_db_fields"},{"location":"api/models/new-basemodel/#get_relation_model_id","text":"1 | get_relation_model_id ( target_field : \"BaseField\" ) -> Optional [ int ] Returns an id of the relation side model to use in prefetch query. Arguments : target_field : field with relation definition :type target_field: \"BaseField\" Returns : value of pk if set :rtype: Optional[int]","title":"get_relation_model_id"},{"location":"api/models/traversible/","text":"models.traversible NodeList Objects 1 class NodeList () Helper class that helps with iterating nested models add 1 | add ( node_class : Type [ \"RelationMixin\" ], relation_name : str = None , parent_node : \"Node\" = None ) -> \"Node\" Adds new Node or returns the existing one Arguments : node_class : Model in current node :type node_class: ormar.models.metaclass.ModelMetaclass relation_name : name of the current relation :type relation_name: str parent_node : parent node :type parent_node: Optional[Node] Returns : returns new or already existing node :rtype: Node find 1 | find ( node_class : Type [ \"RelationMixin\" ], relation_name : Optional [ str ] = None , parent_node : \"Node\" = None ) -> Optional [ \"Node\" ] Searches for existing node with given parameters Arguments : node_class : Model in current node :type node_class: ormar.models.metaclass.ModelMetaclass relation_name : name of the current relation :type relation_name: str parent_node : parent node :type parent_node: Optional[Node] Returns : returns already existing node or None :rtype: Optional[Node] Node Objects 1 class Node () visited 1 | visited ( relation_name : str ) -> bool Checks if given relation was already visited. Relation was visited if it's name is in current node children. Relation was visited if one of the parent node had the same Model class Arguments : relation_name : name of relation :type relation_name: str Returns : result of the check :rtype: bool","title":"Traversible"},{"location":"api/models/traversible/#modelstraversible","text":"","title":"models.traversible"},{"location":"api/models/traversible/#nodelist-objects","text":"1 class NodeList () Helper class that helps with iterating nested models","title":"NodeList Objects"},{"location":"api/models/traversible/#add","text":"1 | add ( node_class : Type [ \"RelationMixin\" ], relation_name : str = None , parent_node : \"Node\" = None ) -> \"Node\" Adds new Node or returns the existing one Arguments : node_class : Model in current node :type node_class: ormar.models.metaclass.ModelMetaclass relation_name : name of the current relation :type relation_name: str parent_node : parent node :type parent_node: Optional[Node] Returns : returns new or already existing node :rtype: Node","title":"add"},{"location":"api/models/traversible/#find","text":"1 | find ( node_class : Type [ \"RelationMixin\" ], relation_name : Optional [ str ] = None , parent_node : \"Node\" = None ) -> Optional [ \"Node\" ] Searches for existing node with given parameters Arguments : node_class : Model in current node :type node_class: ormar.models.metaclass.ModelMetaclass relation_name : name of the current relation :type relation_name: str parent_node : parent node :type parent_node: Optional[Node] Returns : returns already existing node or None :rtype: Optional[Node]","title":"find"},{"location":"api/models/traversible/#node-objects","text":"1 class Node ()","title":"Node Objects"},{"location":"api/models/traversible/#visited","text":"1 | visited ( relation_name : str ) -> bool Checks if given relation was already visited. Relation was visited if it's name is in current node children. Relation was visited if one of the parent node had the same Model class Arguments : relation_name : name of relation :type relation_name: str Returns : result of the check :rtype: bool","title":"visited"},{"location":"api/models/descriptors/descriptors/","text":"models.descriptors.descriptors PydanticDescriptor Objects 1 class PydanticDescriptor () Pydantic descriptor simply delegates everything to pydantic model JsonDescriptor Objects 1 class JsonDescriptor () Json descriptor dumps/loads strings to actual data on write/read BytesDescriptor Objects 1 class BytesDescriptor () Bytes descriptor converts strings to bytes on write and converts bytes to str if represent_as_base64_str flag is set, so the value can be dumped to json PkDescriptor Objects 1 class PkDescriptor () As of now it's basically a copy of PydanticDescriptor but that will change in the future with multi column primary keys RelationDescriptor Objects 1 class RelationDescriptor () Relation descriptor expands the relation to initialize the related model before setting it to dict . Note that expanding also registers the related model in RelationManager. PropertyDescriptor Objects 1 class PropertyDescriptor () Property descriptor handles methods decorated with @property_field decorator. They are read only.","title":"Descriptors"},{"location":"api/models/descriptors/descriptors/#modelsdescriptorsdescriptors","text":"","title":"models.descriptors.descriptors"},{"location":"api/models/descriptors/descriptors/#pydanticdescriptor-objects","text":"1 class PydanticDescriptor () Pydantic descriptor simply delegates everything to pydantic model","title":"PydanticDescriptor Objects"},{"location":"api/models/descriptors/descriptors/#jsondescriptor-objects","text":"1 class JsonDescriptor () Json descriptor dumps/loads strings to actual data on write/read","title":"JsonDescriptor Objects"},{"location":"api/models/descriptors/descriptors/#bytesdescriptor-objects","text":"1 class BytesDescriptor () Bytes descriptor converts strings to bytes on write and converts bytes to str if represent_as_base64_str flag is set, so the value can be dumped to json","title":"BytesDescriptor Objects"},{"location":"api/models/descriptors/descriptors/#pkdescriptor-objects","text":"1 class PkDescriptor () As of now it's basically a copy of PydanticDescriptor but that will change in the future with multi column primary keys","title":"PkDescriptor Objects"},{"location":"api/models/descriptors/descriptors/#relationdescriptor-objects","text":"1 class RelationDescriptor () Relation descriptor expands the relation to initialize the related model before setting it to dict . Note that expanding also registers the related model in RelationManager.","title":"RelationDescriptor Objects"},{"location":"api/models/descriptors/descriptors/#propertydescriptor-objects","text":"1 class PropertyDescriptor () Property descriptor handles methods decorated with @property_field decorator. They are read only.","title":"PropertyDescriptor Objects"},{"location":"api/models/helpers/models/","text":"models.helpers.models is_field_an_forward_ref 1 is_field_an_forward_ref ( field : \"BaseField\" ) -> bool Checks if field is a relation field and whether any of the referenced models are ForwardRefs that needs to be updated before proceeding. Arguments : field : model field to verify :type field: Type[BaseField] Returns : result of the check :rtype: bool populate_default_options_values 1 populate_default_options_values ( new_model : Type [ \"Model\" ], model_fields : Dict ) -> None Sets all optional Meta values to it's defaults and set model_fields that were already previously extracted. Here should live all options that are not overwritten/set for all models. Current options are: * constraints = [] * abstract = False Arguments : new_model : newly constructed Model :type new_model: Model class model_fields : dict of model fields :type model_fields: Union[Dict[str, type], Dict] substitue_backend_pool_for_sqlite 1 substitue_backend_pool_for_sqlite ( new_model : Type [ \"Model\" ]) -> None Recreates Connection pool for sqlite3 with new factory that executes \"PRAGMA foreign_keys=1; on initialization to enable foreign keys. Arguments : new_model : newly declared ormar Model :type new_model: Model class check_required_meta_parameters 1 check_required_meta_parameters ( new_model : Type [ \"Model\" ]) -> None Verifies if ormar.Model has database and metadata set. Recreates Connection pool for sqlite3 Arguments : new_model : newly declared ormar Model :type new_model: Model class extract_annotations_and_default_vals 1 extract_annotations_and_default_vals ( attrs : Dict ) -> Tuple [ Dict , Dict ] Extracts annotations from class namespace dict and triggers extraction of ormar model_fields. Arguments : attrs : namespace of the class created :type attrs: Dict Returns : namespace of the class updated, dict of extracted model_fields :rtype: Tuple[Dict, Dict] group_related_list 1 group_related_list ( list_ : List ) -> collections . OrderedDict Translates the list of related strings into a dictionary. That way nested models are grouped to traverse them in a right order and to avoid repetition. Sample: [\"people__houses\", \"people__cars__models\", \"people__cars__colors\"] will become: {'people': {'houses': [], 'cars': ['models', 'colors']}} Result dictionary is sorted by length of the values and by key Arguments : list_ : list of related models used in select related :type list_: List[str] Returns : list converted to dictionary to avoid repetition and group nested models :rtype: Dict[str, List] meta_field_not_set 1 meta_field_not_set ( model : Type [ \"Model\" ], field_name : str ) -> bool Checks if field with given name is already present in model.Meta. Then check if it's set to something truthful (in practice meaning not None, as it's non or ormar Field only). Arguments : model : newly constructed model :type model: Model class field_name : name of the ormar field :type field_name: str Returns : result of the check :rtype: bool","title":"Models"},{"location":"api/models/helpers/models/#modelshelpersmodels","text":"","title":"models.helpers.models"},{"location":"api/models/helpers/models/#is_field_an_forward_ref","text":"1 is_field_an_forward_ref ( field : \"BaseField\" ) -> bool Checks if field is a relation field and whether any of the referenced models are ForwardRefs that needs to be updated before proceeding. Arguments : field : model field to verify :type field: Type[BaseField] Returns : result of the check :rtype: bool","title":"is_field_an_forward_ref"},{"location":"api/models/helpers/models/#populate_default_options_values","text":"1 populate_default_options_values ( new_model : Type [ \"Model\" ], model_fields : Dict ) -> None Sets all optional Meta values to it's defaults and set model_fields that were already previously extracted. Here should live all options that are not overwritten/set for all models. Current options are: * constraints = [] * abstract = False Arguments : new_model : newly constructed Model :type new_model: Model class model_fields : dict of model fields :type model_fields: Union[Dict[str, type], Dict]","title":"populate_default_options_values"},{"location":"api/models/helpers/models/#substitue_backend_pool_for_sqlite","text":"1 substitue_backend_pool_for_sqlite ( new_model : Type [ \"Model\" ]) -> None Recreates Connection pool for sqlite3 with new factory that executes \"PRAGMA foreign_keys=1; on initialization to enable foreign keys. Arguments : new_model : newly declared ormar Model :type new_model: Model class","title":"substitue_backend_pool_for_sqlite"},{"location":"api/models/helpers/models/#check_required_meta_parameters","text":"1 check_required_meta_parameters ( new_model : Type [ \"Model\" ]) -> None Verifies if ormar.Model has database and metadata set. Recreates Connection pool for sqlite3 Arguments : new_model : newly declared ormar Model :type new_model: Model class","title":"check_required_meta_parameters"},{"location":"api/models/helpers/models/#extract_annotations_and_default_vals","text":"1 extract_annotations_and_default_vals ( attrs : Dict ) -> Tuple [ Dict , Dict ] Extracts annotations from class namespace dict and triggers extraction of ormar model_fields. Arguments : attrs : namespace of the class created :type attrs: Dict Returns : namespace of the class updated, dict of extracted model_fields :rtype: Tuple[Dict, Dict]","title":"extract_annotations_and_default_vals"},{"location":"api/models/helpers/models/#group_related_list","text":"1 group_related_list ( list_ : List ) -> collections . OrderedDict Translates the list of related strings into a dictionary. That way nested models are grouped to traverse them in a right order and to avoid repetition. Sample: [\"people__houses\", \"people__cars__models\", \"people__cars__colors\"] will become: {'people': {'houses': [], 'cars': ['models', 'colors']}} Result dictionary is sorted by length of the values and by key Arguments : list_ : list of related models used in select related :type list_: List[str] Returns : list converted to dictionary to avoid repetition and group nested models :rtype: Dict[str, List]","title":"group_related_list"},{"location":"api/models/helpers/models/#meta_field_not_set","text":"1 meta_field_not_set ( model : Type [ \"Model\" ], field_name : str ) -> bool Checks if field with given name is already present in model.Meta. Then check if it's set to something truthful (in practice meaning not None, as it's non or ormar Field only). Arguments : model : newly constructed model :type model: Model class field_name : name of the ormar field :type field_name: str Returns : result of the check :rtype: bool","title":"meta_field_not_set"},{"location":"api/models/helpers/pydantic/","text":"models.helpers.pydantic create_pydantic_field 1 create_pydantic_field ( field_name : str , model : Type [ \"Model\" ], model_field : \"ManyToManyField\" ) -> None Registers pydantic field on through model that leads to passed model and is registered as field_name passed. Through model is fetched from through attributed on passed model_field. Arguments : field_name : field name to register :type field_name: str model : type of field to register :type model: Model class model_field : relation field from which through model is extracted :type model_field: ManyToManyField class get_pydantic_field 1 get_pydantic_field ( field_name : str , model : Type [ \"Model\" ]) -> \"ModelField\" Extracts field type and if it's required from Model model_fields by passed field_name. Returns a pydantic field with type of field_name field type. Arguments : field_name : field name to fetch from Model and name of pydantic field :type field_name: str model : type of field to register :type model: Model class Returns : newly created pydantic field :rtype: pydantic.ModelField populate_pydantic_default_values 1 populate_pydantic_default_values ( attrs : Dict ) -> Tuple [ Dict , Dict ] Extracts ormar fields from annotations (deprecated) and from namespace dictionary of the class. Fields declared on model are all subclasses of the BaseField class. Trigger conversion of ormar field into pydantic FieldInfo, which has all needed parameters saved. Overwrites the annotations of ormar fields to corresponding types declared on ormar fields (constructed dynamically for relations). Those annotations are later used by pydantic to construct it's own fields. Arguments : attrs : current class namespace :type attrs: Dict Returns : namespace of the class updated, dict of extracted model_fields :rtype: Tuple[Dict, Dict] merge_or_generate_pydantic_config 1 merge_or_generate_pydantic_config ( attrs : Dict , name : str ) -> None Checks if the user provided pydantic Config, and if he did merges it with the default one. Updates the attrs in place with a new config. :rtype: None get_pydantic_base_orm_config 1 get_pydantic_base_orm_config () -> Type [ pydantic . BaseConfig ] Returns empty pydantic Config with orm_mode set to True. Returns : empty default config with orm_mode set. :rtype: pydantic Config get_potential_fields 1 get_potential_fields ( attrs : Dict ) -> Dict Gets all the fields in current class namespace that are Fields. Arguments : attrs : current class namespace :type attrs: Dict Returns : extracted fields that are ormar Fields :rtype: Dict remove_excluded_parent_fields 1 remove_excluded_parent_fields ( model : Type [ \"Model\" ]) -> None Removes pydantic fields that should be excluded from parent models Arguments : model : :type model: Type[\"Model\"]","title":"Pydantic"},{"location":"api/models/helpers/pydantic/#modelshelperspydantic","text":"","title":"models.helpers.pydantic"},{"location":"api/models/helpers/pydantic/#create_pydantic_field","text":"1 create_pydantic_field ( field_name : str , model : Type [ \"Model\" ], model_field : \"ManyToManyField\" ) -> None Registers pydantic field on through model that leads to passed model and is registered as field_name passed. Through model is fetched from through attributed on passed model_field. Arguments : field_name : field name to register :type field_name: str model : type of field to register :type model: Model class model_field : relation field from which through model is extracted :type model_field: ManyToManyField class","title":"create_pydantic_field"},{"location":"api/models/helpers/pydantic/#get_pydantic_field","text":"1 get_pydantic_field ( field_name : str , model : Type [ \"Model\" ]) -> \"ModelField\" Extracts field type and if it's required from Model model_fields by passed field_name. Returns a pydantic field with type of field_name field type. Arguments : field_name : field name to fetch from Model and name of pydantic field :type field_name: str model : type of field to register :type model: Model class Returns : newly created pydantic field :rtype: pydantic.ModelField","title":"get_pydantic_field"},{"location":"api/models/helpers/pydantic/#populate_pydantic_default_values","text":"1 populate_pydantic_default_values ( attrs : Dict ) -> Tuple [ Dict , Dict ] Extracts ormar fields from annotations (deprecated) and from namespace dictionary of the class. Fields declared on model are all subclasses of the BaseField class. Trigger conversion of ormar field into pydantic FieldInfo, which has all needed parameters saved. Overwrites the annotations of ormar fields to corresponding types declared on ormar fields (constructed dynamically for relations). Those annotations are later used by pydantic to construct it's own fields. Arguments : attrs : current class namespace :type attrs: Dict Returns : namespace of the class updated, dict of extracted model_fields :rtype: Tuple[Dict, Dict]","title":"populate_pydantic_default_values"},{"location":"api/models/helpers/pydantic/#merge_or_generate_pydantic_config","text":"1 merge_or_generate_pydantic_config ( attrs : Dict , name : str ) -> None Checks if the user provided pydantic Config, and if he did merges it with the default one. Updates the attrs in place with a new config. :rtype: None","title":"merge_or_generate_pydantic_config"},{"location":"api/models/helpers/pydantic/#get_pydantic_base_orm_config","text":"1 get_pydantic_base_orm_config () -> Type [ pydantic . BaseConfig ] Returns empty pydantic Config with orm_mode set to True. Returns : empty default config with orm_mode set. :rtype: pydantic Config","title":"get_pydantic_base_orm_config"},{"location":"api/models/helpers/pydantic/#get_potential_fields","text":"1 get_potential_fields ( attrs : Dict ) -> Dict Gets all the fields in current class namespace that are Fields. Arguments : attrs : current class namespace :type attrs: Dict Returns : extracted fields that are ormar Fields :rtype: Dict","title":"get_potential_fields"},{"location":"api/models/helpers/pydantic/#remove_excluded_parent_fields","text":"1 remove_excluded_parent_fields ( model : Type [ \"Model\" ]) -> None Removes pydantic fields that should be excluded from parent models Arguments : model : :type model: Type[\"Model\"]","title":"remove_excluded_parent_fields"},{"location":"api/models/helpers/related-names-validation/","text":"models.helpers.related_names_validation validate_related_names_in_relations 1 validate_related_names_in_relations ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> None Performs a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param (populated by default as model.name.lower()+'s'). Also related_names have to be unique for given related model. Raises : ModelDefinitionError : if validation of related_names fail Arguments : model_fields : dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] new_model : :type new_model: Model class","title":"Related names validation"},{"location":"api/models/helpers/related-names-validation/#modelshelpersrelated_names_validation","text":"","title":"models.helpers.related_names_validation"},{"location":"api/models/helpers/related-names-validation/#validate_related_names_in_relations","text":"1 validate_related_names_in_relations ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> None Performs a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param (populated by default as model.name.lower()+'s'). Also related_names have to be unique for given related model. Raises : ModelDefinitionError : if validation of related_names fail Arguments : model_fields : dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] new_model : :type new_model: Model class","title":"validate_related_names_in_relations"},{"location":"api/models/helpers/relations/","text":"models.helpers.relations register_relation_on_build 1 register_relation_on_build ( field : \"ForeignKeyField\" ) -> None Registers ForeignKey relation in alias_manager to set a table_prefix. Registration include also reverse relation side to be able to join both sides. Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins. Arguments : field : relation field :type field: ForeignKey class register_many_to_many_relation_on_build 1 register_many_to_many_relation_on_build ( field : \"ManyToManyField\" ) -> None Registers connection between through model and both sides of the m2m relation. Registration include also reverse relation side to be able to join both sides. Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins. By default relation name is a model.name.lower(). Arguments : field : relation field :type field: ManyToManyField class expand_reverse_relationship 1 expand_reverse_relationship ( model_field : \"ForeignKeyField\" ) -> None If the reverse relation has not been set before it's set here. Arguments : model_field : :type model_field: Returns : None :rtype: None expand_reverse_relationships 1 expand_reverse_relationships ( model : Type [ \"Model\" ]) -> None Iterates through model_fields of given model and verifies if all reverse relation have been populated on related models. If the reverse relation has not been set before it's set here. Arguments : model : model on which relation should be checked and registered :type model: Model class register_reverse_model_fields 1 register_reverse_model_fields ( model_field : \"ForeignKeyField\" ) -> None Registers reverse ForeignKey field on related model. By default it's name.lower()+'s' of the model on which relation is defined. But if the related_model name is provided it's registered with that name. Autogenerated reverse fields also set related_name to the original field name. Arguments : model_field : original relation ForeignKey field :type model_field: relation Field register_through_shortcut_fields 1 register_through_shortcut_fields ( model_field : \"ManyToManyField\" ) -> None Registers m2m relation through shortcut on both ends of the relation. Arguments : model_field : relation field defined in parent model :type model_field: ManyToManyField register_relation_in_alias_manager 1 register_relation_in_alias_manager ( field : \"ForeignKeyField\" ) -> None Registers the relation (and reverse relation) in alias manager. The m2m relations require registration of through model between actual end models of the relation. Delegates the actual registration to: m2m - register_many_to_many_relation_on_build fk - register_relation_on_build Arguments : field : relation field :type field: ForeignKey or ManyToManyField class verify_related_name_dont_duplicate 1 verify_related_name_dont_duplicate ( related_name : str , model_field : \"ForeignKeyField\" ) -> None Verifies whether the used related_name (regardless of the fact if user defined or auto generated) is already used on related model, but is connected with other model than the one that we connect right now. Raises : ModelDefinitionError : if name is already used but lead to different related model Arguments : related_name : :type related_name: model_field : original relation ForeignKey field :type model_field: relation Field Returns : None :rtype: None reverse_field_not_already_registered 1 reverse_field_not_already_registered ( model_field : \"ForeignKeyField\" ) -> bool Checks if child is already registered in parents pydantic fields. Raises : ModelDefinitionError : if related name is already used but lead to different related model Arguments : model_field : original relation ForeignKey field :type model_field: relation Field Returns : result of the check :rtype: bool","title":"Relations"},{"location":"api/models/helpers/relations/#modelshelpersrelations","text":"","title":"models.helpers.relations"},{"location":"api/models/helpers/relations/#register_relation_on_build","text":"1 register_relation_on_build ( field : \"ForeignKeyField\" ) -> None Registers ForeignKey relation in alias_manager to set a table_prefix. Registration include also reverse relation side to be able to join both sides. Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins. Arguments : field : relation field :type field: ForeignKey class","title":"register_relation_on_build"},{"location":"api/models/helpers/relations/#register_many_to_many_relation_on_build","text":"1 register_many_to_many_relation_on_build ( field : \"ManyToManyField\" ) -> None Registers connection between through model and both sides of the m2m relation. Registration include also reverse relation side to be able to join both sides. Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins. By default relation name is a model.name.lower(). Arguments : field : relation field :type field: ManyToManyField class","title":"register_many_to_many_relation_on_build"},{"location":"api/models/helpers/relations/#expand_reverse_relationship","text":"1 expand_reverse_relationship ( model_field : \"ForeignKeyField\" ) -> None If the reverse relation has not been set before it's set here. Arguments : model_field : :type model_field: Returns : None :rtype: None","title":"expand_reverse_relationship"},{"location":"api/models/helpers/relations/#expand_reverse_relationships","text":"1 expand_reverse_relationships ( model : Type [ \"Model\" ]) -> None Iterates through model_fields of given model and verifies if all reverse relation have been populated on related models. If the reverse relation has not been set before it's set here. Arguments : model : model on which relation should be checked and registered :type model: Model class","title":"expand_reverse_relationships"},{"location":"api/models/helpers/relations/#register_reverse_model_fields","text":"1 register_reverse_model_fields ( model_field : \"ForeignKeyField\" ) -> None Registers reverse ForeignKey field on related model. By default it's name.lower()+'s' of the model on which relation is defined. But if the related_model name is provided it's registered with that name. Autogenerated reverse fields also set related_name to the original field name. Arguments : model_field : original relation ForeignKey field :type model_field: relation Field","title":"register_reverse_model_fields"},{"location":"api/models/helpers/relations/#register_through_shortcut_fields","text":"1 register_through_shortcut_fields ( model_field : \"ManyToManyField\" ) -> None Registers m2m relation through shortcut on both ends of the relation. Arguments : model_field : relation field defined in parent model :type model_field: ManyToManyField","title":"register_through_shortcut_fields"},{"location":"api/models/helpers/relations/#register_relation_in_alias_manager","text":"1 register_relation_in_alias_manager ( field : \"ForeignKeyField\" ) -> None Registers the relation (and reverse relation) in alias manager. The m2m relations require registration of through model between actual end models of the relation. Delegates the actual registration to: m2m - register_many_to_many_relation_on_build fk - register_relation_on_build Arguments : field : relation field :type field: ForeignKey or ManyToManyField class","title":"register_relation_in_alias_manager"},{"location":"api/models/helpers/relations/#verify_related_name_dont_duplicate","text":"1 verify_related_name_dont_duplicate ( related_name : str , model_field : \"ForeignKeyField\" ) -> None Verifies whether the used related_name (regardless of the fact if user defined or auto generated) is already used on related model, but is connected with other model than the one that we connect right now. Raises : ModelDefinitionError : if name is already used but lead to different related model Arguments : related_name : :type related_name: model_field : original relation ForeignKey field :type model_field: relation Field Returns : None :rtype: None","title":"verify_related_name_dont_duplicate"},{"location":"api/models/helpers/relations/#reverse_field_not_already_registered","text":"1 reverse_field_not_already_registered ( model_field : \"ForeignKeyField\" ) -> bool Checks if child is already registered in parents pydantic fields. Raises : ModelDefinitionError : if related name is already used but lead to different related model Arguments : model_field : original relation ForeignKey field :type model_field: relation Field Returns : result of the check :rtype: bool","title":"reverse_field_not_already_registered"},{"location":"api/models/helpers/sqlalchemy/","text":"models.helpers.sqlalchemy adjust_through_many_to_many_model 1 adjust_through_many_to_many_model ( model_field : \"ManyToManyField\" ) -> None Registers m2m relation on through model. Sets ormar.ForeignKey from through model to both child and parent models. Sets sqlalchemy.ForeignKey to both child and parent models. Sets pydantic fields with child and parent model types. Arguments : model_field : relation field defined in parent model :type model_field: ManyToManyField create_and_append_m2m_fk 1 create_and_append_m2m_fk ( model : Type [ \"Model\" ], model_field : \"ManyToManyField\" , field_name : str ) -> None Registers sqlalchemy Column with sqlalchemy.ForeignKey leading to the model. Newly created field is added to m2m relation through model Meta columns and table. Arguments : field_name : name of the column to create :type field_name: str model : Model class to which FK should be created :type model: Model class model_field : field with ManyToMany relation :type model_field: ManyToManyField field check_pk_column_validity 1 check_pk_column_validity ( field_name : str , field : \"BaseField\" , pkname : Optional [ str ]) -> Optional [ str ] Receives the field marked as primary key and verifies if the pkname was not already set (only one allowed per model) and if field is not marked as pydantic_only as it needs to be a database field. Raises : ModelDefintionError : if pkname already set or field is pydantic_only Arguments : field_name : name of field :type field_name: str field : ormar.Field :type field: BaseField pkname : already set pkname :type pkname: Optional[str] Returns : name of the field that should be set as pkname :rtype: str sqlalchemy_columns_from_model_fields 1 sqlalchemy_columns_from_model_fields ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> Tuple [ Optional [ str ], List [ sqlalchemy . Column ]] Iterates over declared on Model model fields and extracts fields that should be treated as database fields. If the model is empty it sets mandatory id field as primary key (used in through models in m2m relations). Triggers a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param. Also related_names have to be unique. Trigger validation of primary_key - only one and required pk can be set, cannot be pydantic_only. Append fields to columns if it's not pydantic_only, virtual ForeignKey or ManyToMany field. Sets owner on each model_field as reference to newly created Model. Raises : ModelDefinitionError : if validation of related_names fail, or pkname validation fails. Arguments : model_fields : dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] new_model : :type new_model: Model class Returns : pkname, list of sqlalchemy columns :rtype: Tuple[Optional[str], List[sqlalchemy.Column]] _process_fields 1 _process_fields ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> Tuple [ Optional [ str ], List [ sqlalchemy . Column ]] Helper method. Populates pkname and columns. Trigger validation of primary_key - only one and required pk can be set, cannot be pydantic_only. Append fields to columns if it's not pydantic_only, virtual ForeignKey or ManyToMany field. Sets owner on each model_field as reference to newly created Model. Raises : ModelDefinitionError : if validation of related_names fail, or pkname validation fails. Arguments : model_fields : dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] new_model : :type new_model: Model class Returns : pkname, list of sqlalchemy columns :rtype: Tuple[Optional[str], List[sqlalchemy.Column]] _is_through_model_not_set 1 _is_through_model_not_set ( field : \"BaseField\" ) -> bool Alias to if check that verifies if through model was created. Arguments : field : field to check :type field: \"BaseField\" Returns : result of the check :rtype: bool _is_db_field 1 _is_db_field ( field : \"BaseField\" ) -> bool Alias to if check that verifies if field should be included in database. Arguments : field : field to check :type field: \"BaseField\" Returns : result of the check :rtype: bool populate_meta_tablename_columns_and_pk 1 populate_meta_tablename_columns_and_pk ( name : str , new_model : Type [ \"Model\" ]) -> Type [ \"Model\" ] Sets Model tablename if it's not already set in Meta. Default tablename if not present is class name lower + s (i.e. Bed becomes -> beds) Checks if Model's Meta have pkname and columns set. If not calls the sqlalchemy_columns_from_model_fields to populate columns from ormar.fields definitions. Raises : ModelDefinitionError : if pkname is not present raises ModelDefinitionError. Each model has to have pk. Arguments : name : name of the current Model :type name: str new_model : currently constructed Model :type new_model: ormar.models.metaclass.ModelMetaclass Returns : Model with populated pkname and columns in Meta :rtype: ormar.models.metaclass.ModelMetaclass check_for_null_type_columns_from_forward_refs 1 check_for_null_type_columns_from_forward_refs ( meta : \"ModelMeta\" ) -> bool Check is any column is of NUllType() meaning it's empty column from ForwardRef Arguments : meta : Meta class of the Model without sqlalchemy table constructed :type meta: Model class Meta Returns : result of the check :rtype: bool populate_meta_sqlalchemy_table_if_required 1 populate_meta_sqlalchemy_table_if_required ( meta : \"ModelMeta\" ) -> None Constructs sqlalchemy table out of columns and parameters set on Meta class. It populates name, metadata, columns and constraints. Arguments : meta : Meta class of the Model without sqlalchemy table constructed :type meta: Model class Meta Returns : class with populated Meta.table :rtype: Model class update_column_definition 1 update_column_definition ( model : Union [ Type [ \"Model\" ], Type [ \"NewBaseModel\" ]], field : \"ForeignKeyField\" ) -> None Updates a column with a new type column based on updated parameters in FK fields. Arguments : model : model on which columns needs to be updated :type model: Type[\"Model\"] field : field with column definition that requires update :type field: ForeignKeyField Returns : None :rtype: None","title":"Sqlalchemy"},{"location":"api/models/helpers/sqlalchemy/#modelshelperssqlalchemy","text":"","title":"models.helpers.sqlalchemy"},{"location":"api/models/helpers/sqlalchemy/#adjust_through_many_to_many_model","text":"1 adjust_through_many_to_many_model ( model_field : \"ManyToManyField\" ) -> None Registers m2m relation on through model. Sets ormar.ForeignKey from through model to both child and parent models. Sets sqlalchemy.ForeignKey to both child and parent models. Sets pydantic fields with child and parent model types. Arguments : model_field : relation field defined in parent model :type model_field: ManyToManyField","title":"adjust_through_many_to_many_model"},{"location":"api/models/helpers/sqlalchemy/#create_and_append_m2m_fk","text":"1 create_and_append_m2m_fk ( model : Type [ \"Model\" ], model_field : \"ManyToManyField\" , field_name : str ) -> None Registers sqlalchemy Column with sqlalchemy.ForeignKey leading to the model. Newly created field is added to m2m relation through model Meta columns and table. Arguments : field_name : name of the column to create :type field_name: str model : Model class to which FK should be created :type model: Model class model_field : field with ManyToMany relation :type model_field: ManyToManyField field","title":"create_and_append_m2m_fk"},{"location":"api/models/helpers/sqlalchemy/#check_pk_column_validity","text":"1 check_pk_column_validity ( field_name : str , field : \"BaseField\" , pkname : Optional [ str ]) -> Optional [ str ] Receives the field marked as primary key and verifies if the pkname was not already set (only one allowed per model) and if field is not marked as pydantic_only as it needs to be a database field. Raises : ModelDefintionError : if pkname already set or field is pydantic_only Arguments : field_name : name of field :type field_name: str field : ormar.Field :type field: BaseField pkname : already set pkname :type pkname: Optional[str] Returns : name of the field that should be set as pkname :rtype: str","title":"check_pk_column_validity"},{"location":"api/models/helpers/sqlalchemy/#sqlalchemy_columns_from_model_fields","text":"1 sqlalchemy_columns_from_model_fields ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> Tuple [ Optional [ str ], List [ sqlalchemy . Column ]] Iterates over declared on Model model fields and extracts fields that should be treated as database fields. If the model is empty it sets mandatory id field as primary key (used in through models in m2m relations). Triggers a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param. Also related_names have to be unique. Trigger validation of primary_key - only one and required pk can be set, cannot be pydantic_only. Append fields to columns if it's not pydantic_only, virtual ForeignKey or ManyToMany field. Sets owner on each model_field as reference to newly created Model. Raises : ModelDefinitionError : if validation of related_names fail, or pkname validation fails. Arguments : model_fields : dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] new_model : :type new_model: Model class Returns : pkname, list of sqlalchemy columns :rtype: Tuple[Optional[str], List[sqlalchemy.Column]]","title":"sqlalchemy_columns_from_model_fields"},{"location":"api/models/helpers/sqlalchemy/#_process_fields","text":"1 _process_fields ( model_fields : Dict , new_model : Type [ \"Model\" ]) -> Tuple [ Optional [ str ], List [ sqlalchemy . Column ]] Helper method. Populates pkname and columns. Trigger validation of primary_key - only one and required pk can be set, cannot be pydantic_only. Append fields to columns if it's not pydantic_only, virtual ForeignKey or ManyToMany field. Sets owner on each model_field as reference to newly created Model. Raises : ModelDefinitionError : if validation of related_names fail, or pkname validation fails. Arguments : model_fields : dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] new_model : :type new_model: Model class Returns : pkname, list of sqlalchemy columns :rtype: Tuple[Optional[str], List[sqlalchemy.Column]]","title":"_process_fields"},{"location":"api/models/helpers/sqlalchemy/#_is_through_model_not_set","text":"1 _is_through_model_not_set ( field : \"BaseField\" ) -> bool Alias to if check that verifies if through model was created. Arguments : field : field to check :type field: \"BaseField\" Returns : result of the check :rtype: bool","title":"_is_through_model_not_set"},{"location":"api/models/helpers/sqlalchemy/#_is_db_field","text":"1 _is_db_field ( field : \"BaseField\" ) -> bool Alias to if check that verifies if field should be included in database. Arguments : field : field to check :type field: \"BaseField\" Returns : result of the check :rtype: bool","title":"_is_db_field"},{"location":"api/models/helpers/sqlalchemy/#populate_meta_tablename_columns_and_pk","text":"1 populate_meta_tablename_columns_and_pk ( name : str , new_model : Type [ \"Model\" ]) -> Type [ \"Model\" ] Sets Model tablename if it's not already set in Meta. Default tablename if not present is class name lower + s (i.e. Bed becomes -> beds) Checks if Model's Meta have pkname and columns set. If not calls the sqlalchemy_columns_from_model_fields to populate columns from ormar.fields definitions. Raises : ModelDefinitionError : if pkname is not present raises ModelDefinitionError. Each model has to have pk. Arguments : name : name of the current Model :type name: str new_model : currently constructed Model :type new_model: ormar.models.metaclass.ModelMetaclass Returns : Model with populated pkname and columns in Meta :rtype: ormar.models.metaclass.ModelMetaclass","title":"populate_meta_tablename_columns_and_pk"},{"location":"api/models/helpers/sqlalchemy/#check_for_null_type_columns_from_forward_refs","text":"1 check_for_null_type_columns_from_forward_refs ( meta : \"ModelMeta\" ) -> bool Check is any column is of NUllType() meaning it's empty column from ForwardRef Arguments : meta : Meta class of the Model without sqlalchemy table constructed :type meta: Model class Meta Returns : result of the check :rtype: bool","title":"check_for_null_type_columns_from_forward_refs"},{"location":"api/models/helpers/sqlalchemy/#populate_meta_sqlalchemy_table_if_required","text":"1 populate_meta_sqlalchemy_table_if_required ( meta : \"ModelMeta\" ) -> None Constructs sqlalchemy table out of columns and parameters set on Meta class. It populates name, metadata, columns and constraints. Arguments : meta : Meta class of the Model without sqlalchemy table constructed :type meta: Model class Meta Returns : class with populated Meta.table :rtype: Model class","title":"populate_meta_sqlalchemy_table_if_required"},{"location":"api/models/helpers/sqlalchemy/#update_column_definition","text":"1 update_column_definition ( model : Union [ Type [ \"Model\" ], Type [ \"NewBaseModel\" ]], field : \"ForeignKeyField\" ) -> None Updates a column with a new type column based on updated parameters in FK fields. Arguments : model : model on which columns needs to be updated :type model: Type[\"Model\"] field : field with column definition that requires update :type field: ForeignKeyField Returns : None :rtype: None","title":"update_column_definition"},{"location":"api/models/helpers/validation/","text":"models.helpers.validation check_if_field_has_choices 1 check_if_field_has_choices ( field : BaseField ) -> bool Checks if given field has choices populated. A if it has one, a validator for this field needs to be attached. Arguments : field : ormar field to check :type field: BaseField Returns : result of the check :rtype: bool convert_choices_if_needed 1 convert_choices_if_needed ( field : \"BaseField\" , value : Any ) -> Tuple [ Any , List ] Converts dates to isoformat as fastapi can check this condition in routes and the fields are not yet parsed. Converts enums to list of it's values. Converts uuids to strings. Converts decimal to float with given scale. Arguments : field : ormar field to check with choices :type field: BaseField values : current values of the model to verify :type values: Dict Returns : value, choices list :rtype: Tuple[Any, List] validate_choices 1 validate_choices ( field : \"BaseField\" , value : Any ) -> None Validates if given value is in provided choices. Raises : ValueError : If value is not in choices. Arguments : field : field to validate :type field: BaseField value : value of the field :type value: Any choices_validator 1 choices_validator ( cls : Type [ \"Model\" ], values : Dict [ str , Any ]) -> Dict [ str , Any ] Validator that is attached to pydantic model pre root validators. Validator checks if field value is in field.choices list. Raises : ValueError : if field value is outside of allowed choices. Arguments : cls : constructed class :type cls: Model class values : dictionary of field values (pydantic side) :type values: Dict[str, Any] Returns : values if pass validation, otherwise exception is raised :rtype: Dict[str, Any] generate_model_example 1 generate_model_example ( model : Type [ \"Model\" ], relation_map : Dict = None ) -> Dict Generates example to be included in schema in fastapi. Arguments : model : ormar.Model :type model: Type[\"Model\"] relation_map : dict with relations to follow :type relation_map: Optional[Dict] Returns : dict with example values :rtype: Dict[str, int] populates_sample_fields_values 1 populates_sample_fields_values ( example : Dict [ str , Any ], name : str , field : BaseField , relation_map : Dict = None ) -> None Iterates the field and sets fields to sample values Arguments : field : ormar field :type field: BaseField name : name of the field :type name: str example : example dict :type example: Dict[str, Any] relation_map : dict with relations to follow :type relation_map: Optional[Dict] get_nested_model_example 1 get_nested_model_example ( name : str , field : \"BaseField\" , relation_map : Dict ) -> Union [ List , Dict ] Gets representation of nested model. Arguments : name : name of the field to follow :type name: str field : ormar field :type field: BaseField relation_map : dict with relation map :type relation_map: Dict Returns : nested model or list of nested model repr :rtype: Union[List, Dict] generate_pydantic_example 1 generate_pydantic_example ( pydantic_model : Type [ pydantic . BaseModel ], exclude : Set = None ) -> Dict Generates dict with example. Arguments : pydantic_model : model to parse :type pydantic_model: Type[pydantic.BaseModel] exclude : list of fields to exclude :type exclude: Optional[Set] Returns : dict with fields and sample values :rtype: Dict get_pydantic_example_repr 1 get_pydantic_example_repr ( type_ : Any ) -> Any Gets sample representation of pydantic field for example dict. Arguments : type_ : type of pydantic field :type type_: Any Returns : representation to include in example :rtype: Any overwrite_example_and_description 1 overwrite_example_and_description ( schema : Dict [ str , Any ], model : Type [ \"Model\" ]) -> None Overwrites the example with properly nested children models. Overwrites the description if it's taken from ormar.Model. Arguments : schema : schema of current model :type schema: Dict[str, Any] model : model class :type model: Type[\"Model\"] overwrite_binary_format 1 overwrite_binary_format ( schema : Dict [ str , Any ], model : Type [ \"Model\" ]) -> None Overwrites format of the field if it's a LargeBinary field with a flag to represent the field as base64 encoded string. Arguments : schema : schema of current model :type schema: Dict[str, Any] model : model class :type model: Type[\"Model\"] construct_modify_schema_function 1 construct_modify_schema_function ( fields_with_choices : List ) -> SchemaExtraCallable Modifies the schema to include fields with choices validator. Those fields will be displayed in schema as Enum types with available choices values listed next to them. Note that schema extra has to be a function, otherwise it's called to soon before all the relations are expanded. Arguments : fields_with_choices : list of fields with choices validation :type fields_with_choices: List Returns : callable that will be run by pydantic to modify the schema :rtype: Callable construct_schema_function_without_choices 1 construct_schema_function_without_choices () -> SchemaExtraCallable Modifies model example and description if needed. Note that schema extra has to be a function, otherwise it's called to soon before all the relations are expanded. Returns : callable that will be run by pydantic to modify the schema :rtype: Callable populate_choices_validators 1 populate_choices_validators ( model : Type [ \"Model\" ]) -> None Checks if Model has any fields with choices set. If yes it adds choices validation into pre root validators. Arguments : model : newly constructed Model :type model: Model class","title":"Validation"},{"location":"api/models/helpers/validation/#modelshelpersvalidation","text":"","title":"models.helpers.validation"},{"location":"api/models/helpers/validation/#check_if_field_has_choices","text":"1 check_if_field_has_choices ( field : BaseField ) -> bool Checks if given field has choices populated. A if it has one, a validator for this field needs to be attached. Arguments : field : ormar field to check :type field: BaseField Returns : result of the check :rtype: bool","title":"check_if_field_has_choices"},{"location":"api/models/helpers/validation/#convert_choices_if_needed","text":"1 convert_choices_if_needed ( field : \"BaseField\" , value : Any ) -> Tuple [ Any , List ] Converts dates to isoformat as fastapi can check this condition in routes and the fields are not yet parsed. Converts enums to list of it's values. Converts uuids to strings. Converts decimal to float with given scale. Arguments : field : ormar field to check with choices :type field: BaseField values : current values of the model to verify :type values: Dict Returns : value, choices list :rtype: Tuple[Any, List]","title":"convert_choices_if_needed"},{"location":"api/models/helpers/validation/#validate_choices","text":"1 validate_choices ( field : \"BaseField\" , value : Any ) -> None Validates if given value is in provided choices. Raises : ValueError : If value is not in choices. Arguments : field : field to validate :type field: BaseField value : value of the field :type value: Any","title":"validate_choices"},{"location":"api/models/helpers/validation/#choices_validator","text":"1 choices_validator ( cls : Type [ \"Model\" ], values : Dict [ str , Any ]) -> Dict [ str , Any ] Validator that is attached to pydantic model pre root validators. Validator checks if field value is in field.choices list. Raises : ValueError : if field value is outside of allowed choices. Arguments : cls : constructed class :type cls: Model class values : dictionary of field values (pydantic side) :type values: Dict[str, Any] Returns : values if pass validation, otherwise exception is raised :rtype: Dict[str, Any]","title":"choices_validator"},{"location":"api/models/helpers/validation/#generate_model_example","text":"1 generate_model_example ( model : Type [ \"Model\" ], relation_map : Dict = None ) -> Dict Generates example to be included in schema in fastapi. Arguments : model : ormar.Model :type model: Type[\"Model\"] relation_map : dict with relations to follow :type relation_map: Optional[Dict] Returns : dict with example values :rtype: Dict[str, int]","title":"generate_model_example"},{"location":"api/models/helpers/validation/#populates_sample_fields_values","text":"1 populates_sample_fields_values ( example : Dict [ str , Any ], name : str , field : BaseField , relation_map : Dict = None ) -> None Iterates the field and sets fields to sample values Arguments : field : ormar field :type field: BaseField name : name of the field :type name: str example : example dict :type example: Dict[str, Any] relation_map : dict with relations to follow :type relation_map: Optional[Dict]","title":"populates_sample_fields_values"},{"location":"api/models/helpers/validation/#get_nested_model_example","text":"1 get_nested_model_example ( name : str , field : \"BaseField\" , relation_map : Dict ) -> Union [ List , Dict ] Gets representation of nested model. Arguments : name : name of the field to follow :type name: str field : ormar field :type field: BaseField relation_map : dict with relation map :type relation_map: Dict Returns : nested model or list of nested model repr :rtype: Union[List, Dict]","title":"get_nested_model_example"},{"location":"api/models/helpers/validation/#generate_pydantic_example","text":"1 generate_pydantic_example ( pydantic_model : Type [ pydantic . BaseModel ], exclude : Set = None ) -> Dict Generates dict with example. Arguments : pydantic_model : model to parse :type pydantic_model: Type[pydantic.BaseModel] exclude : list of fields to exclude :type exclude: Optional[Set] Returns : dict with fields and sample values :rtype: Dict","title":"generate_pydantic_example"},{"location":"api/models/helpers/validation/#get_pydantic_example_repr","text":"1 get_pydantic_example_repr ( type_ : Any ) -> Any Gets sample representation of pydantic field for example dict. Arguments : type_ : type of pydantic field :type type_: Any Returns : representation to include in example :rtype: Any","title":"get_pydantic_example_repr"},{"location":"api/models/helpers/validation/#overwrite_example_and_description","text":"1 overwrite_example_and_description ( schema : Dict [ str , Any ], model : Type [ \"Model\" ]) -> None Overwrites the example with properly nested children models. Overwrites the description if it's taken from ormar.Model. Arguments : schema : schema of current model :type schema: Dict[str, Any] model : model class :type model: Type[\"Model\"]","title":"overwrite_example_and_description"},{"location":"api/models/helpers/validation/#overwrite_binary_format","text":"1 overwrite_binary_format ( schema : Dict [ str , Any ], model : Type [ \"Model\" ]) -> None Overwrites format of the field if it's a LargeBinary field with a flag to represent the field as base64 encoded string. Arguments : schema : schema of current model :type schema: Dict[str, Any] model : model class :type model: Type[\"Model\"]","title":"overwrite_binary_format"},{"location":"api/models/helpers/validation/#construct_modify_schema_function","text":"1 construct_modify_schema_function ( fields_with_choices : List ) -> SchemaExtraCallable Modifies the schema to include fields with choices validator. Those fields will be displayed in schema as Enum types with available choices values listed next to them. Note that schema extra has to be a function, otherwise it's called to soon before all the relations are expanded. Arguments : fields_with_choices : list of fields with choices validation :type fields_with_choices: List Returns : callable that will be run by pydantic to modify the schema :rtype: Callable","title":"construct_modify_schema_function"},{"location":"api/models/helpers/validation/#construct_schema_function_without_choices","text":"1 construct_schema_function_without_choices () -> SchemaExtraCallable Modifies model example and description if needed. Note that schema extra has to be a function, otherwise it's called to soon before all the relations are expanded. Returns : callable that will be run by pydantic to modify the schema :rtype: Callable","title":"construct_schema_function_without_choices"},{"location":"api/models/helpers/validation/#populate_choices_validators","text":"1 populate_choices_validators ( model : Type [ \"Model\" ]) -> None Checks if Model has any fields with choices set. If yes it adds choices validation into pre root validators. Arguments : model : newly constructed Model :type model: Model class","title":"populate_choices_validators"},{"location":"api/models/mixins/alias-mixin/","text":"models.mixins.alias_mixin AliasMixin Objects 1 class AliasMixin () Used to translate field names into database column names. get_column_alias 1 2 | @classmethod | get_column_alias ( cls , field_name : str ) -> str Returns db alias (column name in db) for given ormar field. For fields without alias field name is returned. Arguments : field_name : name of the field to get alias from :type field_name: str Returns : alias (db name) if set, otherwise passed name :rtype: str get_column_name_from_alias 1 2 | @classmethod | get_column_name_from_alias ( cls , alias : str ) -> str Returns ormar field name for given db alias (column name in db). If field do not have alias it's returned as is. Arguments : alias : :type alias: str Returns : field name if set, otherwise passed alias (db name) :rtype: str translate_columns_to_aliases 1 2 | @classmethod | translate_columns_to_aliases ( cls , new_kwargs : Dict ) -> Dict Translates dictionary of model fields changing field names into aliases. If field has no alias the field name remains intact. Only fields present in the dictionary are translated. Arguments : new_kwargs : dict with fields names and their values :type new_kwargs: Dict Returns : dict with aliases and their values :rtype: Dict translate_aliases_to_columns 1 2 | @classmethod | translate_aliases_to_columns ( cls , new_kwargs : Dict ) -> Dict Translates dictionary of model fields changing aliases into field names. If field has no alias the alias is already a field name. Only fields present in the dictionary are translated. Arguments : new_kwargs : dict with aliases and their values :type new_kwargs: Dict Returns : dict with fields names and their values :rtype: Dict","title":"Alias Mixin"},{"location":"api/models/mixins/alias-mixin/#modelsmixinsalias_mixin","text":"","title":"models.mixins.alias_mixin"},{"location":"api/models/mixins/alias-mixin/#aliasmixin-objects","text":"1 class AliasMixin () Used to translate field names into database column names.","title":"AliasMixin Objects"},{"location":"api/models/mixins/alias-mixin/#get_column_alias","text":"1 2 | @classmethod | get_column_alias ( cls , field_name : str ) -> str Returns db alias (column name in db) for given ormar field. For fields without alias field name is returned. Arguments : field_name : name of the field to get alias from :type field_name: str Returns : alias (db name) if set, otherwise passed name :rtype: str","title":"get_column_alias"},{"location":"api/models/mixins/alias-mixin/#get_column_name_from_alias","text":"1 2 | @classmethod | get_column_name_from_alias ( cls , alias : str ) -> str Returns ormar field name for given db alias (column name in db). If field do not have alias it's returned as is. Arguments : alias : :type alias: str Returns : field name if set, otherwise passed alias (db name) :rtype: str","title":"get_column_name_from_alias"},{"location":"api/models/mixins/alias-mixin/#translate_columns_to_aliases","text":"1 2 | @classmethod | translate_columns_to_aliases ( cls , new_kwargs : Dict ) -> Dict Translates dictionary of model fields changing field names into aliases. If field has no alias the field name remains intact. Only fields present in the dictionary are translated. Arguments : new_kwargs : dict with fields names and their values :type new_kwargs: Dict Returns : dict with aliases and their values :rtype: Dict","title":"translate_columns_to_aliases"},{"location":"api/models/mixins/alias-mixin/#translate_aliases_to_columns","text":"1 2 | @classmethod | translate_aliases_to_columns ( cls , new_kwargs : Dict ) -> Dict Translates dictionary of model fields changing aliases into field names. If field has no alias the alias is already a field name. Only fields present in the dictionary are translated. Arguments : new_kwargs : dict with aliases and their values :type new_kwargs: Dict Returns : dict with fields names and their values :rtype: Dict","title":"translate_aliases_to_columns"},{"location":"api/models/mixins/excludable-mixin/","text":"models.mixins.excludable_mixin ExcludableMixin Objects 1 class ExcludableMixin ( RelationMixin ) Used to include/exclude given set of fields on models during load and dict() calls. get_child 1 2 | @staticmethod | get_child ( items : Union [ Set , Dict , None ], key : str = None ) -> Union [ Set , Dict , None ] Used to get nested dictionaries keys if they exists otherwise returns passed items. Arguments : items : bag of items to include or exclude :type items: Union[Set, Dict, None] key : name of the child to extract :type key: str Returns : child extracted from items if exists :rtype: Union[Set, Dict, None] _populate_pk_column 1 2 | @staticmethod | _populate_pk_column ( model : Union [ Type [ \"Model\" ], Type [ \"ModelRow\" ]], columns : List [ str ], use_alias : bool = False ) -> List [ str ] Adds primary key column/alias (depends on use_alias flag) to list of column names that are selected. Arguments : model : model on columns are selected :type model: Type[\"Model\"] columns : list of columns names :type columns: List[str] use_alias : flag to set if aliases or field names should be used :type use_alias: bool Returns : list of columns names with pk column in it :rtype: List[str] own_table_columns 1 2 | @classmethod | own_table_columns ( cls , model : Union [ Type [ \"Model\" ], Type [ \"ModelRow\" ]], excludable : ExcludableItems , alias : str = \"\" , use_alias : bool = False , add_pk_columns : bool = True ) -> List [ str ] Returns list of aliases or field names for given model. Aliases/names switch is use_alias flag. If provided only fields included in fields will be returned. If provided fields in exclude_fields will be excluded in return. Primary key field is always added and cannot be excluded (will be added anyway). Arguments : add_pk_columns : flag if add primary key - always yes if ormar parses data :type add_pk_columns: bool alias : relation prefix :type alias: str excludable : structure of fields to include and exclude :type excludable: ExcludableItems model : model on columns are selected :type model: Type[\"Model\"] use_alias : flag if aliases or field names should be used :type use_alias: bool Returns : list of column field names or aliases :rtype: List[str] _update_excluded_with_related 1 2 | @classmethod | _update_excluded_with_related ( cls , exclude : Union [ Set , Dict , None ]) -> Set Used during generation of the dict(). To avoid cyclical references and max recurrence limit nested models have to exclude related models that are not mandatory. For a main model (not nested) only nullable related field names are added to exclusion, for nested models all related models are excluded. Arguments : exclude : set/dict with fields to exclude :type exclude: Union[Set, Dict, None] Returns : set or dict with excluded fields added. :rtype: Union[Set, Dict] _update_excluded_with_pks_and_through 1 2 | @classmethod | _update_excluded_with_pks_and_through ( cls , exclude : Set , exclude_primary_keys : bool , exclude_through_models : bool ) -> Set Updates excluded names with name of pk column if exclude flag is set. Arguments : exclude : set of names to exclude :type exclude: Set exclude_primary_keys : flag if the primary keys should be excluded :type exclude_primary_keys: bool Returns : set updated with pk if flag is set :rtype: Set get_names_to_exclude 1 2 | @classmethod | get_names_to_exclude ( cls , excludable : ExcludableItems , alias : str ) -> Set Returns a set of models field names that should be explicitly excluded during model initialization. Those fields will be set to None to avoid ormar/pydantic setting default values on them. They should be returned as None in any case. Used in parsing data from database rows that construct Models by initializing them with dicts constructed from those db rows. Arguments : alias : alias of current relation :type alias: str excludable : structure of fields to include and exclude :type excludable: ExcludableItems Returns : set of field names that should be excluded :rtype: Set","title":"Excludable Mixin"},{"location":"api/models/mixins/excludable-mixin/#modelsmixinsexcludable_mixin","text":"","title":"models.mixins.excludable_mixin"},{"location":"api/models/mixins/excludable-mixin/#excludablemixin-objects","text":"1 class ExcludableMixin ( RelationMixin ) Used to include/exclude given set of fields on models during load and dict() calls.","title":"ExcludableMixin Objects"},{"location":"api/models/mixins/excludable-mixin/#get_child","text":"1 2 | @staticmethod | get_child ( items : Union [ Set , Dict , None ], key : str = None ) -> Union [ Set , Dict , None ] Used to get nested dictionaries keys if they exists otherwise returns passed items. Arguments : items : bag of items to include or exclude :type items: Union[Set, Dict, None] key : name of the child to extract :type key: str Returns : child extracted from items if exists :rtype: Union[Set, Dict, None]","title":"get_child"},{"location":"api/models/mixins/excludable-mixin/#_populate_pk_column","text":"1 2 | @staticmethod | _populate_pk_column ( model : Union [ Type [ \"Model\" ], Type [ \"ModelRow\" ]], columns : List [ str ], use_alias : bool = False ) -> List [ str ] Adds primary key column/alias (depends on use_alias flag) to list of column names that are selected. Arguments : model : model on columns are selected :type model: Type[\"Model\"] columns : list of columns names :type columns: List[str] use_alias : flag to set if aliases or field names should be used :type use_alias: bool Returns : list of columns names with pk column in it :rtype: List[str]","title":"_populate_pk_column"},{"location":"api/models/mixins/excludable-mixin/#own_table_columns","text":"1 2 | @classmethod | own_table_columns ( cls , model : Union [ Type [ \"Model\" ], Type [ \"ModelRow\" ]], excludable : ExcludableItems , alias : str = \"\" , use_alias : bool = False , add_pk_columns : bool = True ) -> List [ str ] Returns list of aliases or field names for given model. Aliases/names switch is use_alias flag. If provided only fields included in fields will be returned. If provided fields in exclude_fields will be excluded in return. Primary key field is always added and cannot be excluded (will be added anyway). Arguments : add_pk_columns : flag if add primary key - always yes if ormar parses data :type add_pk_columns: bool alias : relation prefix :type alias: str excludable : structure of fields to include and exclude :type excludable: ExcludableItems model : model on columns are selected :type model: Type[\"Model\"] use_alias : flag if aliases or field names should be used :type use_alias: bool Returns : list of column field names or aliases :rtype: List[str]","title":"own_table_columns"},{"location":"api/models/mixins/excludable-mixin/#_update_excluded_with_related","text":"1 2 | @classmethod | _update_excluded_with_related ( cls , exclude : Union [ Set , Dict , None ]) -> Set Used during generation of the dict(). To avoid cyclical references and max recurrence limit nested models have to exclude related models that are not mandatory. For a main model (not nested) only nullable related field names are added to exclusion, for nested models all related models are excluded. Arguments : exclude : set/dict with fields to exclude :type exclude: Union[Set, Dict, None] Returns : set or dict with excluded fields added. :rtype: Union[Set, Dict]","title":"_update_excluded_with_related"},{"location":"api/models/mixins/excludable-mixin/#_update_excluded_with_pks_and_through","text":"1 2 | @classmethod | _update_excluded_with_pks_and_through ( cls , exclude : Set , exclude_primary_keys : bool , exclude_through_models : bool ) -> Set Updates excluded names with name of pk column if exclude flag is set. Arguments : exclude : set of names to exclude :type exclude: Set exclude_primary_keys : flag if the primary keys should be excluded :type exclude_primary_keys: bool Returns : set updated with pk if flag is set :rtype: Set","title":"_update_excluded_with_pks_and_through"},{"location":"api/models/mixins/excludable-mixin/#get_names_to_exclude","text":"1 2 | @classmethod | get_names_to_exclude ( cls , excludable : ExcludableItems , alias : str ) -> Set Returns a set of models field names that should be explicitly excluded during model initialization. Those fields will be set to None to avoid ormar/pydantic setting default values on them. They should be returned as None in any case. Used in parsing data from database rows that construct Models by initializing them with dicts constructed from those db rows. Arguments : alias : alias of current relation :type alias: str excludable : structure of fields to include and exclude :type excludable: ExcludableItems Returns : set of field names that should be excluded :rtype: Set","title":"get_names_to_exclude"},{"location":"api/models/mixins/merge-model-mixin/","text":"models.mixins.merge_mixin MergeModelMixin Objects 1 class MergeModelMixin () Used to merge models instances returned by database, but already initialized to ormar Models.keys Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique. merge_instances_list 1 2 | @classmethod | merge_instances_list ( cls , result_rows : List [ \"Model\" ]) -> List [ \"Model\" ] Merges a list of models into list of unique models. Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique. Arguments : result_rows : list of already initialized Models with child models populated, each instance is one row in db and some models can duplicate :type result_rows: List[\"Model\"] Returns : list of merged models where each main model is unique :rtype: List[\"Model\"] merge_two_instances 1 2 | @classmethod | merge_two_instances ( cls , one : \"Model\" , other : \"Model\" , relation_map : Dict = None ) -> \"Model\" Merges current (other) Model and previous one (one) and returns the current Model instance with data merged from previous one. If needed it's calling itself recurrently and merges also children models. Arguments : relation_map : map of models relations to follow :type relation_map: Dict one : previous model instance :type one: Model other : current model instance :type other: Model Returns : current Model instance with data merged from previous one. :rtype: Model _merge_items_lists 1 2 | @classmethod | _merge_items_lists ( cls , field_name : str , current_field : List , other_value : List , relation_map : Optional [ Dict ]) -> List Takes two list of nested models and process them going deeper according with the map. If model from one's list is in other -> they are merged with relations to follow passed from map. If one's model is not in other it's simply appended to the list. Arguments : field_name : name of the current relation field :type field_name: str current_field : list of nested models from one model :type current_field: List[Model] other_value : list of nested models from other model :type other_value: List[Model] relation_map : map of relations to follow :type relation_map: Dict Returns : merged list of models :rtype: List[Model]","title":"Merge Model Mixin"},{"location":"api/models/mixins/merge-model-mixin/#modelsmixinsmerge_mixin","text":"","title":"models.mixins.merge_mixin"},{"location":"api/models/mixins/merge-model-mixin/#mergemodelmixin-objects","text":"1 class MergeModelMixin () Used to merge models instances returned by database, but already initialized to ormar Models.keys Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique.","title":"MergeModelMixin Objects"},{"location":"api/models/mixins/merge-model-mixin/#merge_instances_list","text":"1 2 | @classmethod | merge_instances_list ( cls , result_rows : List [ \"Model\" ]) -> List [ \"Model\" ] Merges a list of models into list of unique models. Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique. Arguments : result_rows : list of already initialized Models with child models populated, each instance is one row in db and some models can duplicate :type result_rows: List[\"Model\"] Returns : list of merged models where each main model is unique :rtype: List[\"Model\"]","title":"merge_instances_list"},{"location":"api/models/mixins/merge-model-mixin/#merge_two_instances","text":"1 2 | @classmethod | merge_two_instances ( cls , one : \"Model\" , other : \"Model\" , relation_map : Dict = None ) -> \"Model\" Merges current (other) Model and previous one (one) and returns the current Model instance with data merged from previous one. If needed it's calling itself recurrently and merges also children models. Arguments : relation_map : map of models relations to follow :type relation_map: Dict one : previous model instance :type one: Model other : current model instance :type other: Model Returns : current Model instance with data merged from previous one. :rtype: Model","title":"merge_two_instances"},{"location":"api/models/mixins/merge-model-mixin/#_merge_items_lists","text":"1 2 | @classmethod | _merge_items_lists ( cls , field_name : str , current_field : List , other_value : List , relation_map : Optional [ Dict ]) -> List Takes two list of nested models and process them going deeper according with the map. If model from one's list is in other -> they are merged with relations to follow passed from map. If one's model is not in other it's simply appended to the list. Arguments : field_name : name of the current relation field :type field_name: str current_field : list of nested models from one model :type current_field: List[Model] other_value : list of nested models from other model :type other_value: List[Model] relation_map : map of relations to follow :type relation_map: Dict Returns : merged list of models :rtype: List[Model]","title":"_merge_items_lists"},{"location":"api/models/mixins/prefetch-query-mixin/","text":"models.mixins.prefetch_mixin PrefetchQueryMixin Objects 1 class PrefetchQueryMixin ( RelationMixin ) Used in PrefetchQuery to extract ids and names of models to prefetch. get_clause_target_and_filter_column_name 1 2 | @staticmethod | get_clause_target_and_filter_column_name ( parent_model : Type [ \"Model\" ], target_model : Type [ \"Model\" ], reverse : bool , related : str ) -> Tuple [ Type [ \"Model\" ], str ] Returns Model on which query clause should be performed and name of the column. Arguments : parent_model : related model that the relation lead to :type parent_model: Type[Model] target_model : model on which query should be perfomed :type target_model: Type[Model] reverse : flag if the relation is reverse :type reverse: bool related : name of the relation field :type related: str Returns : Model on which query clause should be performed and name of the column :rtype: Tuple[Type[Model], str] get_column_name_for_id_extraction 1 2 | @staticmethod | get_column_name_for_id_extraction ( parent_model : Type [ \"Model\" ], reverse : bool , related : str , use_raw : bool ) -> str Returns name of the column that should be used to extract ids from model. Depending on the relation side it's either primary key column of parent model or field name specified by related parameter. Arguments : parent_model : model from which id column should be extracted :type parent_model: Type[Model] reverse : flag if the relation is reverse :type reverse: bool related : name of the relation field :type related: str use_raw : flag if aliases or field names should be used :type use_raw: bool Returns : :rtype: get_related_field_name 1 2 | @classmethod | get_related_field_name ( cls , target_field : \"ForeignKeyField\" ) -> str Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query. Arguments : target_field : relation field that should be used in prefetch :type target_field: Type[BaseField] Returns : name of the field :rtype: str get_filtered_names_to_extract 1 2 | @classmethod | get_filtered_names_to_extract ( cls , prefetch_dict : Dict ) -> List Returns list of related fields names that should be followed to prefetch related models from. List of models is translated into dict to assure each model is extracted only once in one query, that's why this function accepts prefetch_dict not list. Only relations from current model are returned. Arguments : prefetch_dict : dictionary of fields to extract :type prefetch_dict: Dict Returns : list of fields names to extract :rtype: List","title":"Prefetch Query Mixin"},{"location":"api/models/mixins/prefetch-query-mixin/#modelsmixinsprefetch_mixin","text":"","title":"models.mixins.prefetch_mixin"},{"location":"api/models/mixins/prefetch-query-mixin/#prefetchquerymixin-objects","text":"1 class PrefetchQueryMixin ( RelationMixin ) Used in PrefetchQuery to extract ids and names of models to prefetch.","title":"PrefetchQueryMixin Objects"},{"location":"api/models/mixins/prefetch-query-mixin/#get_clause_target_and_filter_column_name","text":"1 2 | @staticmethod | get_clause_target_and_filter_column_name ( parent_model : Type [ \"Model\" ], target_model : Type [ \"Model\" ], reverse : bool , related : str ) -> Tuple [ Type [ \"Model\" ], str ] Returns Model on which query clause should be performed and name of the column. Arguments : parent_model : related model that the relation lead to :type parent_model: Type[Model] target_model : model on which query should be perfomed :type target_model: Type[Model] reverse : flag if the relation is reverse :type reverse: bool related : name of the relation field :type related: str Returns : Model on which query clause should be performed and name of the column :rtype: Tuple[Type[Model], str]","title":"get_clause_target_and_filter_column_name"},{"location":"api/models/mixins/prefetch-query-mixin/#get_column_name_for_id_extraction","text":"1 2 | @staticmethod | get_column_name_for_id_extraction ( parent_model : Type [ \"Model\" ], reverse : bool , related : str , use_raw : bool ) -> str Returns name of the column that should be used to extract ids from model. Depending on the relation side it's either primary key column of parent model or field name specified by related parameter. Arguments : parent_model : model from which id column should be extracted :type parent_model: Type[Model] reverse : flag if the relation is reverse :type reverse: bool related : name of the relation field :type related: str use_raw : flag if aliases or field names should be used :type use_raw: bool Returns : :rtype:","title":"get_column_name_for_id_extraction"},{"location":"api/models/mixins/prefetch-query-mixin/#get_related_field_name","text":"1 2 | @classmethod | get_related_field_name ( cls , target_field : \"ForeignKeyField\" ) -> str Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query. Arguments : target_field : relation field that should be used in prefetch :type target_field: Type[BaseField] Returns : name of the field :rtype: str","title":"get_related_field_name"},{"location":"api/models/mixins/prefetch-query-mixin/#get_filtered_names_to_extract","text":"1 2 | @classmethod | get_filtered_names_to_extract ( cls , prefetch_dict : Dict ) -> List Returns list of related fields names that should be followed to prefetch related models from. List of models is translated into dict to assure each model is extracted only once in one query, that's why this function accepts prefetch_dict not list. Only relations from current model are returned. Arguments : prefetch_dict : dictionary of fields to extract :type prefetch_dict: Dict Returns : list of fields names to extract :rtype: List","title":"get_filtered_names_to_extract"},{"location":"api/models/mixins/relation-mixin/","text":"models.mixins.relation_mixin RelationMixin Objects 1 class RelationMixin () Used to return relation fields/names etc. from given model extract_db_own_fields 1 2 | @classmethod | extract_db_own_fields ( cls ) -> Set Returns only fields that are stored in the own database table, exclude all related fields. Returns : set of model fields with relation fields excluded :rtype: Set extract_related_fields 1 2 | @classmethod | extract_related_fields ( cls ) -> List [ \"ForeignKeyField\" ] Returns List of ormar Fields for all relations declared on a model. List is cached in cls._related_fields for quicker access. Returns : list of related fields :rtype: List extract_through_names 1 2 | @classmethod | extract_through_names ( cls ) -> Set [ str ] Extracts related fields through names which are shortcuts to through models. Returns : set of related through fields names :rtype: Set extract_related_names 1 2 | @classmethod | extract_related_names ( cls ) -> Set [ str ] Returns List of fields names for all relations declared on a model. List is cached in cls._related_names for quicker access. Returns : set of related fields names :rtype: Set _extract_db_related_names 1 2 | @classmethod | _extract_db_related_names ( cls ) -> Set Returns only fields that are stored in the own database table, exclude related fields that are not stored as foreign keys on given model. Returns : set of model fields with non fk relation fields excluded :rtype: Set _iterate_related_models 1 2 | @classmethod | _iterate_related_models ( cls , node_list : NodeList = None , source_relation : str = None ) -> List [ str ] Iterates related models recursively to extract relation strings of nested not visited models. Returns : list of relation strings to be passed to select_related :rtype: List[str] _get_final_relations 1 2 | @staticmethod | _get_final_relations ( processed_relations : List , source_relation : Optional [ str ]) -> List [ str ] Helper method to prefix nested relation strings with current source relation Arguments : processed_relations : list of already processed relation str :type processed_relations: List[str] source_relation : name of the current relation :type source_relation: str Returns : list of relation strings to be passed to select_related :rtype: List[str]","title":"Relation Mixin"},{"location":"api/models/mixins/relation-mixin/#modelsmixinsrelation_mixin","text":"","title":"models.mixins.relation_mixin"},{"location":"api/models/mixins/relation-mixin/#relationmixin-objects","text":"1 class RelationMixin () Used to return relation fields/names etc. from given model","title":"RelationMixin Objects"},{"location":"api/models/mixins/relation-mixin/#extract_db_own_fields","text":"1 2 | @classmethod | extract_db_own_fields ( cls ) -> Set Returns only fields that are stored in the own database table, exclude all related fields. Returns : set of model fields with relation fields excluded :rtype: Set","title":"extract_db_own_fields"},{"location":"api/models/mixins/relation-mixin/#extract_related_fields","text":"1 2 | @classmethod | extract_related_fields ( cls ) -> List [ \"ForeignKeyField\" ] Returns List of ormar Fields for all relations declared on a model. List is cached in cls._related_fields for quicker access. Returns : list of related fields :rtype: List","title":"extract_related_fields"},{"location":"api/models/mixins/relation-mixin/#extract_through_names","text":"1 2 | @classmethod | extract_through_names ( cls ) -> Set [ str ] Extracts related fields through names which are shortcuts to through models. Returns : set of related through fields names :rtype: Set","title":"extract_through_names"},{"location":"api/models/mixins/relation-mixin/#extract_related_names","text":"1 2 | @classmethod | extract_related_names ( cls ) -> Set [ str ] Returns List of fields names for all relations declared on a model. List is cached in cls._related_names for quicker access. Returns : set of related fields names :rtype: Set","title":"extract_related_names"},{"location":"api/models/mixins/relation-mixin/#_extract_db_related_names","text":"1 2 | @classmethod | _extract_db_related_names ( cls ) -> Set Returns only fields that are stored in the own database table, exclude related fields that are not stored as foreign keys on given model. Returns : set of model fields with non fk relation fields excluded :rtype: Set","title":"_extract_db_related_names"},{"location":"api/models/mixins/relation-mixin/#_iterate_related_models","text":"1 2 | @classmethod | _iterate_related_models ( cls , node_list : NodeList = None , source_relation : str = None ) -> List [ str ] Iterates related models recursively to extract relation strings of nested not visited models. Returns : list of relation strings to be passed to select_related :rtype: List[str]","title":"_iterate_related_models"},{"location":"api/models/mixins/relation-mixin/#_get_final_relations","text":"1 2 | @staticmethod | _get_final_relations ( processed_relations : List , source_relation : Optional [ str ]) -> List [ str ] Helper method to prefix nested relation strings with current source relation Arguments : processed_relations : list of already processed relation str :type processed_relations: List[str] source_relation : name of the current relation :type source_relation: str Returns : list of relation strings to be passed to select_related :rtype: List[str]","title":"_get_final_relations"},{"location":"api/models/mixins/save-prepare-mixin/","text":"models.mixins.save_mixin SavePrepareMixin Objects 1 class SavePrepareMixin ( RelationMixin , AliasMixin ) Used to prepare models to be saved in database prepare_model_to_save 1 2 | @classmethod | prepare_model_to_save ( cls , new_kwargs : dict ) -> dict Combines all preparation methods before saving. Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Substitute related models with their primary key values as fk column. Populates the default values for field with default set and no value. Translate columns into aliases (db names). Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] Returns : dictionary of model that is about to be saved :rtype: Dict[str, str] _remove_not_ormar_fields 1 2 | @classmethod | _remove_not_ormar_fields ( cls , new_kwargs : dict ) -> dict Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] Returns : dictionary of model that is about to be saved :rtype: Dict[str, str] _remove_pk_from_kwargs 1 2 | @classmethod | _remove_pk_from_kwargs ( cls , new_kwargs : dict ) -> dict Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] Returns : dictionary of model that is about to be saved :rtype: Dict[str, str] parse_non_db_fields 1 2 | @classmethod | parse_non_db_fields ( cls , model_dict : Dict ) -> Dict Receives dictionary of model that is about to be saved and changes uuid fields to strings in bulk_update. Arguments : model_dict : dictionary of model that is about to be saved :type model_dict: Dict Returns : dictionary of model that is about to be saved :rtype: Dict substitute_models_with_pks 1 2 | @classmethod | substitute_models_with_pks ( cls , model_dict : Dict ) -> Dict Receives dictionary of model that is about to be saved and changes all related models that are stored as foreign keys to their fk value. Arguments : model_dict : dictionary of model that is about to be saved :type model_dict: Dict Returns : dictionary of model that is about to be saved :rtype: Dict populate_default_values 1 2 | @classmethod | populate_default_values ( cls , new_kwargs : Dict ) -> Dict Receives dictionary of model that is about to be saved and populates the default value on the fields that have the default value set, but no actual value was passed by the user. Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict Returns : dictionary of model that is about to be saved :rtype: Dict validate_choices 1 2 | @classmethod | validate_choices ( cls , new_kwargs : Dict ) -> Dict Receives dictionary of model that is about to be saved and validates the fields with choices set to see if the value is allowed. Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict Returns : dictionary of model that is about to be saved :rtype: Dict _upsert_model 1 2 | @staticmethod | async _upsert_model ( instance : \"Model\" , save_all : bool , previous_model : Optional [ \"Model\" ], relation_field : Optional [ \"ForeignKeyField\" ], update_count : int ) -> int Method updates given instance if: instance is not saved or instance have no pk or save_all=True flag is set and instance is not pk_only . If relation leading to instance is a ManyToMany also the through model is saved Arguments : instance : current model to upsert :type instance: Model save_all : flag if all models should be saved or only not saved ones :type save_all: bool relation_field : field with relation :type relation_field: Optional[ForeignKeyField] previous_model : previous model from which method came :type previous_model: Model update_count : no of updated models :type update_count: int Returns : no of updated models :rtype: int _upsert_through_model 1 2 | @staticmethod | async _upsert_through_model ( instance : \"Model\" , previous_model : \"Model\" , relation_field : \"ForeignKeyField\" ) -> None Upsert through model for m2m relation. Arguments : instance : current model to upsert :type instance: Model relation_field : field with relation :type relation_field: Optional[ForeignKeyField] previous_model : previous model from which method came :type previous_model: Model _update_relation_list 1 | async _update_relation_list ( fields_list : Collection [ \"ForeignKeyField\" ], follow : bool , save_all : bool , relation_map : Dict , update_count : int ) -> int Internal method used in save_related to follow deeper from related models and update numbers of updated related instances. :type save_all: flag if all models should be saved :type save_all: bool Arguments : fields_list : list of ormar fields to follow and save :type fields_list: Collection[\"ForeignKeyField\"] relation_map : map of relations to follow :type relation_map: Dict follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool update_count : internal parameter for recursive calls - number of updated instances :type update_count: int Returns : tuple of update count and visited :rtype: int _get_field_values 1 | _get_field_values ( name : str ) -> List Extract field values and ensures it is a list. Arguments : name : name of the field :type name: str Returns : list of values :rtype: List","title":"Save Prepare Mixin"},{"location":"api/models/mixins/save-prepare-mixin/#modelsmixinssave_mixin","text":"","title":"models.mixins.save_mixin"},{"location":"api/models/mixins/save-prepare-mixin/#savepreparemixin-objects","text":"1 class SavePrepareMixin ( RelationMixin , AliasMixin ) Used to prepare models to be saved in database","title":"SavePrepareMixin Objects"},{"location":"api/models/mixins/save-prepare-mixin/#prepare_model_to_save","text":"1 2 | @classmethod | prepare_model_to_save ( cls , new_kwargs : dict ) -> dict Combines all preparation methods before saving. Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Substitute related models with their primary key values as fk column. Populates the default values for field with default set and no value. Translate columns into aliases (db names). Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] Returns : dictionary of model that is about to be saved :rtype: Dict[str, str]","title":"prepare_model_to_save"},{"location":"api/models/mixins/save-prepare-mixin/#_remove_not_ormar_fields","text":"1 2 | @classmethod | _remove_not_ormar_fields ( cls , new_kwargs : dict ) -> dict Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] Returns : dictionary of model that is about to be saved :rtype: Dict[str, str]","title":"_remove_not_ormar_fields"},{"location":"api/models/mixins/save-prepare-mixin/#_remove_pk_from_kwargs","text":"1 2 | @classmethod | _remove_pk_from_kwargs ( cls , new_kwargs : dict ) -> dict Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] Returns : dictionary of model that is about to be saved :rtype: Dict[str, str]","title":"_remove_pk_from_kwargs"},{"location":"api/models/mixins/save-prepare-mixin/#parse_non_db_fields","text":"1 2 | @classmethod | parse_non_db_fields ( cls , model_dict : Dict ) -> Dict Receives dictionary of model that is about to be saved and changes uuid fields to strings in bulk_update. Arguments : model_dict : dictionary of model that is about to be saved :type model_dict: Dict Returns : dictionary of model that is about to be saved :rtype: Dict","title":"parse_non_db_fields"},{"location":"api/models/mixins/save-prepare-mixin/#substitute_models_with_pks","text":"1 2 | @classmethod | substitute_models_with_pks ( cls , model_dict : Dict ) -> Dict Receives dictionary of model that is about to be saved and changes all related models that are stored as foreign keys to their fk value. Arguments : model_dict : dictionary of model that is about to be saved :type model_dict: Dict Returns : dictionary of model that is about to be saved :rtype: Dict","title":"substitute_models_with_pks"},{"location":"api/models/mixins/save-prepare-mixin/#populate_default_values","text":"1 2 | @classmethod | populate_default_values ( cls , new_kwargs : Dict ) -> Dict Receives dictionary of model that is about to be saved and populates the default value on the fields that have the default value set, but no actual value was passed by the user. Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict Returns : dictionary of model that is about to be saved :rtype: Dict","title":"populate_default_values"},{"location":"api/models/mixins/save-prepare-mixin/#validate_choices","text":"1 2 | @classmethod | validate_choices ( cls , new_kwargs : Dict ) -> Dict Receives dictionary of model that is about to be saved and validates the fields with choices set to see if the value is allowed. Arguments : new_kwargs : dictionary of model that is about to be saved :type new_kwargs: Dict Returns : dictionary of model that is about to be saved :rtype: Dict","title":"validate_choices"},{"location":"api/models/mixins/save-prepare-mixin/#_upsert_model","text":"1 2 | @staticmethod | async _upsert_model ( instance : \"Model\" , save_all : bool , previous_model : Optional [ \"Model\" ], relation_field : Optional [ \"ForeignKeyField\" ], update_count : int ) -> int Method updates given instance if: instance is not saved or instance have no pk or save_all=True flag is set and instance is not pk_only . If relation leading to instance is a ManyToMany also the through model is saved Arguments : instance : current model to upsert :type instance: Model save_all : flag if all models should be saved or only not saved ones :type save_all: bool relation_field : field with relation :type relation_field: Optional[ForeignKeyField] previous_model : previous model from which method came :type previous_model: Model update_count : no of updated models :type update_count: int Returns : no of updated models :rtype: int","title":"_upsert_model"},{"location":"api/models/mixins/save-prepare-mixin/#_upsert_through_model","text":"1 2 | @staticmethod | async _upsert_through_model ( instance : \"Model\" , previous_model : \"Model\" , relation_field : \"ForeignKeyField\" ) -> None Upsert through model for m2m relation. Arguments : instance : current model to upsert :type instance: Model relation_field : field with relation :type relation_field: Optional[ForeignKeyField] previous_model : previous model from which method came :type previous_model: Model","title":"_upsert_through_model"},{"location":"api/models/mixins/save-prepare-mixin/#_update_relation_list","text":"1 | async _update_relation_list ( fields_list : Collection [ \"ForeignKeyField\" ], follow : bool , save_all : bool , relation_map : Dict , update_count : int ) -> int Internal method used in save_related to follow deeper from related models and update numbers of updated related instances. :type save_all: flag if all models should be saved :type save_all: bool Arguments : fields_list : list of ormar fields to follow and save :type fields_list: Collection[\"ForeignKeyField\"] relation_map : map of relations to follow :type relation_map: Dict follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool update_count : internal parameter for recursive calls - number of updated instances :type update_count: int Returns : tuple of update count and visited :rtype: int","title":"_update_relation_list"},{"location":"api/models/mixins/save-prepare-mixin/#_get_field_values","text":"1 | _get_field_values ( name : str ) -> List Extract field values and ensures it is a list. Arguments : name : name of the field :type name: str Returns : list of values :rtype: List","title":"_get_field_values"},{"location":"api/query-set/clause/","text":"queryset.clause FilterGroup Objects 1 class FilterGroup () Filter groups are used in complex queries condition to group and and or clauses in where condition resolve 1 | resolve ( model_cls : Type [ \"Model\" ], select_related : List = None , filter_clauses : List = None ) -> Tuple [ List [ FilterAction ], List [ str ]] Resolves the FilterGroups actions to use proper target model, replace complex relation prefixes if needed and nested groups also resolved. Arguments : model_cls : model from which the query is run :type model_cls: Type[\"Model\"] select_related : list of models to join :type select_related: List[str] filter_clauses : list of filter conditions :type filter_clauses: List[FilterAction] Returns : list of filter conditions and select_related list :rtype: Tuple[List[FilterAction], List[str]] _iter 1 | _iter () -> Generator Iterates all actions in a tree Returns : generator yielding from own actions and nested groups :rtype: Generator _get_text_clauses 1 | _get_text_clauses () -> List [ sqlalchemy . sql . expression . TextClause ] Helper to return list of text queries from actions and nested groups Returns : list of text queries from actions and nested groups :rtype: List[sqlalchemy.sql.elements.TextClause] get_text_clause 1 | get_text_clause () -> sqlalchemy . sql . expression . TextClause Returns all own actions and nested groups conditions compiled and joined inside parentheses. Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause. Returns : complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause or_ 1 or_ ( * args : FilterGroup , ** kwargs : Any ) -> FilterGroup Construct or filter from nested groups and keyword arguments Arguments : args : nested filter groups :type args: Tuple[FilterGroup] kwargs : fields names and proper value types :type kwargs: Any Returns : FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup and_ 1 and_ ( * args : FilterGroup , ** kwargs : Any ) -> FilterGroup Construct and filter from nested groups and keyword arguments Arguments : args : nested filter groups :type args: Tuple[FilterGroup] kwargs : fields names and proper value types :type kwargs: Any Returns : FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup QueryClause Objects 1 class QueryClause () Constructs FilterActions from strings passed as arguments prepare_filter 1 | prepare_filter ( _own_only : bool = False , ** kwargs : Any ) -> Tuple [ List [ FilterAction ], List [ str ]] Main external access point that processes the clauses into sqlalchemy text clauses and updates select_related list with implicit related tables mentioned in select_related strings but not included in select_related. Arguments : _own_only : :type _own_only: kwargs : key, value pair with column names and values :type kwargs: Any Returns : Tuple with list of where clauses and updated select_related list :rtype: Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]] _populate_filter_clauses 1 | _populate_filter_clauses ( _own_only : bool , ** kwargs : Any ) -> Tuple [ List [ FilterAction ], List [ str ]] Iterates all clauses and extracts used operator and field from related models if needed. Based on the chain of related names the target table is determined and the final clause is escaped if needed and compiled. Arguments : kwargs : key, value pair with column names and values :type kwargs: Any Returns : Tuple with list of where clauses and updated select_related list :rtype: Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]] _register_complex_duplicates 1 | _register_complex_duplicates ( select_related : List [ str ]) -> None Checks if duplicate aliases are presented which can happen in self relation or when two joins end with the same pair of models. If there are duplicates, the all duplicated joins are registered as source model and whole relation key (not just last relation name). Arguments : select_related : list of relation strings :type select_related: List[str] Returns : None :rtype: None _parse_related_prefixes 1 | _parse_related_prefixes ( select_related : List [ str ]) -> List [ Prefix ] Walks all relation strings and parses the target models and prefixes. Arguments : select_related : list of relation strings :type select_related: List[str] Returns : list of parsed prefixes :rtype: List[Prefix] _switch_filter_action_prefixes 1 | _switch_filter_action_prefixes ( filter_clauses : List [ FilterAction ]) -> List [ FilterAction ] Substitutes aliases for filter action if the complex key (whole relation str) is present in alias_manager. Arguments : filter_clauses : raw list of actions :type filter_clauses: List[FilterAction] Returns : list of actions with aliases changed if needed :rtype: List[FilterAction] _verify_prefix_and_switch 1 | _verify_prefix_and_switch ( action : \"FilterAction\" ) -> None Helper to switch prefix to complex relation one if required Arguments : action : action to switch prefix in :type action: ormar.queryset.actions.filter_action.FilterAction","title":"Clause"},{"location":"api/query-set/clause/#querysetclause","text":"","title":"queryset.clause"},{"location":"api/query-set/clause/#filtergroup-objects","text":"1 class FilterGroup () Filter groups are used in complex queries condition to group and and or clauses in where condition","title":"FilterGroup Objects"},{"location":"api/query-set/clause/#resolve","text":"1 | resolve ( model_cls : Type [ \"Model\" ], select_related : List = None , filter_clauses : List = None ) -> Tuple [ List [ FilterAction ], List [ str ]] Resolves the FilterGroups actions to use proper target model, replace complex relation prefixes if needed and nested groups also resolved. Arguments : model_cls : model from which the query is run :type model_cls: Type[\"Model\"] select_related : list of models to join :type select_related: List[str] filter_clauses : list of filter conditions :type filter_clauses: List[FilterAction] Returns : list of filter conditions and select_related list :rtype: Tuple[List[FilterAction], List[str]]","title":"resolve"},{"location":"api/query-set/clause/#_iter","text":"1 | _iter () -> Generator Iterates all actions in a tree Returns : generator yielding from own actions and nested groups :rtype: Generator","title":"_iter"},{"location":"api/query-set/clause/#_get_text_clauses","text":"1 | _get_text_clauses () -> List [ sqlalchemy . sql . expression . TextClause ] Helper to return list of text queries from actions and nested groups Returns : list of text queries from actions and nested groups :rtype: List[sqlalchemy.sql.elements.TextClause]","title":"_get_text_clauses"},{"location":"api/query-set/clause/#get_text_clause","text":"1 | get_text_clause () -> sqlalchemy . sql . expression . TextClause Returns all own actions and nested groups conditions compiled and joined inside parentheses. Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause. Returns : complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause","title":"get_text_clause"},{"location":"api/query-set/clause/#or_","text":"1 or_ ( * args : FilterGroup , ** kwargs : Any ) -> FilterGroup Construct or filter from nested groups and keyword arguments Arguments : args : nested filter groups :type args: Tuple[FilterGroup] kwargs : fields names and proper value types :type kwargs: Any Returns : FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup","title":"or_"},{"location":"api/query-set/clause/#and_","text":"1 and_ ( * args : FilterGroup , ** kwargs : Any ) -> FilterGroup Construct and filter from nested groups and keyword arguments Arguments : args : nested filter groups :type args: Tuple[FilterGroup] kwargs : fields names and proper value types :type kwargs: Any Returns : FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup","title":"and_"},{"location":"api/query-set/clause/#queryclause-objects","text":"1 class QueryClause () Constructs FilterActions from strings passed as arguments","title":"QueryClause Objects"},{"location":"api/query-set/clause/#prepare_filter","text":"1 | prepare_filter ( _own_only : bool = False , ** kwargs : Any ) -> Tuple [ List [ FilterAction ], List [ str ]] Main external access point that processes the clauses into sqlalchemy text clauses and updates select_related list with implicit related tables mentioned in select_related strings but not included in select_related. Arguments : _own_only : :type _own_only: kwargs : key, value pair with column names and values :type kwargs: Any Returns : Tuple with list of where clauses and updated select_related list :rtype: Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]","title":"prepare_filter"},{"location":"api/query-set/clause/#_populate_filter_clauses","text":"1 | _populate_filter_clauses ( _own_only : bool , ** kwargs : Any ) -> Tuple [ List [ FilterAction ], List [ str ]] Iterates all clauses and extracts used operator and field from related models if needed. Based on the chain of related names the target table is determined and the final clause is escaped if needed and compiled. Arguments : kwargs : key, value pair with column names and values :type kwargs: Any Returns : Tuple with list of where clauses and updated select_related list :rtype: Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]","title":"_populate_filter_clauses"},{"location":"api/query-set/clause/#_register_complex_duplicates","text":"1 | _register_complex_duplicates ( select_related : List [ str ]) -> None Checks if duplicate aliases are presented which can happen in self relation or when two joins end with the same pair of models. If there are duplicates, the all duplicated joins are registered as source model and whole relation key (not just last relation name). Arguments : select_related : list of relation strings :type select_related: List[str] Returns : None :rtype: None","title":"_register_complex_duplicates"},{"location":"api/query-set/clause/#_parse_related_prefixes","text":"1 | _parse_related_prefixes ( select_related : List [ str ]) -> List [ Prefix ] Walks all relation strings and parses the target models and prefixes. Arguments : select_related : list of relation strings :type select_related: List[str] Returns : list of parsed prefixes :rtype: List[Prefix]","title":"_parse_related_prefixes"},{"location":"api/query-set/clause/#_switch_filter_action_prefixes","text":"1 | _switch_filter_action_prefixes ( filter_clauses : List [ FilterAction ]) -> List [ FilterAction ] Substitutes aliases for filter action if the complex key (whole relation str) is present in alias_manager. Arguments : filter_clauses : raw list of actions :type filter_clauses: List[FilterAction] Returns : list of actions with aliases changed if needed :rtype: List[FilterAction]","title":"_switch_filter_action_prefixes"},{"location":"api/query-set/clause/#_verify_prefix_and_switch","text":"1 | _verify_prefix_and_switch ( action : \"FilterAction\" ) -> None Helper to switch prefix to complex relation one if required Arguments : action : action to switch prefix in :type action: ormar.queryset.actions.filter_action.FilterAction","title":"_verify_prefix_and_switch"},{"location":"api/query-set/field-accessor/","text":"queryset.field_accessor FieldAccessor Objects 1 class FieldAccessor () Helper to access ormar fields directly from Model class also for nested models attributes. __bool__ 1 | __bool__ () -> bool Hack to avoid pydantic name check from parent model, returns false Returns : False :rtype: bool __getattr__ 1 | __getattr__ ( item : str ) -> Any Accessor return new accessor for each field and nested models. Thanks to that operator overload is possible to use in filter. Arguments : item : attribute name :type item: str Returns : FieldAccessor for field or nested model :rtype: ormar.queryset.field_accessor.FieldAccessor __eq__ 1 | __eq__ ( other : Any ) -> FilterGroup overloaded to work as sql column = <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup __ge__ 1 | __ge__ ( other : Any ) -> FilterGroup overloaded to work as sql column >= <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup __gt__ 1 | __gt__ ( other : Any ) -> FilterGroup overloaded to work as sql column > <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup __le__ 1 | __le__ ( other : Any ) -> FilterGroup overloaded to work as sql column <= <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup __lt__ 1 | __lt__ ( other : Any ) -> FilterGroup overloaded to work as sql column < <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup __mod__ 1 | __mod__ ( other : Any ) -> FilterGroup overloaded to work as sql column LIKE '%<VALUE>%' Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup __lshift__ 1 | __lshift__ ( other : Any ) -> FilterGroup overloaded to work as sql column IN (<VALUE1>, <VALUE2>,...) Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup __rshift__ 1 | __rshift__ ( other : Any ) -> FilterGroup overloaded to work as sql column IS NULL Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup in_ 1 | in_ ( other : Any ) -> FilterGroup works as sql column IN (<VALUE1>, <VALUE2>,...) Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup iexact 1 | iexact ( other : Any ) -> FilterGroup works as sql column = <VALUE> case-insensitive Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup contains 1 | contains ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>%' Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup icontains 1 | icontains ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>%' case-insensitive Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup startswith 1 | startswith ( other : Any ) -> FilterGroup works as sql column LIKE '<VALUE>%' Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup istartswith 1 | istartswith ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>' case-insensitive Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup endswith 1 | endswith ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>' Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup iendswith 1 | iendswith ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>' case-insensitive Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup isnull 1 | isnull ( other : Any ) -> FilterGroup works as sql column IS NULL or IS NOT NULL Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup asc 1 | asc () -> OrderAction works as sql column asc Returns : OrderGroup for operator :rtype: ormar.queryset.actions.OrderGroup desc 1 | desc () -> OrderAction works as sql column desc Returns : OrderGroup for operator :rtype: ormar.queryset.actions.OrderGroup","title":"Field Accessor"},{"location":"api/query-set/field-accessor/#querysetfield_accessor","text":"","title":"queryset.field_accessor"},{"location":"api/query-set/field-accessor/#fieldaccessor-objects","text":"1 class FieldAccessor () Helper to access ormar fields directly from Model class also for nested models attributes.","title":"FieldAccessor Objects"},{"location":"api/query-set/field-accessor/#__bool__","text":"1 | __bool__ () -> bool Hack to avoid pydantic name check from parent model, returns false Returns : False :rtype: bool","title":"__bool__"},{"location":"api/query-set/field-accessor/#__getattr__","text":"1 | __getattr__ ( item : str ) -> Any Accessor return new accessor for each field and nested models. Thanks to that operator overload is possible to use in filter. Arguments : item : attribute name :type item: str Returns : FieldAccessor for field or nested model :rtype: ormar.queryset.field_accessor.FieldAccessor","title":"__getattr__"},{"location":"api/query-set/field-accessor/#__eq__","text":"1 | __eq__ ( other : Any ) -> FilterGroup overloaded to work as sql column = <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"__eq__"},{"location":"api/query-set/field-accessor/#__ge__","text":"1 | __ge__ ( other : Any ) -> FilterGroup overloaded to work as sql column >= <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"__ge__"},{"location":"api/query-set/field-accessor/#__gt__","text":"1 | __gt__ ( other : Any ) -> FilterGroup overloaded to work as sql column > <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"__gt__"},{"location":"api/query-set/field-accessor/#__le__","text":"1 | __le__ ( other : Any ) -> FilterGroup overloaded to work as sql column <= <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"__le__"},{"location":"api/query-set/field-accessor/#__lt__","text":"1 | __lt__ ( other : Any ) -> FilterGroup overloaded to work as sql column < <VALUE> Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"__lt__"},{"location":"api/query-set/field-accessor/#__mod__","text":"1 | __mod__ ( other : Any ) -> FilterGroup overloaded to work as sql column LIKE '%<VALUE>%' Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"__mod__"},{"location":"api/query-set/field-accessor/#__lshift__","text":"1 | __lshift__ ( other : Any ) -> FilterGroup overloaded to work as sql column IN (<VALUE1>, <VALUE2>,...) Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"__lshift__"},{"location":"api/query-set/field-accessor/#__rshift__","text":"1 | __rshift__ ( other : Any ) -> FilterGroup overloaded to work as sql column IS NULL Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"__rshift__"},{"location":"api/query-set/field-accessor/#in_","text":"1 | in_ ( other : Any ) -> FilterGroup works as sql column IN (<VALUE1>, <VALUE2>,...) Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"in_"},{"location":"api/query-set/field-accessor/#iexact","text":"1 | iexact ( other : Any ) -> FilterGroup works as sql column = <VALUE> case-insensitive Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"iexact"},{"location":"api/query-set/field-accessor/#contains","text":"1 | contains ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>%' Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"contains"},{"location":"api/query-set/field-accessor/#icontains","text":"1 | icontains ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>%' case-insensitive Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"icontains"},{"location":"api/query-set/field-accessor/#startswith","text":"1 | startswith ( other : Any ) -> FilterGroup works as sql column LIKE '<VALUE>%' Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"startswith"},{"location":"api/query-set/field-accessor/#istartswith","text":"1 | istartswith ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>' case-insensitive Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"istartswith"},{"location":"api/query-set/field-accessor/#endswith","text":"1 | endswith ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>' Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"endswith"},{"location":"api/query-set/field-accessor/#iendswith","text":"1 | iendswith ( other : Any ) -> FilterGroup works as sql column LIKE '%<VALUE>' case-insensitive Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"iendswith"},{"location":"api/query-set/field-accessor/#isnull","text":"1 | isnull ( other : Any ) -> FilterGroup works as sql column IS NULL or IS NOT NULL Arguments : other : value to check agains operator :type other: str Returns : FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup","title":"isnull"},{"location":"api/query-set/field-accessor/#asc","text":"1 | asc () -> OrderAction works as sql column asc Returns : OrderGroup for operator :rtype: ormar.queryset.actions.OrderGroup","title":"asc"},{"location":"api/query-set/field-accessor/#desc","text":"1 | desc () -> OrderAction works as sql column desc Returns : OrderGroup for operator :rtype: ormar.queryset.actions.OrderGroup","title":"desc"},{"location":"api/query-set/filter-query/","text":"queryset.filter_query FilterQuery Objects 1 class FilterQuery () Modifies the select query with given list of where/filter clauses. apply 1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies all filter clauses if set. Arguments : expr : query to modify :type expr: sqlalchemy.sql.selectable.Select Returns : modified query :rtype: sqlalchemy.sql.selectable.Select","title":"Filter Query"},{"location":"api/query-set/filter-query/#querysetfilter_query","text":"","title":"queryset.filter_query"},{"location":"api/query-set/filter-query/#filterquery-objects","text":"1 class FilterQuery () Modifies the select query with given list of where/filter clauses.","title":"FilterQuery Objects"},{"location":"api/query-set/filter-query/#apply","text":"1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies all filter clauses if set. Arguments : expr : query to modify :type expr: sqlalchemy.sql.selectable.Select Returns : modified query :rtype: sqlalchemy.sql.selectable.Select","title":"apply"},{"location":"api/query-set/join/","text":"queryset.join SqlJoin Objects 1 class SqlJoin () alias_manager 1 2 | @property | alias_manager () -> AliasManager Shortcut for ormar's model AliasManager stored on Meta. Returns : alias manager from model's Meta :rtype: AliasManager to_table 1 2 | @property | to_table () -> sqlalchemy . Table Shortcut to table name of the next model Returns : name of the target table :rtype: str _on_clause 1 | _on_clause ( previous_alias : str , from_clause : str , to_clause : str ) -> text Receives aliases and names of both ends of the join and combines them into one text clause used in joins. Arguments : previous_alias : alias of previous table :type previous_alias: str from_clause : from table name :type from_clause: str to_clause : to table name :type to_clause: str Returns : clause combining all strings :rtype: sqlalchemy.text build_join 1 | build_join () -> Tuple [ List , sqlalchemy . sql . select , List , OrderedDict ] Main external access point for building a join. Splits the join definition, updates fields and exclude_fields if needed, handles switching to through models for m2m relations, returns updated lists of used_aliases and sort_orders. Returns : list of used aliases, select from, list of aliased columns, sort orders :rtype: Tuple[List[str], Join, List[TextClause], collections.OrderedDict] _forward_join 1 | _forward_join () -> None Process actual join. Registers complex relation join on encountering of the duplicated alias. _process_following_joins 1 | _process_following_joins () -> None Iterates through nested models to create subsequent joins. _process_deeper_join 1 | _process_deeper_join ( related_name : str , remainder : Any ) -> None Creates nested recurrent instance of SqlJoin for each nested join table, updating needed return params here as a side effect. Updated are: self.used_aliases, self.select_from, self.columns, self.sorted_orders, Arguments : related_name : name of the relation to follow :type related_name: str remainder : deeper tables if there are more nested joins :type remainder: Any _process_m2m_through_table 1 | _process_m2m_through_table () -> None Process Through table of the ManyToMany relation so that source table is linked to the through table (one additional join) Replaces needed parameters like: self.next_model, self.next_alias, self.relation_name, self.own_alias, self.target_field To point to through model _process_m2m_related_name_change 1 | _process_m2m_related_name_change ( reverse : bool = False ) -> str Extracts relation name to link join through the Through model declared on relation field. Changes the same names in order_by queries if they are present. Arguments : reverse : flag if it's on_clause lookup - use reverse fields :type reverse: bool Returns : new relation name switched to through model field :rtype: str _process_join 1 | _process_join () -> None Resolves to and from column names and table names. Produces on_clause. Performs actual join updating select_from parameter. Adds aliases of required column to list of columns to include in query. Updates the used aliases list directly. Process order_by causes for non m2m relations. _verify_allowed_order_field 1 | _verify_allowed_order_field ( order_by : str ) -> None Verifies if proper field string is used. Arguments : order_by : string with order by definition :type order_by: str _get_alias_and_model 1 | _get_alias_and_model ( order_by : str ) -> Tuple [ str , Type [ \"Model\" ]] Returns proper model and alias to be applied in the clause. Arguments : order_by : string with order by definition :type order_by: str Returns : alias and model to be used in clause :rtype: Tuple[str, Type[\"Model\"]] _get_order_bys 1 | _get_order_bys () -> None Triggers construction of order bys if they are given. Otherwise by default each table is sorted by a primary key column asc. _get_to_and_from_keys 1 | _get_to_and_from_keys () -> Tuple [ str , str ] Based on the relation type, name of the relation and previous models and parts stored in JoinParameters it resolves the current to and from keys, which are different for ManyToMany relation, ForeignKey and reverse related of relations. Returns : to key and from key :rtype: Tuple[str, str]","title":"Join"},{"location":"api/query-set/join/#querysetjoin","text":"","title":"queryset.join"},{"location":"api/query-set/join/#sqljoin-objects","text":"1 class SqlJoin ()","title":"SqlJoin Objects"},{"location":"api/query-set/join/#alias_manager","text":"1 2 | @property | alias_manager () -> AliasManager Shortcut for ormar's model AliasManager stored on Meta. Returns : alias manager from model's Meta :rtype: AliasManager","title":"alias_manager"},{"location":"api/query-set/join/#to_table","text":"1 2 | @property | to_table () -> sqlalchemy . Table Shortcut to table name of the next model Returns : name of the target table :rtype: str","title":"to_table"},{"location":"api/query-set/join/#_on_clause","text":"1 | _on_clause ( previous_alias : str , from_clause : str , to_clause : str ) -> text Receives aliases and names of both ends of the join and combines them into one text clause used in joins. Arguments : previous_alias : alias of previous table :type previous_alias: str from_clause : from table name :type from_clause: str to_clause : to table name :type to_clause: str Returns : clause combining all strings :rtype: sqlalchemy.text","title":"_on_clause"},{"location":"api/query-set/join/#build_join","text":"1 | build_join () -> Tuple [ List , sqlalchemy . sql . select , List , OrderedDict ] Main external access point for building a join. Splits the join definition, updates fields and exclude_fields if needed, handles switching to through models for m2m relations, returns updated lists of used_aliases and sort_orders. Returns : list of used aliases, select from, list of aliased columns, sort orders :rtype: Tuple[List[str], Join, List[TextClause], collections.OrderedDict]","title":"build_join"},{"location":"api/query-set/join/#_forward_join","text":"1 | _forward_join () -> None Process actual join. Registers complex relation join on encountering of the duplicated alias.","title":"_forward_join"},{"location":"api/query-set/join/#_process_following_joins","text":"1 | _process_following_joins () -> None Iterates through nested models to create subsequent joins.","title":"_process_following_joins"},{"location":"api/query-set/join/#_process_deeper_join","text":"1 | _process_deeper_join ( related_name : str , remainder : Any ) -> None Creates nested recurrent instance of SqlJoin for each nested join table, updating needed return params here as a side effect. Updated are: self.used_aliases, self.select_from, self.columns, self.sorted_orders, Arguments : related_name : name of the relation to follow :type related_name: str remainder : deeper tables if there are more nested joins :type remainder: Any","title":"_process_deeper_join"},{"location":"api/query-set/join/#_process_m2m_through_table","text":"1 | _process_m2m_through_table () -> None Process Through table of the ManyToMany relation so that source table is linked to the through table (one additional join) Replaces needed parameters like: self.next_model, self.next_alias, self.relation_name, self.own_alias, self.target_field To point to through model","title":"_process_m2m_through_table"},{"location":"api/query-set/join/#_process_m2m_related_name_change","text":"1 | _process_m2m_related_name_change ( reverse : bool = False ) -> str Extracts relation name to link join through the Through model declared on relation field. Changes the same names in order_by queries if they are present. Arguments : reverse : flag if it's on_clause lookup - use reverse fields :type reverse: bool Returns : new relation name switched to through model field :rtype: str","title":"_process_m2m_related_name_change"},{"location":"api/query-set/join/#_process_join","text":"1 | _process_join () -> None Resolves to and from column names and table names. Produces on_clause. Performs actual join updating select_from parameter. Adds aliases of required column to list of columns to include in query. Updates the used aliases list directly. Process order_by causes for non m2m relations.","title":"_process_join"},{"location":"api/query-set/join/#_verify_allowed_order_field","text":"1 | _verify_allowed_order_field ( order_by : str ) -> None Verifies if proper field string is used. Arguments : order_by : string with order by definition :type order_by: str","title":"_verify_allowed_order_field"},{"location":"api/query-set/join/#_get_alias_and_model","text":"1 | _get_alias_and_model ( order_by : str ) -> Tuple [ str , Type [ \"Model\" ]] Returns proper model and alias to be applied in the clause. Arguments : order_by : string with order by definition :type order_by: str Returns : alias and model to be used in clause :rtype: Tuple[str, Type[\"Model\"]]","title":"_get_alias_and_model"},{"location":"api/query-set/join/#_get_order_bys","text":"1 | _get_order_bys () -> None Triggers construction of order bys if they are given. Otherwise by default each table is sorted by a primary key column asc.","title":"_get_order_bys"},{"location":"api/query-set/join/#_get_to_and_from_keys","text":"1 | _get_to_and_from_keys () -> Tuple [ str , str ] Based on the relation type, name of the relation and previous models and parts stored in JoinParameters it resolves the current to and from keys, which are different for ManyToMany relation, ForeignKey and reverse related of relations. Returns : to key and from key :rtype: Tuple[str, str]","title":"_get_to_and_from_keys"},{"location":"api/query-set/limit-query/","text":"queryset.limit_query LimitQuery Objects 1 class LimitQuery () Modifies the select query with limit clause. apply 1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies the limit clause. Arguments : expr : query to modify :type expr: sqlalchemy.sql.selectable.Select Returns : modified query :rtype: sqlalchemy.sql.selectable.Select","title":"Limit Query"},{"location":"api/query-set/limit-query/#querysetlimit_query","text":"","title":"queryset.limit_query"},{"location":"api/query-set/limit-query/#limitquery-objects","text":"1 class LimitQuery () Modifies the select query with limit clause.","title":"LimitQuery Objects"},{"location":"api/query-set/limit-query/#apply","text":"1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies the limit clause. Arguments : expr : query to modify :type expr: sqlalchemy.sql.selectable.Select Returns : modified query :rtype: sqlalchemy.sql.selectable.Select","title":"apply"},{"location":"api/query-set/offset-query/","text":"queryset.offset_query OffsetQuery Objects 1 class OffsetQuery () Modifies the select query with offset if set apply 1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies the offset clause. Arguments : expr : query to modify :type expr: sqlalchemy.sql.selectable.Select Returns : modified query :rtype: sqlalchemy.sql.selectable.Select","title":"Offset Query"},{"location":"api/query-set/offset-query/#querysetoffset_query","text":"","title":"queryset.offset_query"},{"location":"api/query-set/offset-query/#offsetquery-objects","text":"1 class OffsetQuery () Modifies the select query with offset if set","title":"OffsetQuery Objects"},{"location":"api/query-set/offset-query/#apply","text":"1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies the offset clause. Arguments : expr : query to modify :type expr: sqlalchemy.sql.selectable.Select Returns : modified query :rtype: sqlalchemy.sql.selectable.Select","title":"apply"},{"location":"api/query-set/order-query/","text":"queryset.order_query OrderQuery Objects 1 class OrderQuery () Modifies the select query with given list of order_by clauses. apply 1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies all order_by clauses if set. Arguments : expr : query to modify :type expr: sqlalchemy.sql.selectable.Select Returns : modified query :rtype: sqlalchemy.sql.selectable.Select","title":"Order Query"},{"location":"api/query-set/order-query/#querysetorder_query","text":"","title":"queryset.order_query"},{"location":"api/query-set/order-query/#orderquery-objects","text":"1 class OrderQuery () Modifies the select query with given list of order_by clauses.","title":"OrderQuery Objects"},{"location":"api/query-set/order-query/#apply","text":"1 | apply ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Applies all order_by clauses if set. Arguments : expr : query to modify :type expr: sqlalchemy.sql.selectable.Select Returns : modified query :rtype: sqlalchemy.sql.selectable.Select","title":"apply"},{"location":"api/query-set/prefetch-query/","text":"queryset.prefetch_query sort_models 1 sort_models ( models : List [ \"Model\" ], orders_by : Dict ) -> List [ \"Model\" ] Since prefetch query gets all related models by ids the sorting needs to happen in python. Since by default models are already sorted by id here we resort only if order_by parameters was set. Arguments : models : list of models already fetched from db :type models: List[tests.test_prefetch_related.Division] orders_by : order by dictionary :type orders_by: Dict[str, str] Returns : sorted list of models :rtype: List[tests.test_prefetch_related.Division] set_children_on_model 1 set_children_on_model ( model : \"Model\" , related : str , children : Dict , model_id : int , models : Dict , orders_by : Dict ) -> None Extract ids of child models by given relation id key value. Based on those ids the actual children model instances are fetched from already fetched data. If needed the child models are resorted according to passed orders_by dict. Also relation is registered as each child is set as parent related field name value. Arguments : model : parent model instance :type model: Model related : name of the related field :type related: str children : dictionary of children ids/ related field value :type children: Dict[int, set] model_id : id of the model on which children should be set :type model_id: int models : dictionary of child models instances :type models: Dict orders_by : order_by dictionary :type orders_by: Dict PrefetchQuery Objects 1 class PrefetchQuery () Query used to fetch related models in subsequent queries. Each model is fetched only ones by the name of the relation. That means that for each prefetch_related entry next query is issued to database. prefetch_related 1 | async prefetch_related ( models : Sequence [ \"Model\" ], rows : List ) -> Sequence [ \"Model\" ] Main entry point for prefetch_query. Receives list of already initialized parent models with all children from select_related already populated. Receives also list of row sql result rows as it's quicker to extract ids that way instead of calling each model. Returns list with related models already prefetched and set. Arguments : models : list of already instantiated models from main query :type models: List[Model] rows : row sql result of the main query before the prefetch :type rows: List[sqlalchemy.engine.result.RowProxy] Returns : list of models with children prefetched :rtype: List[Model] _extract_ids_from_raw_data 1 | _extract_ids_from_raw_data ( parent_model : Type [ \"Model\" ], column_name : str ) -> Set Iterates over raw rows and extract id values of relation columns by using prefixed column name. Arguments : parent_model : ormar model class :type parent_model: Type[Model] column_name : name of the relation column which is a key column :type column_name: str Returns : set of ids of related model that should be extracted :rtype: set _extract_ids_from_preloaded_models 1 | _extract_ids_from_preloaded_models ( parent_model : Type [ \"Model\" ], column_name : str ) -> Set Extracts relation ids from already populated models if they were included in the original query before. Arguments : parent_model : model from which related ids should be extracted :type parent_model: Type[\"Model\"] column_name : name of the relation column which is a key column :type column_name: str Returns : set of ids of related model that should be extracted :rtype: set _extract_required_ids 1 | _extract_required_ids ( parent_model : Type [ \"Model\" ], reverse : bool , related : str ) -> Set Delegates extraction of the fields to either get ids from raw sql response or from already populated models. Arguments : parent_model : model from which related ids should be extracted :type parent_model: Type[\"Model\"] reverse : flag if the relation is reverse :type reverse: bool related : name of the field with relation :type related: str Returns : set of ids of related model that should be extracted :rtype: set _get_filter_for_prefetch 1 | _get_filter_for_prefetch ( parent_model : Type [ \"Model\" ], target_model : Type [ \"Model\" ], reverse : bool , related : str ) -> List Populates where clause with condition to return only models within the set of extracted ids. If there are no ids for relation the empty list is returned. Arguments : parent_model : model from which related ids should be extracted :type parent_model: Type[\"Model\"] target_model : model to which relation leads to :type target_model: Type[\"Model\"] reverse : flag if the relation is reverse :type reverse: bool related : name of the field with relation :type related: str Returns : :rtype: List[sqlalchemy.sql.elements.TextClause] _populate_nested_related 1 | _populate_nested_related ( model : \"Model\" , prefetch_dict : Dict , orders_by : Dict ) -> \"Model\" Populates all related models children of parent model that are included in prefetch query. Arguments : model : ormar model instance :type model: Model prefetch_dict : dictionary of models to prefetch :type prefetch_dict: Dict orders_by : dictionary of order bys :type orders_by: Dict Returns : model with children populated :rtype: Model _prefetch_related_models 1 | async _prefetch_related_models ( models : Sequence [ \"Model\" ], rows : List ) -> Sequence [ \"Model\" ] Main method of the query. Translates select nad prefetch list into dictionaries to avoid querying the same related models multiple times. Keeps the list of already extracted models. Extracts the related models from the database and later populate all children on each of the parent models from list. Arguments : models : list of parent models from main query :type models: List[Model] rows : raw response from sql query :type rows: List[sqlalchemy.engine.result.RowProxy] Returns : list of models with prefetch children populated :rtype: List[Model] _extract_related_models 1 | async _extract_related_models ( related : str , target_model : Type [ \"Model\" ], prefetch_dict : Dict , select_dict : Dict , excludable : \"ExcludableItems\" , orders_by : Dict ) -> None Constructs queries with required ids and extracts data with fields that should be included/excluded. Runs the queries against the database and populated dictionaries with ids and with actual extracted children models. Calls itself recurrently to extract deeper nested relations of related model. Arguments : related : name of the relation :type related: str target_model : model to which relation leads to :type target_model: Type[Model] prefetch_dict : prefetch related list converted into dictionary :type prefetch_dict: Dict select_dict : select related list converted into dictionary :type select_dict: Dict fields : fields to include :type fields: Union[Set[Any], Dict[Any, Any], None] exclude_fields : fields to exclude :type exclude_fields: Union[Set[Any], Dict[Any, Any], None] orders_by : dictionary of order bys clauses :type orders_by: Dict Returns : None :rtype: None _run_prefetch_query 1 | async _run_prefetch_query ( target_field : \"BaseField\" , excludable : \"ExcludableItems\" , filter_clauses : List , related_field_name : str ) -> Tuple [ str , str , List ] Actually runs the queries against the database and populates the raw response for given related model. Returns table prefix as it's later needed to eventually initialize the children models. Arguments : target_field : ormar field with relation definition :type target_field: \"BaseField\" filter_clauses : list of clauses, actually one clause with ids of relation :type filter_clauses: List[sqlalchemy.sql.elements.TextClause] Returns : table prefix and raw rows from sql response :rtype: Tuple[str, List] _get_select_related_if_apply 1 2 | @staticmethod | _get_select_related_if_apply ( related : str , select_dict : Dict ) -> Dict Extract nested related of select_related dictionary to extract models nested deeper on related model and already loaded in select related query. Arguments : related : name of the relation :type related: str select_dict : dictionary of select related models in main query :type select_dict: Dict Returns : dictionary with nested related of select related :rtype: Dict _update_already_loaded_rows 1 | _update_already_loaded_rows ( target_field : \"BaseField\" , prefetch_dict : Dict , orders_by : Dict ) -> None Updates models that are already loaded, usually children of children. Arguments : target_field : ormar field with relation definition :type target_field: \"BaseField\" prefetch_dict : dictionaries of related models to prefetch :type prefetch_dict: Dict orders_by : dictionary of order by clauses by model :type orders_by: Dict _populate_rows 1 | _populate_rows ( rows : List , target_field : \"ForeignKeyField\" , parent_model : Type [ \"Model\" ], table_prefix : str , exclude_prefix : str , excludable : \"ExcludableItems\" , prefetch_dict : Dict , orders_by : Dict ) -> None Instantiates children models extracted from given relation. Populates them with their own nested children if they are included in prefetch query. Sets the initialized models and ids of them under corresponding keys in already_extracted dictionary. Later those instances will be fetched by ids and set on the parent model after sorting if needed. Arguments : excludable : structure of fields to include and exclude :type excludable: ExcludableItems rows : raw sql response from the prefetch query :type rows: List[sqlalchemy.engine.result.RowProxy] target_field : field with relation definition from parent model :type target_field: \"BaseField\" parent_model : model with relation definition :type parent_model: Type[Model] table_prefix : prefix of the target table from current relation :type table_prefix: str prefetch_dict : dictionaries of related models to prefetch :type prefetch_dict: Dict orders_by : dictionary of order by clauses by model :type orders_by: Dict","title":"Prefetch Query"},{"location":"api/query-set/prefetch-query/#querysetprefetch_query","text":"","title":"queryset.prefetch_query"},{"location":"api/query-set/prefetch-query/#sort_models","text":"1 sort_models ( models : List [ \"Model\" ], orders_by : Dict ) -> List [ \"Model\" ] Since prefetch query gets all related models by ids the sorting needs to happen in python. Since by default models are already sorted by id here we resort only if order_by parameters was set. Arguments : models : list of models already fetched from db :type models: List[tests.test_prefetch_related.Division] orders_by : order by dictionary :type orders_by: Dict[str, str] Returns : sorted list of models :rtype: List[tests.test_prefetch_related.Division]","title":"sort_models"},{"location":"api/query-set/prefetch-query/#set_children_on_model","text":"1 set_children_on_model ( model : \"Model\" , related : str , children : Dict , model_id : int , models : Dict , orders_by : Dict ) -> None Extract ids of child models by given relation id key value. Based on those ids the actual children model instances are fetched from already fetched data. If needed the child models are resorted according to passed orders_by dict. Also relation is registered as each child is set as parent related field name value. Arguments : model : parent model instance :type model: Model related : name of the related field :type related: str children : dictionary of children ids/ related field value :type children: Dict[int, set] model_id : id of the model on which children should be set :type model_id: int models : dictionary of child models instances :type models: Dict orders_by : order_by dictionary :type orders_by: Dict","title":"set_children_on_model"},{"location":"api/query-set/prefetch-query/#prefetchquery-objects","text":"1 class PrefetchQuery () Query used to fetch related models in subsequent queries. Each model is fetched only ones by the name of the relation. That means that for each prefetch_related entry next query is issued to database.","title":"PrefetchQuery Objects"},{"location":"api/query-set/prefetch-query/#prefetch_related","text":"1 | async prefetch_related ( models : Sequence [ \"Model\" ], rows : List ) -> Sequence [ \"Model\" ] Main entry point for prefetch_query. Receives list of already initialized parent models with all children from select_related already populated. Receives also list of row sql result rows as it's quicker to extract ids that way instead of calling each model. Returns list with related models already prefetched and set. Arguments : models : list of already instantiated models from main query :type models: List[Model] rows : row sql result of the main query before the prefetch :type rows: List[sqlalchemy.engine.result.RowProxy] Returns : list of models with children prefetched :rtype: List[Model]","title":"prefetch_related"},{"location":"api/query-set/prefetch-query/#_extract_ids_from_raw_data","text":"1 | _extract_ids_from_raw_data ( parent_model : Type [ \"Model\" ], column_name : str ) -> Set Iterates over raw rows and extract id values of relation columns by using prefixed column name. Arguments : parent_model : ormar model class :type parent_model: Type[Model] column_name : name of the relation column which is a key column :type column_name: str Returns : set of ids of related model that should be extracted :rtype: set","title":"_extract_ids_from_raw_data"},{"location":"api/query-set/prefetch-query/#_extract_ids_from_preloaded_models","text":"1 | _extract_ids_from_preloaded_models ( parent_model : Type [ \"Model\" ], column_name : str ) -> Set Extracts relation ids from already populated models if they were included in the original query before. Arguments : parent_model : model from which related ids should be extracted :type parent_model: Type[\"Model\"] column_name : name of the relation column which is a key column :type column_name: str Returns : set of ids of related model that should be extracted :rtype: set","title":"_extract_ids_from_preloaded_models"},{"location":"api/query-set/prefetch-query/#_extract_required_ids","text":"1 | _extract_required_ids ( parent_model : Type [ \"Model\" ], reverse : bool , related : str ) -> Set Delegates extraction of the fields to either get ids from raw sql response or from already populated models. Arguments : parent_model : model from which related ids should be extracted :type parent_model: Type[\"Model\"] reverse : flag if the relation is reverse :type reverse: bool related : name of the field with relation :type related: str Returns : set of ids of related model that should be extracted :rtype: set","title":"_extract_required_ids"},{"location":"api/query-set/prefetch-query/#_get_filter_for_prefetch","text":"1 | _get_filter_for_prefetch ( parent_model : Type [ \"Model\" ], target_model : Type [ \"Model\" ], reverse : bool , related : str ) -> List Populates where clause with condition to return only models within the set of extracted ids. If there are no ids for relation the empty list is returned. Arguments : parent_model : model from which related ids should be extracted :type parent_model: Type[\"Model\"] target_model : model to which relation leads to :type target_model: Type[\"Model\"] reverse : flag if the relation is reverse :type reverse: bool related : name of the field with relation :type related: str Returns : :rtype: List[sqlalchemy.sql.elements.TextClause]","title":"_get_filter_for_prefetch"},{"location":"api/query-set/prefetch-query/#_populate_nested_related","text":"1 | _populate_nested_related ( model : \"Model\" , prefetch_dict : Dict , orders_by : Dict ) -> \"Model\" Populates all related models children of parent model that are included in prefetch query. Arguments : model : ormar model instance :type model: Model prefetch_dict : dictionary of models to prefetch :type prefetch_dict: Dict orders_by : dictionary of order bys :type orders_by: Dict Returns : model with children populated :rtype: Model","title":"_populate_nested_related"},{"location":"api/query-set/prefetch-query/#_prefetch_related_models","text":"1 | async _prefetch_related_models ( models : Sequence [ \"Model\" ], rows : List ) -> Sequence [ \"Model\" ] Main method of the query. Translates select nad prefetch list into dictionaries to avoid querying the same related models multiple times. Keeps the list of already extracted models. Extracts the related models from the database and later populate all children on each of the parent models from list. Arguments : models : list of parent models from main query :type models: List[Model] rows : raw response from sql query :type rows: List[sqlalchemy.engine.result.RowProxy] Returns : list of models with prefetch children populated :rtype: List[Model]","title":"_prefetch_related_models"},{"location":"api/query-set/prefetch-query/#_extract_related_models","text":"1 | async _extract_related_models ( related : str , target_model : Type [ \"Model\" ], prefetch_dict : Dict , select_dict : Dict , excludable : \"ExcludableItems\" , orders_by : Dict ) -> None Constructs queries with required ids and extracts data with fields that should be included/excluded. Runs the queries against the database and populated dictionaries with ids and with actual extracted children models. Calls itself recurrently to extract deeper nested relations of related model. Arguments : related : name of the relation :type related: str target_model : model to which relation leads to :type target_model: Type[Model] prefetch_dict : prefetch related list converted into dictionary :type prefetch_dict: Dict select_dict : select related list converted into dictionary :type select_dict: Dict fields : fields to include :type fields: Union[Set[Any], Dict[Any, Any], None] exclude_fields : fields to exclude :type exclude_fields: Union[Set[Any], Dict[Any, Any], None] orders_by : dictionary of order bys clauses :type orders_by: Dict Returns : None :rtype: None","title":"_extract_related_models"},{"location":"api/query-set/prefetch-query/#_run_prefetch_query","text":"1 | async _run_prefetch_query ( target_field : \"BaseField\" , excludable : \"ExcludableItems\" , filter_clauses : List , related_field_name : str ) -> Tuple [ str , str , List ] Actually runs the queries against the database and populates the raw response for given related model. Returns table prefix as it's later needed to eventually initialize the children models. Arguments : target_field : ormar field with relation definition :type target_field: \"BaseField\" filter_clauses : list of clauses, actually one clause with ids of relation :type filter_clauses: List[sqlalchemy.sql.elements.TextClause] Returns : table prefix and raw rows from sql response :rtype: Tuple[str, List]","title":"_run_prefetch_query"},{"location":"api/query-set/prefetch-query/#_get_select_related_if_apply","text":"1 2 | @staticmethod | _get_select_related_if_apply ( related : str , select_dict : Dict ) -> Dict Extract nested related of select_related dictionary to extract models nested deeper on related model and already loaded in select related query. Arguments : related : name of the relation :type related: str select_dict : dictionary of select related models in main query :type select_dict: Dict Returns : dictionary with nested related of select related :rtype: Dict","title":"_get_select_related_if_apply"},{"location":"api/query-set/prefetch-query/#_update_already_loaded_rows","text":"1 | _update_already_loaded_rows ( target_field : \"BaseField\" , prefetch_dict : Dict , orders_by : Dict ) -> None Updates models that are already loaded, usually children of children. Arguments : target_field : ormar field with relation definition :type target_field: \"BaseField\" prefetch_dict : dictionaries of related models to prefetch :type prefetch_dict: Dict orders_by : dictionary of order by clauses by model :type orders_by: Dict","title":"_update_already_loaded_rows"},{"location":"api/query-set/prefetch-query/#_populate_rows","text":"1 | _populate_rows ( rows : List , target_field : \"ForeignKeyField\" , parent_model : Type [ \"Model\" ], table_prefix : str , exclude_prefix : str , excludable : \"ExcludableItems\" , prefetch_dict : Dict , orders_by : Dict ) -> None Instantiates children models extracted from given relation. Populates them with their own nested children if they are included in prefetch query. Sets the initialized models and ids of them under corresponding keys in already_extracted dictionary. Later those instances will be fetched by ids and set on the parent model after sorting if needed. Arguments : excludable : structure of fields to include and exclude :type excludable: ExcludableItems rows : raw sql response from the prefetch query :type rows: List[sqlalchemy.engine.result.RowProxy] target_field : field with relation definition from parent model :type target_field: \"BaseField\" parent_model : model with relation definition :type parent_model: Type[Model] table_prefix : prefix of the target table from current relation :type table_prefix: str prefetch_dict : dictionaries of related models to prefetch :type prefetch_dict: Dict orders_by : dictionary of order by clauses by model :type orders_by: Dict","title":"_populate_rows"},{"location":"api/query-set/query-set/","text":"queryset.queryset QuerySet Objects 1 class QuerySet ( Generic [ T ]) Main class to perform database queries, exposed on each model as objects attribute. model_meta 1 2 | @property | model_meta () -> \"ModelMeta\" Shortcut to model class Meta set on QuerySet model. Returns : Meta class of the model :rtype: model Meta class model 1 2 | @property | model () -> Type [ \"T\" ] Shortcut to model class set on QuerySet. Returns : model class :rtype: Type[Model] rebuild_self 1 | rebuild_self ( filter_clauses : List = None , exclude_clauses : List = None , select_related : List = None , limit_count : int = None , offset : int = None , excludable : \"ExcludableItems\" = None , order_bys : List = None , prefetch_related : List = None , limit_raw_sql : bool = None , proxy_source_model : Optional [ Type [ \"Model\" ]] = None ) -> \"QuerySet\" Method that returns new instance of queryset based on passed params, all not passed params are taken from current values. _prefetch_related_models 1 | async _prefetch_related_models ( models : List [ \"T\" ], rows : List ) -> List [ \"T\" ] Performs prefetch query for selected models names. Arguments : models : list of already parsed main Models from main query :type models: List[Model] rows : database rows from main query :type rows: List[sqlalchemy.engine.result.RowProxy] Returns : list of models with prefetch models populated :rtype: List[Model] _process_query_result_rows 1 | _process_query_result_rows ( rows : List ) -> List [ \"T\" ] Process database rows and initialize ormar Model from each of the rows. Arguments : rows : list of database rows from query result :type rows: List[sqlalchemy.engine.result.RowProxy] Returns : list of models :rtype: List[Model] _resolve_filter_groups 1 | _resolve_filter_groups ( groups : Any ) -> Tuple [ List [ FilterGroup ], List [ str ]] Resolves filter groups to populate FilterAction params in group tree. Arguments : groups : tuple of FilterGroups :type groups: Any Returns : list of resolver groups :rtype: Tuple[List[FilterGroup], List[str]] check_single_result_rows_count 1 2 | @staticmethod | check_single_result_rows_count ( rows : Sequence [ Optional [ \"T\" ]]) -> None Verifies if the result has one and only one row. Arguments : rows : one element list of Models :type rows: List[Model] database 1 2 | @property | database () -> databases . Database Shortcut to models database from Meta class. Returns : database :rtype: databases.Database table 1 2 | @property | table () -> sqlalchemy . Table Shortcut to models table from Meta class. Returns : database table :rtype: sqlalchemy.Table build_select_expression 1 | build_select_expression ( limit : int = None , offset : int = None , order_bys : List = None ) -> sqlalchemy . sql . select Constructs the actual database query used in the QuerySet. If any of the params is not passed the QuerySet own value is used. Arguments : limit : number to limit the query :type limit: int offset : number to offset by :type offset: int order_bys : list of order-by fields names :type order_bys: List Returns : built sqlalchemy select expression :rtype: sqlalchemy.sql.selectable.Select filter 1 | filter ( * args : Any , * , _exclude : bool = False , ** kwargs : Any ) -> \"QuerySet[T]\" Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) isnull - like album__name__isnull=True (sql is null) (isnotnull album__name__isnull=False (sql is not null)) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (case insensitive) Note that you can also use python style filters - check the docs! Arguments : _exclude : flag if it should be exclude or filter :type _exclude: bool kwargs : fields names and proper value types :type kwargs: Any Returns : filtered QuerySet :rtype: QuerySet exclude 1 | exclude ( * args : Any , ** kwargs : Any ) -> \"QuerySet[T]\" Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which is where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : filtered QuerySet :rtype: QuerySet select_related 1 | select_related ( related : Union [ List , str , FieldAccessor ]) -> \"QuerySet[T]\" Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Arguments : related : list of relation field names, can be linked by '__' to nest :type related: Union[List, str] Returns : QuerySet :rtype: QuerySet select_all 1 | select_all ( follow : bool = False ) -> \"QuerySet[T]\" By default adds only directly related models. If follow=True is set it adds also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -> Model B -> Model C -> Model A -> Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually. Arguments : follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool Returns : reloaded Model :rtype: Model prefetch_related 1 | prefetch_related ( related : Union [ List , str , FieldAccessor ]) -> \"QuerySet[T]\" Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Arguments : related : list of relation field names, can be linked by '__' to nest :type related: Union[List, str] Returns : QuerySet :rtype: QuerySet fields 1 | fields ( columns : Union [ List , str , Set , Dict ], _is_exclude : bool = False ) -> \"QuerySet[T]\" With fields() you can select subset of model columns to limit the data load. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Arguments : _is_exclude : flag if it's exclude or include operation :type _is_exclude: bool columns : columns to include :type columns: Union[List, str, Set, Dict] Returns : QuerySet :rtype: QuerySet exclude_fields 1 | exclude_fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerySet[T]\" With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if explicitly excluded. Arguments : columns : columns to exclude :type columns: Union[List, str, Set, Dict] Returns : QuerySet :rtype: QuerySet order_by 1 | order_by ( columns : Union [ List , str , OrderAction ]) -> \"QuerySet[T]\" With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with fields names. Ordering in sql will be applied in order of names you provide in order_by. By default if you do not provide ordering ormar explicitly orders by all primary keys If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. The main model will never duplicate in the result To order by main model field just provide a field name To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. To sort in descending order provide a hyphen in front of the field name Arguments : columns : columns by which models should be sorted :type columns: Union[List, str] Returns : QuerySet :rtype: QuerySet values 1 | async values ( fields : Union [ List , str , Set , Dict ] = None , exclude_through : bool = False , _as_dict : bool = True , _flatten : bool = False ) -> List Return a list of dictionaries with column values in order of the fields passed or all fields from queried models. To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values. Note that it always return a list even for one row from database. Arguments : exclude_through : flag if through models should be excluded :type exclude_through: bool _flatten : internal parameter to flatten one element tuples :type _flatten: bool _as_dict : internal parameter if return dict or tuples :type _as_dict: bool fields : field name or list of field names to extract from db :type fields: Union[List, str, Set, Dict] values_list 1 | async values_list ( fields : Union [ List , str , Set , Dict ] = None , flatten : bool = False , exclude_through : bool = False ) -> List Return a list of tuples with column values in order of the fields passed or all fields from queried models. When one field is passed you can flatten the list of tuples into list of values of that single field. To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values. Note that it always return a list even for one row from database. Arguments : exclude_through : flag if through models should be excluded :type exclude_through: bool fields : field name or list of field names to extract from db :type fields: Union[str, List[str]] flatten : when one field is passed you can flatten the list of tuples :type flatten: bool exists 1 | async exists () -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude if set). Returns : result of the check :rtype: bool count 1 | async count () -> int Returns number of rows matching the given criteria (applied with filter and exclude if set before). Returns : number of rows :rtype: int max 1 | async max ( columns : Union [ str , List [ str ]]) -> Any Returns max value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : max value of column(s) :rtype: Any min 1 | async min ( columns : Union [ str , List [ str ]]) -> Any Returns min value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : min value of column(s) :rtype: Any sum 1 | async sum ( columns : Union [ str , List [ str ]]) -> Any Returns sum value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : sum value of columns :rtype: int avg 1 | async avg ( columns : Union [ str , List [ str ]]) -> Any Returns avg value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : avg value of columns :rtype: Union[int, float, List] update 1 | async update ( each : bool = False , ** kwargs : Any ) -> int Updates the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each : flag if whole table should be affected if no filter is passed :type each: bool kwargs : fields names and proper value types :type kwargs: Any Returns : number of updated rows :rtype: int delete 1 | async delete ( * args : Any , * , each : bool = False , ** kwargs : Any ) -> int Deletes from the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each : flag if whole table should be affected if no filter is passed :type each: bool kwargs : fields names and proper value types :type kwargs: Any Returns : number of deleted rows :rtype:int paginate 1 | paginate ( page : int , page_size : int = 20 ) -> \"QuerySet[T]\" You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size. Arguments : page_size : numbers of items per page :type page_size: int page : page number :type page: int Returns : QuerySet :rtype: QuerySet limit 1 | limit ( limit_count : int , limit_raw_sql : bool = None ) -> \"QuerySet[T]\" You can limit the results to desired number of parent models. To limit the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . Arguments : limit_raw_sql : flag if raw sql should be limited :type limit_raw_sql: bool limit_count : number of models to limit :type limit_count: int Returns : QuerySet :rtype: QuerySet offset 1 | offset ( offset : int , limit_raw_sql : bool = None ) -> \"QuerySet[T]\" You can also offset the results by desired number of main models. To offset the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . Arguments : limit_raw_sql : flag if raw sql should be offset :type limit_raw_sql: bool offset : numbers of models to offset :type offset: int Returns : QuerySet :rtype: QuerySet first 1 | async first ( * args : Any , ** kwargs : Any ) -> \"T\" Gets the first row from the db ordered by primary key column ascending. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model get_or_none 1 | async get_or_none ( * args : Any , ** kwargs : Any ) -> Optional [ \"T\" ] Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing a criteria is actually calling filter( args, *kwargs) method described below. If not match is found None will be returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model get 1 | async get ( * args : Any , ** kwargs : Any ) -> \"T\" Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing a criteria is actually calling filter( args, *kwargs) method described below. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model get_or_create 1 | async get_or_create ( * args : Any , ** kwargs : Any ) -> \"T\" Combination of create and get methods. Tries to get a row meeting the criteria for kwargs and if NoMatch exception is raised it creates a new one with given kwargs. Passing a criteria is actually calling filter( args, *kwargs) method described below. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned or created Model :rtype: Model update_or_create 1 | async update_or_create ( ** kwargs : Any ) -> \"T\" Updates the model, or in case there is no match in database creates a new one. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : updated or created model :rtype: Model all 1 | async all ( * args : Any , ** kwargs : Any ) -> List [ \"T\" ] Returns all rows from a database for given model for set filter options. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).all() . If there are no rows meeting the criteria an empty list is returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : list of returned models :rtype: List[Model] create 1 | async create ( ** kwargs : Any ) -> \"T\" Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : created model :rtype: Model bulk_create 1 | async bulk_create ( objects : List [ \"T\" ]) -> None Performs a bulk update in one database session to speed up the process. Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. Bulk operations do not send signals. Arguments : objects : list of ormar models already initialized and ready to save. :type objects: List[Model] bulk_update 1 | async bulk_update ( objects : List [ \"T\" ], columns : List [ str ] = None ) -> None Performs bulk update in one database session to speed up the process. Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. Bulk operations do not send signals. Arguments : objects : list of ormar models :type objects: List[Model] columns : list of columns to update :type columns: List[str]","title":"Query Set"},{"location":"api/query-set/query-set/#querysetqueryset","text":"","title":"queryset.queryset"},{"location":"api/query-set/query-set/#queryset-objects","text":"1 class QuerySet ( Generic [ T ]) Main class to perform database queries, exposed on each model as objects attribute.","title":"QuerySet Objects"},{"location":"api/query-set/query-set/#model_meta","text":"1 2 | @property | model_meta () -> \"ModelMeta\" Shortcut to model class Meta set on QuerySet model. Returns : Meta class of the model :rtype: model Meta class","title":"model_meta"},{"location":"api/query-set/query-set/#model","text":"1 2 | @property | model () -> Type [ \"T\" ] Shortcut to model class set on QuerySet. Returns : model class :rtype: Type[Model]","title":"model"},{"location":"api/query-set/query-set/#rebuild_self","text":"1 | rebuild_self ( filter_clauses : List = None , exclude_clauses : List = None , select_related : List = None , limit_count : int = None , offset : int = None , excludable : \"ExcludableItems\" = None , order_bys : List = None , prefetch_related : List = None , limit_raw_sql : bool = None , proxy_source_model : Optional [ Type [ \"Model\" ]] = None ) -> \"QuerySet\" Method that returns new instance of queryset based on passed params, all not passed params are taken from current values.","title":"rebuild_self"},{"location":"api/query-set/query-set/#_prefetch_related_models","text":"1 | async _prefetch_related_models ( models : List [ \"T\" ], rows : List ) -> List [ \"T\" ] Performs prefetch query for selected models names. Arguments : models : list of already parsed main Models from main query :type models: List[Model] rows : database rows from main query :type rows: List[sqlalchemy.engine.result.RowProxy] Returns : list of models with prefetch models populated :rtype: List[Model]","title":"_prefetch_related_models"},{"location":"api/query-set/query-set/#_process_query_result_rows","text":"1 | _process_query_result_rows ( rows : List ) -> List [ \"T\" ] Process database rows and initialize ormar Model from each of the rows. Arguments : rows : list of database rows from query result :type rows: List[sqlalchemy.engine.result.RowProxy] Returns : list of models :rtype: List[Model]","title":"_process_query_result_rows"},{"location":"api/query-set/query-set/#_resolve_filter_groups","text":"1 | _resolve_filter_groups ( groups : Any ) -> Tuple [ List [ FilterGroup ], List [ str ]] Resolves filter groups to populate FilterAction params in group tree. Arguments : groups : tuple of FilterGroups :type groups: Any Returns : list of resolver groups :rtype: Tuple[List[FilterGroup], List[str]]","title":"_resolve_filter_groups"},{"location":"api/query-set/query-set/#check_single_result_rows_count","text":"1 2 | @staticmethod | check_single_result_rows_count ( rows : Sequence [ Optional [ \"T\" ]]) -> None Verifies if the result has one and only one row. Arguments : rows : one element list of Models :type rows: List[Model]","title":"check_single_result_rows_count"},{"location":"api/query-set/query-set/#database","text":"1 2 | @property | database () -> databases . Database Shortcut to models database from Meta class. Returns : database :rtype: databases.Database","title":"database"},{"location":"api/query-set/query-set/#table","text":"1 2 | @property | table () -> sqlalchemy . Table Shortcut to models table from Meta class. Returns : database table :rtype: sqlalchemy.Table","title":"table"},{"location":"api/query-set/query-set/#build_select_expression","text":"1 | build_select_expression ( limit : int = None , offset : int = None , order_bys : List = None ) -> sqlalchemy . sql . select Constructs the actual database query used in the QuerySet. If any of the params is not passed the QuerySet own value is used. Arguments : limit : number to limit the query :type limit: int offset : number to offset by :type offset: int order_bys : list of order-by fields names :type order_bys: List Returns : built sqlalchemy select expression :rtype: sqlalchemy.sql.selectable.Select","title":"build_select_expression"},{"location":"api/query-set/query-set/#filter","text":"1 | filter ( * args : Any , * , _exclude : bool = False , ** kwargs : Any ) -> \"QuerySet[T]\" Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) isnull - like album__name__isnull=True (sql is null) (isnotnull album__name__isnull=False (sql is not null)) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (case insensitive) Note that you can also use python style filters - check the docs! Arguments : _exclude : flag if it should be exclude or filter :type _exclude: bool kwargs : fields names and proper value types :type kwargs: Any Returns : filtered QuerySet :rtype: QuerySet","title":"filter"},{"location":"api/query-set/query-set/#exclude","text":"1 | exclude ( * args : Any , ** kwargs : Any ) -> \"QuerySet[T]\" Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which is where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : filtered QuerySet :rtype: QuerySet","title":"exclude"},{"location":"api/query-set/query-set/#select_related","text":"1 | select_related ( related : Union [ List , str , FieldAccessor ]) -> \"QuerySet[T]\" Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Arguments : related : list of relation field names, can be linked by '__' to nest :type related: Union[List, str] Returns : QuerySet :rtype: QuerySet","title":"select_related"},{"location":"api/query-set/query-set/#select_all","text":"1 | select_all ( follow : bool = False ) -> \"QuerySet[T]\" By default adds only directly related models. If follow=True is set it adds also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -> Model B -> Model C -> Model A -> Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually. Arguments : follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool Returns : reloaded Model :rtype: Model","title":"select_all"},{"location":"api/query-set/query-set/#prefetch_related","text":"1 | prefetch_related ( related : Union [ List , str , FieldAccessor ]) -> \"QuerySet[T]\" Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Arguments : related : list of relation field names, can be linked by '__' to nest :type related: Union[List, str] Returns : QuerySet :rtype: QuerySet","title":"prefetch_related"},{"location":"api/query-set/query-set/#fields","text":"1 | fields ( columns : Union [ List , str , Set , Dict ], _is_exclude : bool = False ) -> \"QuerySet[T]\" With fields() you can select subset of model columns to limit the data load. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Arguments : _is_exclude : flag if it's exclude or include operation :type _is_exclude: bool columns : columns to include :type columns: Union[List, str, Set, Dict] Returns : QuerySet :rtype: QuerySet","title":"fields"},{"location":"api/query-set/query-set/#exclude_fields","text":"1 | exclude_fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerySet[T]\" With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if explicitly excluded. Arguments : columns : columns to exclude :type columns: Union[List, str, Set, Dict] Returns : QuerySet :rtype: QuerySet","title":"exclude_fields"},{"location":"api/query-set/query-set/#order_by","text":"1 | order_by ( columns : Union [ List , str , OrderAction ]) -> \"QuerySet[T]\" With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with fields names. Ordering in sql will be applied in order of names you provide in order_by. By default if you do not provide ordering ormar explicitly orders by all primary keys If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. The main model will never duplicate in the result To order by main model field just provide a field name To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. To sort in descending order provide a hyphen in front of the field name Arguments : columns : columns by which models should be sorted :type columns: Union[List, str] Returns : QuerySet :rtype: QuerySet","title":"order_by"},{"location":"api/query-set/query-set/#values","text":"1 | async values ( fields : Union [ List , str , Set , Dict ] = None , exclude_through : bool = False , _as_dict : bool = True , _flatten : bool = False ) -> List Return a list of dictionaries with column values in order of the fields passed or all fields from queried models. To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values. Note that it always return a list even for one row from database. Arguments : exclude_through : flag if through models should be excluded :type exclude_through: bool _flatten : internal parameter to flatten one element tuples :type _flatten: bool _as_dict : internal parameter if return dict or tuples :type _as_dict: bool fields : field name or list of field names to extract from db :type fields: Union[List, str, Set, Dict]","title":"values"},{"location":"api/query-set/query-set/#values_list","text":"1 | async values_list ( fields : Union [ List , str , Set , Dict ] = None , flatten : bool = False , exclude_through : bool = False ) -> List Return a list of tuples with column values in order of the fields passed or all fields from queried models. When one field is passed you can flatten the list of tuples into list of values of that single field. To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values. Note that it always return a list even for one row from database. Arguments : exclude_through : flag if through models should be excluded :type exclude_through: bool fields : field name or list of field names to extract from db :type fields: Union[str, List[str]] flatten : when one field is passed you can flatten the list of tuples :type flatten: bool","title":"values_list"},{"location":"api/query-set/query-set/#exists","text":"1 | async exists () -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude if set). Returns : result of the check :rtype: bool","title":"exists"},{"location":"api/query-set/query-set/#count","text":"1 | async count () -> int Returns number of rows matching the given criteria (applied with filter and exclude if set before). Returns : number of rows :rtype: int","title":"count"},{"location":"api/query-set/query-set/#max","text":"1 | async max ( columns : Union [ str , List [ str ]]) -> Any Returns max value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : max value of column(s) :rtype: Any","title":"max"},{"location":"api/query-set/query-set/#min","text":"1 | async min ( columns : Union [ str , List [ str ]]) -> Any Returns min value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : min value of column(s) :rtype: Any","title":"min"},{"location":"api/query-set/query-set/#sum","text":"1 | async sum ( columns : Union [ str , List [ str ]]) -> Any Returns sum value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : sum value of columns :rtype: int","title":"sum"},{"location":"api/query-set/query-set/#avg","text":"1 | async avg ( columns : Union [ str , List [ str ]]) -> Any Returns avg value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : avg value of columns :rtype: Union[int, float, List]","title":"avg"},{"location":"api/query-set/query-set/#update","text":"1 | async update ( each : bool = False , ** kwargs : Any ) -> int Updates the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each : flag if whole table should be affected if no filter is passed :type each: bool kwargs : fields names and proper value types :type kwargs: Any Returns : number of updated rows :rtype: int","title":"update"},{"location":"api/query-set/query-set/#delete","text":"1 | async delete ( * args : Any , * , each : bool = False , ** kwargs : Any ) -> int Deletes from the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each : flag if whole table should be affected if no filter is passed :type each: bool kwargs : fields names and proper value types :type kwargs: Any Returns : number of deleted rows :rtype:int","title":"delete"},{"location":"api/query-set/query-set/#paginate","text":"1 | paginate ( page : int , page_size : int = 20 ) -> \"QuerySet[T]\" You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size. Arguments : page_size : numbers of items per page :type page_size: int page : page number :type page: int Returns : QuerySet :rtype: QuerySet","title":"paginate"},{"location":"api/query-set/query-set/#limit","text":"1 | limit ( limit_count : int , limit_raw_sql : bool = None ) -> \"QuerySet[T]\" You can limit the results to desired number of parent models. To limit the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . Arguments : limit_raw_sql : flag if raw sql should be limited :type limit_raw_sql: bool limit_count : number of models to limit :type limit_count: int Returns : QuerySet :rtype: QuerySet","title":"limit"},{"location":"api/query-set/query-set/#offset","text":"1 | offset ( offset : int , limit_raw_sql : bool = None ) -> \"QuerySet[T]\" You can also offset the results by desired number of main models. To offset the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . Arguments : limit_raw_sql : flag if raw sql should be offset :type limit_raw_sql: bool offset : numbers of models to offset :type offset: int Returns : QuerySet :rtype: QuerySet","title":"offset"},{"location":"api/query-set/query-set/#first","text":"1 | async first ( * args : Any , ** kwargs : Any ) -> \"T\" Gets the first row from the db ordered by primary key column ascending. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model","title":"first"},{"location":"api/query-set/query-set/#get_or_none","text":"1 | async get_or_none ( * args : Any , ** kwargs : Any ) -> Optional [ \"T\" ] Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing a criteria is actually calling filter( args, *kwargs) method described below. If not match is found None will be returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model","title":"get_or_none"},{"location":"api/query-set/query-set/#get","text":"1 | async get ( * args : Any , ** kwargs : Any ) -> \"T\" Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing a criteria is actually calling filter( args, *kwargs) method described below. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model","title":"get"},{"location":"api/query-set/query-set/#get_or_create","text":"1 | async get_or_create ( * args : Any , ** kwargs : Any ) -> \"T\" Combination of create and get methods. Tries to get a row meeting the criteria for kwargs and if NoMatch exception is raised it creates a new one with given kwargs. Passing a criteria is actually calling filter( args, *kwargs) method described below. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned or created Model :rtype: Model","title":"get_or_create"},{"location":"api/query-set/query-set/#update_or_create","text":"1 | async update_or_create ( ** kwargs : Any ) -> \"T\" Updates the model, or in case there is no match in database creates a new one. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : updated or created model :rtype: Model","title":"update_or_create"},{"location":"api/query-set/query-set/#all","text":"1 | async all ( * args : Any , ** kwargs : Any ) -> List [ \"T\" ] Returns all rows from a database for given model for set filter options. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).all() . If there are no rows meeting the criteria an empty list is returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : list of returned models :rtype: List[Model]","title":"all"},{"location":"api/query-set/query-set/#create","text":"1 | async create ( ** kwargs : Any ) -> \"T\" Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : created model :rtype: Model","title":"create"},{"location":"api/query-set/query-set/#bulk_create","text":"1 | async bulk_create ( objects : List [ \"T\" ]) -> None Performs a bulk update in one database session to speed up the process. Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. Bulk operations do not send signals. Arguments : objects : list of ormar models already initialized and ready to save. :type objects: List[Model]","title":"bulk_create"},{"location":"api/query-set/query-set/#bulk_update","text":"1 | async bulk_update ( objects : List [ \"T\" ], columns : List [ str ] = None ) -> None Performs bulk update in one database session to speed up the process. Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. Bulk operations do not send signals. Arguments : objects : list of ormar models :type objects: List[Model] columns : list of columns to update :type columns: List[str]","title":"bulk_update"},{"location":"api/query-set/query/","text":"queryset.query Query Objects 1 class Query () _init_sorted_orders 1 | _init_sorted_orders () -> None Initialize empty order_by dict to be populated later during the query call apply_order_bys_for_primary_model 1 | apply_order_bys_for_primary_model () -> None Applies order_by queries on main model when it's used as a subquery. That way the subquery with limit and offset only on main model has proper sorting applied and correct models are fetched. _apply_default_model_sorting 1 | _apply_default_model_sorting () -> None Applies orders_by from model Meta class (if provided), if it was not provided it was filled by metaclass so it's always there and falls back to pk column _pagination_query_required 1 | _pagination_query_required () -> bool Checks if limit or offset are set, the flag limit_sql_raw is not set and query has select_related applied. Otherwise we can limit/offset normally at the end of whole query. Returns : result of the check :rtype: bool build_select_expression 1 | build_select_expression () -> Tuple [ sqlalchemy . sql . select , List [ str ]] Main entry point from outside (after proper initialization). Extracts columns list to fetch, construct all required joins for select related, then applies all conditional and sort clauses. Returns ready to run query with all joins and clauses. Returns : ready to run query with all joins and clauses. :rtype: sqlalchemy.sql.selectable.Select _build_pagination_condition 1 2 3 | _build_pagination_condition () -> Tuple [ | sqlalchemy . sql . expression . TextClause , sqlalchemy . sql . expression . TextClause | ] In order to apply limit and offset on main table in join only (otherwise you can get only partially constructed main model if number of children exceeds the applied limit and select_related is used) Used also to change first and get() without argument behaviour. Needed only if limit or offset are set, the flag limit_sql_raw is not set and query has select_related applied. Otherwise we can limit/offset normally at the end of whole query. The condition is added to filters to filter out desired number of main model primary key values. Whole query is used to determine the values. _apply_expression_modifiers 1 | _apply_expression_modifiers ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Receives the select query (might be join) and applies: * Filter clauses * Exclude filter clauses * Limit clauses * Offset clauses * Order by clauses Returns complete ready to run query. Arguments : expr : select expression before clauses :type expr: sqlalchemy.sql.selectable.Select Returns : expresion with all present clauses applied :rtype: sqlalchemy.sql.selectable.Select _reset_query_parameters 1 | _reset_query_parameters () -> None Although it should be created each time before the call we reset the key params anyway.","title":"Query"},{"location":"api/query-set/query/#querysetquery","text":"","title":"queryset.query"},{"location":"api/query-set/query/#query-objects","text":"1 class Query ()","title":"Query Objects"},{"location":"api/query-set/query/#_init_sorted_orders","text":"1 | _init_sorted_orders () -> None Initialize empty order_by dict to be populated later during the query call","title":"_init_sorted_orders"},{"location":"api/query-set/query/#apply_order_bys_for_primary_model","text":"1 | apply_order_bys_for_primary_model () -> None Applies order_by queries on main model when it's used as a subquery. That way the subquery with limit and offset only on main model has proper sorting applied and correct models are fetched.","title":"apply_order_bys_for_primary_model"},{"location":"api/query-set/query/#_apply_default_model_sorting","text":"1 | _apply_default_model_sorting () -> None Applies orders_by from model Meta class (if provided), if it was not provided it was filled by metaclass so it's always there and falls back to pk column","title":"_apply_default_model_sorting"},{"location":"api/query-set/query/#_pagination_query_required","text":"1 | _pagination_query_required () -> bool Checks if limit or offset are set, the flag limit_sql_raw is not set and query has select_related applied. Otherwise we can limit/offset normally at the end of whole query. Returns : result of the check :rtype: bool","title":"_pagination_query_required"},{"location":"api/query-set/query/#build_select_expression","text":"1 | build_select_expression () -> Tuple [ sqlalchemy . sql . select , List [ str ]] Main entry point from outside (after proper initialization). Extracts columns list to fetch, construct all required joins for select related, then applies all conditional and sort clauses. Returns ready to run query with all joins and clauses. Returns : ready to run query with all joins and clauses. :rtype: sqlalchemy.sql.selectable.Select","title":"build_select_expression"},{"location":"api/query-set/query/#_build_pagination_condition","text":"1 2 3 | _build_pagination_condition () -> Tuple [ | sqlalchemy . sql . expression . TextClause , sqlalchemy . sql . expression . TextClause | ] In order to apply limit and offset on main table in join only (otherwise you can get only partially constructed main model if number of children exceeds the applied limit and select_related is used) Used also to change first and get() without argument behaviour. Needed only if limit or offset are set, the flag limit_sql_raw is not set and query has select_related applied. Otherwise we can limit/offset normally at the end of whole query. The condition is added to filters to filter out desired number of main model primary key values. Whole query is used to determine the values.","title":"_build_pagination_condition"},{"location":"api/query-set/query/#_apply_expression_modifiers","text":"1 | _apply_expression_modifiers ( expr : sqlalchemy . sql . select ) -> sqlalchemy . sql . select Receives the select query (might be join) and applies: * Filter clauses * Exclude filter clauses * Limit clauses * Offset clauses * Order by clauses Returns complete ready to run query. Arguments : expr : select expression before clauses :type expr: sqlalchemy.sql.selectable.Select Returns : expresion with all present clauses applied :rtype: sqlalchemy.sql.selectable.Select","title":"_apply_expression_modifiers"},{"location":"api/query-set/query/#_reset_query_parameters","text":"1 | _reset_query_parameters () -> None Although it should be created each time before the call we reset the key params anyway.","title":"_reset_query_parameters"},{"location":"api/query-set/reverse-alias-resolver/","text":"queryset.reverse_alias_resolver ReverseAliasResolver Objects 1 class ReverseAliasResolver () Class is used to reverse resolve table aliases into relation strings to parse raw data columns and replace table prefixes with full relation string resolve_columns 1 | resolve_columns ( columns_names : List [ str ]) -> Dict Takes raw query prefixed column and resolves the prefixes to relation strings (relation names connected with dunders). Arguments : columns_names : list of column names with prefixes from query :type columns_names: List[str] Returns : dictionary of prefix: resolved names :rtype: Union[None, Dict[str, str]] _resolve_column_with_prefix 1 | _resolve_column_with_prefix ( column_name : str , prefix : str ) -> None Takes the prefixed column, checks if field should be excluded, and if not it proceeds to replace prefix of a table with full relation string. Sample: translates: \"xsd12df_name\" -> into: \"posts__user__name\" Arguments : column_name : prefixed name of the column :type column_name: str prefix : extracted prefix :type prefix: str _check_if_field_is_excluded 1 | _check_if_field_is_excluded ( prefix : str , field : \"ForeignKeyField\" , is_through : bool ) -> bool Checks if given relation is excluded in current query. Note that in contrary to other queryset methods here you can exclude the in-between models but keep the end columns, which does not make sense when parsing the raw data into models. So in relation category -> category_x_post -> post -> user you can exclude category_x_post and post models but can keep the user one. (in ormar model context that is not possible as if you would exclude through and post model there would be no way to reach user model). Exclusions happen on a model before the current one, so we need to move back in chain of model by one or by two (m2m relations have through model in between) Arguments : prefix : table alias :type prefix: str field : field with relation :type field: ForeignKeyField is_through : flag if current table is a through table :type is_through: bool Returns : result of the check :rtype: bool _get_previous_excludable 1 | _get_previous_excludable ( prefix : str , field : \"ForeignKeyField\" , shift : int = 1 ) -> \"Excludable\" Returns excludable related to model previous in chain of models. Used to check if current model should be excluded. Arguments : prefix : prefix of a current table :type prefix: str field : field with relation :type field: ForeignKeyField shift : how many model back to go - for m2m it's 2 due to through models :type shift: int Returns : excludable for previous model :rtype: Excludable _create_prefixes_map 1 | _create_prefixes_map () -> None Creates a map of alias manager aliases keys to relation strings. I.e in alias manager you can have alias user_roles: xas12ad This method will create entry user_roles: roles, where roles is a name of relation on user model. Will also keep the relation field in separate dictionary so we can later extract field names and owner models. _handle_through_fields_and_prefix 1 | _handle_through_fields_and_prefix ( model_cls : Type [ \"Model\" ], field : \"ForeignKeyField\" , previous_related_str : str , relation : str ) -> str Registers through models for m2m relations and switches prefix for the one linking from through model to target model. For other relations returns current model name + relation name as prefix. Nested relations are a chain of relation names with __ in between. Arguments : model_cls : model of current relation :type model_cls: Type[\"Model\"] field : field with relation :type field: ForeignKeyField previous_related_str : concatenated chain linked with \"__\" :type previous_related_str: str relation : name of the current relation in chain :type relation: str Returns : name of prefix to populate :rtype: str","title":"Reverse Alias Resolver"},{"location":"api/query-set/reverse-alias-resolver/#querysetreverse_alias_resolver","text":"","title":"queryset.reverse_alias_resolver"},{"location":"api/query-set/reverse-alias-resolver/#reversealiasresolver-objects","text":"1 class ReverseAliasResolver () Class is used to reverse resolve table aliases into relation strings to parse raw data columns and replace table prefixes with full relation string","title":"ReverseAliasResolver Objects"},{"location":"api/query-set/reverse-alias-resolver/#resolve_columns","text":"1 | resolve_columns ( columns_names : List [ str ]) -> Dict Takes raw query prefixed column and resolves the prefixes to relation strings (relation names connected with dunders). Arguments : columns_names : list of column names with prefixes from query :type columns_names: List[str] Returns : dictionary of prefix: resolved names :rtype: Union[None, Dict[str, str]]","title":"resolve_columns"},{"location":"api/query-set/reverse-alias-resolver/#_resolve_column_with_prefix","text":"1 | _resolve_column_with_prefix ( column_name : str , prefix : str ) -> None Takes the prefixed column, checks if field should be excluded, and if not it proceeds to replace prefix of a table with full relation string. Sample: translates: \"xsd12df_name\" -> into: \"posts__user__name\" Arguments : column_name : prefixed name of the column :type column_name: str prefix : extracted prefix :type prefix: str","title":"_resolve_column_with_prefix"},{"location":"api/query-set/reverse-alias-resolver/#_check_if_field_is_excluded","text":"1 | _check_if_field_is_excluded ( prefix : str , field : \"ForeignKeyField\" , is_through : bool ) -> bool Checks if given relation is excluded in current query. Note that in contrary to other queryset methods here you can exclude the in-between models but keep the end columns, which does not make sense when parsing the raw data into models. So in relation category -> category_x_post -> post -> user you can exclude category_x_post and post models but can keep the user one. (in ormar model context that is not possible as if you would exclude through and post model there would be no way to reach user model). Exclusions happen on a model before the current one, so we need to move back in chain of model by one or by two (m2m relations have through model in between) Arguments : prefix : table alias :type prefix: str field : field with relation :type field: ForeignKeyField is_through : flag if current table is a through table :type is_through: bool Returns : result of the check :rtype: bool","title":"_check_if_field_is_excluded"},{"location":"api/query-set/reverse-alias-resolver/#_get_previous_excludable","text":"1 | _get_previous_excludable ( prefix : str , field : \"ForeignKeyField\" , shift : int = 1 ) -> \"Excludable\" Returns excludable related to model previous in chain of models. Used to check if current model should be excluded. Arguments : prefix : prefix of a current table :type prefix: str field : field with relation :type field: ForeignKeyField shift : how many model back to go - for m2m it's 2 due to through models :type shift: int Returns : excludable for previous model :rtype: Excludable","title":"_get_previous_excludable"},{"location":"api/query-set/reverse-alias-resolver/#_create_prefixes_map","text":"1 | _create_prefixes_map () -> None Creates a map of alias manager aliases keys to relation strings. I.e in alias manager you can have alias user_roles: xas12ad This method will create entry user_roles: roles, where roles is a name of relation on user model. Will also keep the relation field in separate dictionary so we can later extract field names and owner models.","title":"_create_prefixes_map"},{"location":"api/query-set/reverse-alias-resolver/#_handle_through_fields_and_prefix","text":"1 | _handle_through_fields_and_prefix ( model_cls : Type [ \"Model\" ], field : \"ForeignKeyField\" , previous_related_str : str , relation : str ) -> str Registers through models for m2m relations and switches prefix for the one linking from through model to target model. For other relations returns current model name + relation name as prefix. Nested relations are a chain of relation names with __ in between. Arguments : model_cls : model of current relation :type model_cls: Type[\"Model\"] field : field with relation :type field: ForeignKeyField previous_related_str : concatenated chain linked with \"__\" :type previous_related_str: str relation : name of the current relation in chain :type relation: str Returns : name of prefix to populate :rtype: str","title":"_handle_through_fields_and_prefix"},{"location":"api/query-set/utils/","text":"queryset.utils check_node_not_dict_or_not_last_node 1 check_node_not_dict_or_not_last_node ( part : str , is_last : bool , current_level : Any ) -> bool Checks if given name is not present in the current level of the structure. Checks if given name is not the last name in the split list of parts. Checks if the given name in current level is not a dictionary. All those checks verify if there is a need for deeper traversal. Arguments : part : :type part: str parts : :type parts: List[str] current_level : current level of the traversed structure :type current_level: Any Returns : result of the check :rtype: bool translate_list_to_dict 1 translate_list_to_dict ( list_to_trans : Union [ List , Set ], is_order : bool = False ) -> Dict Splits the list of strings by '__' and converts them to dictionary with nested models grouped by parent model. That way each model appears only once in the whole dictionary and children are grouped under parent name. Default required key ise Ellipsis like in pydantic. Arguments : list_to_trans : input list :type list_to_trans: set is_order : flag if change affects order_by clauses are they require special default value with sort order. :type is_order: bool Returns : converted to dictionary input list :rtype: Dict convert_set_to_required_dict 1 convert_set_to_required_dict ( set_to_convert : set ) -> Dict Converts set to dictionary of required keys. Required key is Ellipsis. Arguments : set_to_convert : set to convert to dict :type set_to_convert: set Returns : set converted to dict of ellipsis :rtype: Dict update 1 update ( current_dict : Any , updating_dict : Any ) -> Dict Update one dict with another but with regard for nested keys. That way nested sets are unionised, dicts updated and only other values are overwritten. Arguments : current_dict : dict to update :type current_dict: Dict[str, ellipsis] updating_dict : dict with values to update :type updating_dict: Dict Returns : combination of both dicts :rtype: Dict subtract_dict 1 subtract_dict ( current_dict : Any , updating_dict : Any ) -> Dict Update one dict with another but with regard for nested keys. That way nested sets are unionised, dicts updated and only other values are overwritten. Arguments : current_dict : dict to update :type current_dict: Dict[str, ellipsis] updating_dict : dict with values to update :type updating_dict: Dict Returns : combination of both dicts :rtype: Dict update_dict_from_list 1 update_dict_from_list ( curr_dict : Dict , list_to_update : Union [ List , Set ]) -> Dict Converts the list into dictionary and later performs special update, where nested keys that are sets or dicts are combined and not overwritten. Arguments : curr_dict : dict to update :type curr_dict: Dict list_to_update : list with values to update the dict :type list_to_update: List[str] Returns : updated dict :rtype: Dict extract_nested_models 1 extract_nested_models ( model : \"Model\" , model_type : Type [ \"Model\" ], select_dict : Dict , extracted : Dict ) -> None Iterates over model relations and extracts all nested models from select_dict and puts them in corresponding list under relation name in extracted dict.keys Basically flattens all relation to dictionary of all related models, that can be used on several models and extract all of their children into dictionary of lists witch children models. Goes also into nested relations if needed (specified in select_dict). Arguments : model : parent Model :type model: Model model_type : parent model class :type model_type: Type[Model] select_dict : dictionary of related models from select_related :type select_dict: Dict extracted : dictionary with already extracted models :type extracted: Dict extract_models_to_dict_of_lists 1 extract_models_to_dict_of_lists ( model_type : Type [ \"Model\" ], models : Sequence [ \"Model\" ], select_dict : Dict , extracted : Dict = None ) -> Dict Receives a list of models and extracts all of the children and their children into dictionary of lists with children models, flattening the structure to one dict with all children models under their relation keys. Arguments : model_type : parent model class :type model_type: Type[Model] models : list of models from which related models should be extracted. :type models: List[Model] select_dict : dictionary of related models from select_related :type select_dict: Dict extracted : dictionary with already extracted models :type extracted: Dict Returns : dictionary of lists f related models :rtype: Dict get_relationship_alias_model_and_str 1 get_relationship_alias_model_and_str ( source_model : Type [ \"Model\" ], related_parts : List ) -> Tuple [ str , Type [ \"Model\" ], str , bool ] Walks the relation to retrieve the actual model on which the clause should be constructed, extracts alias based on last relation leading to target model. Arguments : related_parts : list of related names extracted from string :type related_parts: Union[List, List[str]] source_model : model from which relation starts :type source_model: Type[Model] Returns : table prefix, target model and relation string :rtype: Tuple[str, Type[\"Model\"], str] _process_through_field 1 _process_through_field ( related_parts : List , relation : Optional [ str ], related_field : \"BaseField\" , previous_model : Type [ \"Model\" ], previous_models : List [ Type [ \"Model\" ]]) -> Tuple [ Type [ \"Model\" ], Optional [ str ], bool ] Helper processing through models as they need to be treated differently. Arguments : related_parts : split relation string :type related_parts: List[str] relation : relation name :type relation: str related_field : field with relation declaration :type related_field: \"ForeignKeyField\" previous_model : model from which relation is coming :type previous_model: Type[\"Model\"] previous_models : list of already visited models in relation chain :type previous_models: List[Type[\"Model\"]] Returns : previous_model, relation, is_through :rtype: Tuple[Type[\"Model\"], str, bool]","title":"Utils"},{"location":"api/query-set/utils/#querysetutils","text":"","title":"queryset.utils"},{"location":"api/query-set/utils/#check_node_not_dict_or_not_last_node","text":"1 check_node_not_dict_or_not_last_node ( part : str , is_last : bool , current_level : Any ) -> bool Checks if given name is not present in the current level of the structure. Checks if given name is not the last name in the split list of parts. Checks if the given name in current level is not a dictionary. All those checks verify if there is a need for deeper traversal. Arguments : part : :type part: str parts : :type parts: List[str] current_level : current level of the traversed structure :type current_level: Any Returns : result of the check :rtype: bool","title":"check_node_not_dict_or_not_last_node"},{"location":"api/query-set/utils/#translate_list_to_dict","text":"1 translate_list_to_dict ( list_to_trans : Union [ List , Set ], is_order : bool = False ) -> Dict Splits the list of strings by '__' and converts them to dictionary with nested models grouped by parent model. That way each model appears only once in the whole dictionary and children are grouped under parent name. Default required key ise Ellipsis like in pydantic. Arguments : list_to_trans : input list :type list_to_trans: set is_order : flag if change affects order_by clauses are they require special default value with sort order. :type is_order: bool Returns : converted to dictionary input list :rtype: Dict","title":"translate_list_to_dict"},{"location":"api/query-set/utils/#convert_set_to_required_dict","text":"1 convert_set_to_required_dict ( set_to_convert : set ) -> Dict Converts set to dictionary of required keys. Required key is Ellipsis. Arguments : set_to_convert : set to convert to dict :type set_to_convert: set Returns : set converted to dict of ellipsis :rtype: Dict","title":"convert_set_to_required_dict"},{"location":"api/query-set/utils/#update","text":"1 update ( current_dict : Any , updating_dict : Any ) -> Dict Update one dict with another but with regard for nested keys. That way nested sets are unionised, dicts updated and only other values are overwritten. Arguments : current_dict : dict to update :type current_dict: Dict[str, ellipsis] updating_dict : dict with values to update :type updating_dict: Dict Returns : combination of both dicts :rtype: Dict","title":"update"},{"location":"api/query-set/utils/#subtract_dict","text":"1 subtract_dict ( current_dict : Any , updating_dict : Any ) -> Dict Update one dict with another but with regard for nested keys. That way nested sets are unionised, dicts updated and only other values are overwritten. Arguments : current_dict : dict to update :type current_dict: Dict[str, ellipsis] updating_dict : dict with values to update :type updating_dict: Dict Returns : combination of both dicts :rtype: Dict","title":"subtract_dict"},{"location":"api/query-set/utils/#update_dict_from_list","text":"1 update_dict_from_list ( curr_dict : Dict , list_to_update : Union [ List , Set ]) -> Dict Converts the list into dictionary and later performs special update, where nested keys that are sets or dicts are combined and not overwritten. Arguments : curr_dict : dict to update :type curr_dict: Dict list_to_update : list with values to update the dict :type list_to_update: List[str] Returns : updated dict :rtype: Dict","title":"update_dict_from_list"},{"location":"api/query-set/utils/#extract_nested_models","text":"1 extract_nested_models ( model : \"Model\" , model_type : Type [ \"Model\" ], select_dict : Dict , extracted : Dict ) -> None Iterates over model relations and extracts all nested models from select_dict and puts them in corresponding list under relation name in extracted dict.keys Basically flattens all relation to dictionary of all related models, that can be used on several models and extract all of their children into dictionary of lists witch children models. Goes also into nested relations if needed (specified in select_dict). Arguments : model : parent Model :type model: Model model_type : parent model class :type model_type: Type[Model] select_dict : dictionary of related models from select_related :type select_dict: Dict extracted : dictionary with already extracted models :type extracted: Dict","title":"extract_nested_models"},{"location":"api/query-set/utils/#extract_models_to_dict_of_lists","text":"1 extract_models_to_dict_of_lists ( model_type : Type [ \"Model\" ], models : Sequence [ \"Model\" ], select_dict : Dict , extracted : Dict = None ) -> Dict Receives a list of models and extracts all of the children and their children into dictionary of lists with children models, flattening the structure to one dict with all children models under their relation keys. Arguments : model_type : parent model class :type model_type: Type[Model] models : list of models from which related models should be extracted. :type models: List[Model] select_dict : dictionary of related models from select_related :type select_dict: Dict extracted : dictionary with already extracted models :type extracted: Dict Returns : dictionary of lists f related models :rtype: Dict","title":"extract_models_to_dict_of_lists"},{"location":"api/query-set/utils/#get_relationship_alias_model_and_str","text":"1 get_relationship_alias_model_and_str ( source_model : Type [ \"Model\" ], related_parts : List ) -> Tuple [ str , Type [ \"Model\" ], str , bool ] Walks the relation to retrieve the actual model on which the clause should be constructed, extracts alias based on last relation leading to target model. Arguments : related_parts : list of related names extracted from string :type related_parts: Union[List, List[str]] source_model : model from which relation starts :type source_model: Type[Model] Returns : table prefix, target model and relation string :rtype: Tuple[str, Type[\"Model\"], str]","title":"get_relationship_alias_model_and_str"},{"location":"api/query-set/utils/#_process_through_field","text":"1 _process_through_field ( related_parts : List , relation : Optional [ str ], related_field : \"BaseField\" , previous_model : Type [ \"Model\" ], previous_models : List [ Type [ \"Model\" ]]) -> Tuple [ Type [ \"Model\" ], Optional [ str ], bool ] Helper processing through models as they need to be treated differently. Arguments : related_parts : split relation string :type related_parts: List[str] relation : relation name :type relation: str related_field : field with relation declaration :type related_field: \"ForeignKeyField\" previous_model : model from which relation is coming :type previous_model: Type[\"Model\"] previous_models : list of already visited models in relation chain :type previous_models: List[Type[\"Model\"]] Returns : previous_model, relation, is_through :rtype: Tuple[Type[\"Model\"], str, bool]","title":"_process_through_field"},{"location":"api/relations/alias-manager/","text":"relations.alias_manager get_table_alias 1 get_table_alias () -> str Creates a random string that is used to alias tables in joins. It's necessary that each relation has it's own aliases cause you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join. Returns : randomly generated alias :rtype: str AliasManager Objects 1 class AliasManager () Keep all aliases of relations between different tables. One global instance is shared between all models. reversed_aliases 1 2 | @property | reversed_aliases () -> Dict Returns swapped key-value pairs from aliases where alias is the key. Returns : dictionary of prefix to relation :rtype: Dict prefixed_columns 1 2 | @staticmethod | prefixed_columns ( alias : str , table : sqlalchemy . Table , fields : List = None ) -> List [ text ] Creates a list of aliases sqlalchemy text clauses from string alias and sqlalchemy.Table. Optional list of fields to include can be passed to extract only those columns. List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones. Arguments : alias : alias of given table :type alias: str table : table from which fields should be aliased :type table: sqlalchemy.Table fields : fields to include :type fields: Optional[List[str]] Returns : list of sqlalchemy text clauses with \"column name as aliased name\" :rtype: List[text] prefixed_table_name 1 2 | @staticmethod | prefixed_table_name ( alias : str , table : sqlalchemy . Table ) -> text Creates text clause with table name with aliased name. Arguments : alias : alias of given table :type alias: str table : table :type table: sqlalchemy.Table Returns : sqlalchemy text clause as \"table_name aliased_name\" :rtype: sqlalchemy text clause add_relation_type 1 | add_relation_type ( source_model : Type [ \"Model\" ], relation_name : str , reverse_name : str = None ) -> None Registers the relations defined in ormar models. Given the relation it registers also the reverse side of this relation. Used by both ForeignKey and ManyToMany relations. Each relation is registered as Model name and relation name. Each alias registered has to be unique. Aliases are used to construct joins to assure proper links between tables. That way you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join. Arguments : source_model : model with relation defined :type source_model: source Model relation_name : name of the relation to define :type relation_name: str reverse_name : name of related_name fo given relation for m2m relations :type reverse_name: Optional[str] Returns : none :rtype: None add_alias 1 | add_alias ( alias_key : str ) -> str Adds alias to the dictionary of aliases under given key. Arguments : alias_key : key of relation to generate alias for :type alias_key: str Returns : generated alias :rtype: str resolve_relation_alias 1 | resolve_relation_alias ( from_model : Union [ Type [ \"Model\" ], Type [ \"ModelRow\" ]], relation_name : str ) -> str Given model and relation name returns the alias for this relation. Arguments : from_model : model with relation defined :type from_model: source Model relation_name : name of the relation field :type relation_name: str Returns : alias of the relation :rtype: str resolve_relation_alias_after_complex 1 | resolve_relation_alias_after_complex ( source_model : Union [ Type [ \"Model\" ], Type [ \"ModelRow\" ]], relation_str : str , relation_field : \"ForeignKeyField\" ) -> str Given source model and relation string returns the alias for this complex relation if it exists, otherwise fallback to normal relation from a relation field definition. Arguments : relation_field : field with direct relation definition :type relation_field: \"ForeignKeyField\" source_model : model with query starts :type source_model: source Model relation_str : string with relation joins defined :type relation_str: str Returns : alias of the relation :rtype: str","title":"Alias Manager"},{"location":"api/relations/alias-manager/#relationsalias_manager","text":"","title":"relations.alias_manager"},{"location":"api/relations/alias-manager/#get_table_alias","text":"1 get_table_alias () -> str Creates a random string that is used to alias tables in joins. It's necessary that each relation has it's own aliases cause you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join. Returns : randomly generated alias :rtype: str","title":"get_table_alias"},{"location":"api/relations/alias-manager/#aliasmanager-objects","text":"1 class AliasManager () Keep all aliases of relations between different tables. One global instance is shared between all models.","title":"AliasManager Objects"},{"location":"api/relations/alias-manager/#reversed_aliases","text":"1 2 | @property | reversed_aliases () -> Dict Returns swapped key-value pairs from aliases where alias is the key. Returns : dictionary of prefix to relation :rtype: Dict","title":"reversed_aliases"},{"location":"api/relations/alias-manager/#prefixed_columns","text":"1 2 | @staticmethod | prefixed_columns ( alias : str , table : sqlalchemy . Table , fields : List = None ) -> List [ text ] Creates a list of aliases sqlalchemy text clauses from string alias and sqlalchemy.Table. Optional list of fields to include can be passed to extract only those columns. List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones. Arguments : alias : alias of given table :type alias: str table : table from which fields should be aliased :type table: sqlalchemy.Table fields : fields to include :type fields: Optional[List[str]] Returns : list of sqlalchemy text clauses with \"column name as aliased name\" :rtype: List[text]","title":"prefixed_columns"},{"location":"api/relations/alias-manager/#prefixed_table_name","text":"1 2 | @staticmethod | prefixed_table_name ( alias : str , table : sqlalchemy . Table ) -> text Creates text clause with table name with aliased name. Arguments : alias : alias of given table :type alias: str table : table :type table: sqlalchemy.Table Returns : sqlalchemy text clause as \"table_name aliased_name\" :rtype: sqlalchemy text clause","title":"prefixed_table_name"},{"location":"api/relations/alias-manager/#add_relation_type","text":"1 | add_relation_type ( source_model : Type [ \"Model\" ], relation_name : str , reverse_name : str = None ) -> None Registers the relations defined in ormar models. Given the relation it registers also the reverse side of this relation. Used by both ForeignKey and ManyToMany relations. Each relation is registered as Model name and relation name. Each alias registered has to be unique. Aliases are used to construct joins to assure proper links between tables. That way you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join. Arguments : source_model : model with relation defined :type source_model: source Model relation_name : name of the relation to define :type relation_name: str reverse_name : name of related_name fo given relation for m2m relations :type reverse_name: Optional[str] Returns : none :rtype: None","title":"add_relation_type"},{"location":"api/relations/alias-manager/#add_alias","text":"1 | add_alias ( alias_key : str ) -> str Adds alias to the dictionary of aliases under given key. Arguments : alias_key : key of relation to generate alias for :type alias_key: str Returns : generated alias :rtype: str","title":"add_alias"},{"location":"api/relations/alias-manager/#resolve_relation_alias","text":"1 | resolve_relation_alias ( from_model : Union [ Type [ \"Model\" ], Type [ \"ModelRow\" ]], relation_name : str ) -> str Given model and relation name returns the alias for this relation. Arguments : from_model : model with relation defined :type from_model: source Model relation_name : name of the relation field :type relation_name: str Returns : alias of the relation :rtype: str","title":"resolve_relation_alias"},{"location":"api/relations/alias-manager/#resolve_relation_alias_after_complex","text":"1 | resolve_relation_alias_after_complex ( source_model : Union [ Type [ \"Model\" ], Type [ \"ModelRow\" ]], relation_str : str , relation_field : \"ForeignKeyField\" ) -> str Given source model and relation string returns the alias for this complex relation if it exists, otherwise fallback to normal relation from a relation field definition. Arguments : relation_field : field with direct relation definition :type relation_field: \"ForeignKeyField\" source_model : model with query starts :type source_model: source Model relation_str : string with relation joins defined :type relation_str: str Returns : alias of the relation :rtype: str","title":"resolve_relation_alias_after_complex"},{"location":"api/relations/queryset-proxy/","text":"relations.querysetproxy QuerysetProxy Objects 1 class QuerysetProxy ( Generic [ T ]) Exposes QuerySet methods on relations, but also handles creating and removing of through Models for m2m relations. queryset 1 2 | @property | queryset () -> \"QuerySet[T]\" Returns queryset if it's set, AttributeError otherwise. Returns : QuerySet :rtype: QuerySet queryset 1 2 | @queryset . setter | queryset ( value : \"QuerySet\" ) -> None Set's the queryset. Initialized in RelationProxy. Arguments : value : QuerySet :type value: QuerySet _assign_child_to_parent 1 | _assign_child_to_parent ( child : Optional [ \"T\" ]) -> None Registers child in parents RelationManager. Arguments : child : child to register on parent side. :type child: Model _register_related 1 | _register_related ( child : Union [ \"T\" , Sequence [ Optional [ \"T\" ]]]) -> None Registers child/ children in parents RelationManager. Arguments : child : child or list of children models to register. :type child: Union[Model,List[Model]] _clean_items_on_load 1 | _clean_items_on_load () -> None Cleans the current list of the related models. create_through_instance 1 | async create_through_instance ( child : \"T\" , ** kwargs : Any ) -> None Crete a through model instance in the database for m2m relations. Arguments : kwargs : dict of additional keyword arguments for through instance :type kwargs: Any child : child model instance :type child: Model update_through_instance 1 | async update_through_instance ( child : \"T\" , ** kwargs : Any ) -> None Updates a through model instance in the database for m2m relations. Arguments : kwargs : dict of additional keyword arguments for through instance :type kwargs: Any child : child model instance :type child: Model upsert_through_instance 1 | async upsert_through_instance ( child : \"T\" , ** kwargs : Any ) -> None Updates a through model instance in the database for m2m relations if it already exists, else creates one. Arguments : kwargs : dict of additional keyword arguments for through instance :type kwargs: Any child : child model instance :type child: Model delete_through_instance 1 | async delete_through_instance ( child : \"T\" ) -> None Removes through model instance from the database for m2m relations. Arguments : child : child model instance :type child: Model exists 1 | async exists () -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude if set). Actual call delegated to QuerySet. Returns : result of the check :rtype: bool count 1 | async count () -> int Returns number of rows matching the given criteria (applied with filter and exclude if set before). Actual call delegated to QuerySet. Returns : number of rows :rtype: int max 1 | async max ( columns : Union [ str , List [ str ]]) -> Any Returns max value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : max value of column(s) :rtype: Any min 1 | async min ( columns : Union [ str , List [ str ]]) -> Any Returns min value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : min value of column(s) :rtype: Any sum 1 | async sum ( columns : Union [ str , List [ str ]]) -> Any Returns sum value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : sum value of columns :rtype: int avg 1 | async avg ( columns : Union [ str , List [ str ]]) -> Any Returns avg value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : avg value of columns :rtype: Union[int, float, List] clear 1 | async clear ( keep_reversed : bool = True ) -> int Removes all related models from given relation. Removes all through models for m2m relation. For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation). Arguments : keep_reversed : flag if reverse models in reverse FK should be deleted or not, keep_reversed=False deletes them from database. :type keep_reversed: bool Returns : number of deleted models :rtype: int values 1 | async values ( fields : Union [ List , str , Set , Dict ] = None , exclude_through : bool = False ) -> List Return a list of dictionaries with column values in order of the fields passed or all fields from queried models. To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values. Note that it always return a list even for one row from database. Arguments : exclude_through : flag if through models should be excluded :type exclude_through: bool fields : field name or list of field names to extract from db :type fields: Union[List, str, Set, Dict] values_list 1 | async values_list ( fields : Union [ List , str , Set , Dict ] = None , flatten : bool = False , exclude_through : bool = False ) -> List Return a list of tuples with column values in order of the fields passed or all fields from queried models. When one field is passed you can flatten the list of tuples into list of values of that single field. To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values. Note that it always return a list even for one row from database. Arguments : exclude_through : flag if through models should be excluded :type exclude_through: bool fields : field name or list of field names to extract from db :type fields: Union[str, List[str]] flatten : when one field is passed you can flatten the list of tuples :type flatten: bool first 1 | async first ( * args : Any , ** kwargs : Any ) -> \"T\" Gets the first row from the db ordered by primary key column ascending. Actual call delegated to QuerySet. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).first() . List of related models is cleared before the call. Arguments : kwargs : :type kwargs: Returns : :rtype: _asyncio.Future get_or_none 1 | async get_or_none ( * args : Any , ** kwargs : Any ) -> Optional [ \"T\" ] Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).get_or_none() . If not match is found None will be returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model get 1 | async get ( * args : Any , ** kwargs : Any ) -> \"T\" Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).get() . Actual call delegated to QuerySet. List of related models is cleared before the call. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model all 1 | async all ( * args : Any , ** kwargs : Any ) -> List [ \"T\" ] Returns all rows from a database for given model for set filter options. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).all() . If there are no rows meeting the criteria an empty list is returned. Actual call delegated to QuerySet. List of related models is cleared before the call. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : list of returned models :rtype: List[Model] create 1 | async create ( ** kwargs : Any ) -> \"T\" Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. For m2m relation the through model is created automatically. Actual call delegated to QuerySet. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : created model :rtype: Model update 1 | async update ( each : bool = False , ** kwargs : Any ) -> int Updates the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each : flag if whole table should be affected if no filter is passed :type each: bool kwargs : fields names and proper value types :type kwargs: Any Returns : number of updated rows :rtype: int get_or_create 1 | async get_or_create ( * args : Any , ** kwargs : Any ) -> \"T\" Combination of create and get methods. Tries to get a row meeting the criteria fro kwargs and if NoMatch exception is raised it creates a new one with given kwargs. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned or created Model :rtype: Model update_or_create 1 | async update_or_create ( ** kwargs : Any ) -> \"T\" Updates the model, or in case there is no match in database creates a new one. Actual call delegated to QuerySet. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : updated or created model :rtype: Model filter 1 | filter ( * args : Any , ** kwargs : Any ) -> \"QuerysetProxy[T]\" Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) isnull - like album__name__isnull=True (sql is null) (isnotnull album__name__isnull=False (sql is not null)) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (case insensitive) Actual call delegated to QuerySet. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : filtered QuerysetProxy :rtype: QuerysetProxy exclude 1 | exclude ( * args : Any , ** kwargs : Any ) -> \"QuerysetProxy[T]\" Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which is where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) Actual call delegated to QuerySet. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : filtered QuerysetProxy :rtype: QuerysetProxy select_all 1 | select_all ( follow : bool = False ) -> \"QuerysetProxy[T]\" By default adds only directly related models. If follow=True is set it adds also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -> Model B -> Model C -> Model A -> Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually. Arguments : follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool Returns : reloaded Model :rtype: Model select_related 1 | select_related ( related : Union [ List , str ]) -> \"QuerysetProxy[T]\" Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Actual call delegated to QuerySet. Arguments : related : list of relation field names, can be linked by '__' to nest :type related: Union[List, str] Returns : QuerysetProxy :rtype: QuerysetProxy prefetch_related 1 | prefetch_related ( related : Union [ List , str ]) -> \"QuerysetProxy[T]\" Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Actual call delegated to QuerySet. Arguments : related : list of relation field names, can be linked by '__' to nest :type related: Union[List, str] Returns : QuerysetProxy :rtype: QuerysetProxy paginate 1 | paginate ( page : int , page_size : int = 20 ) -> \"QuerysetProxy[T]\" You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size. Actual call delegated to QuerySet. Arguments : page_size : numbers of items per page :type page_size: int page : page number :type page: int Returns : QuerySet :rtype: QuerySet limit 1 | limit ( limit_count : int ) -> \"QuerysetProxy[T]\" You can limit the results to desired number of parent models. Actual call delegated to QuerySet. Arguments : limit_count : number of models to limit :type limit_count: int Returns : QuerysetProxy :rtype: QuerysetProxy offset 1 | offset ( offset : int ) -> \"QuerysetProxy[T]\" You can also offset the results by desired number of main models. Actual call delegated to QuerySet. Arguments : offset : numbers of models to offset :type offset: int Returns : QuerysetProxy :rtype: QuerysetProxy fields 1 | fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerysetProxy[T]\" With fields() you can select subset of model columns to limit the data load. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Actual call delegated to QuerySet. Arguments : columns : columns to include :type columns: Union[List, str, Set, Dict] Returns : QuerysetProxy :rtype: QuerysetProxy exclude_fields 1 | exclude_fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerysetProxy[T]\" With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if explicitly excluded. Actual call delegated to QuerySet. Arguments : columns : columns to exclude :type columns: Union[List, str, Set, Dict] Returns : QuerysetProxy :rtype: QuerysetProxy order_by 1 | order_by ( columns : Union [ List , str , \"OrderAction\" ]) -> \"QuerysetProxy[T]\" With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with fields names. Ordering in sql will be applied in order of names you provide in order_by. By default if you do not provide ordering ormar explicitly orders by all primary keys If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. The main model will never duplicate in the result To order by main model field just provide a field name To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. To sort in descending order provide a hyphen in front of the field name Actual call delegated to QuerySet. Arguments : columns : columns by which models should be sorted :type columns: Union[List, str] Returns : QuerysetProxy :rtype: QuerysetProxy","title":"Queryset Proxy"},{"location":"api/relations/queryset-proxy/#relationsquerysetproxy","text":"","title":"relations.querysetproxy"},{"location":"api/relations/queryset-proxy/#querysetproxy-objects","text":"1 class QuerysetProxy ( Generic [ T ]) Exposes QuerySet methods on relations, but also handles creating and removing of through Models for m2m relations.","title":"QuerysetProxy Objects"},{"location":"api/relations/queryset-proxy/#queryset","text":"1 2 | @property | queryset () -> \"QuerySet[T]\" Returns queryset if it's set, AttributeError otherwise. Returns : QuerySet :rtype: QuerySet","title":"queryset"},{"location":"api/relations/queryset-proxy/#queryset_1","text":"1 2 | @queryset . setter | queryset ( value : \"QuerySet\" ) -> None Set's the queryset. Initialized in RelationProxy. Arguments : value : QuerySet :type value: QuerySet","title":"queryset"},{"location":"api/relations/queryset-proxy/#_assign_child_to_parent","text":"1 | _assign_child_to_parent ( child : Optional [ \"T\" ]) -> None Registers child in parents RelationManager. Arguments : child : child to register on parent side. :type child: Model","title":"_assign_child_to_parent"},{"location":"api/relations/queryset-proxy/#_register_related","text":"1 | _register_related ( child : Union [ \"T\" , Sequence [ Optional [ \"T\" ]]]) -> None Registers child/ children in parents RelationManager. Arguments : child : child or list of children models to register. :type child: Union[Model,List[Model]]","title":"_register_related"},{"location":"api/relations/queryset-proxy/#_clean_items_on_load","text":"1 | _clean_items_on_load () -> None Cleans the current list of the related models.","title":"_clean_items_on_load"},{"location":"api/relations/queryset-proxy/#create_through_instance","text":"1 | async create_through_instance ( child : \"T\" , ** kwargs : Any ) -> None Crete a through model instance in the database for m2m relations. Arguments : kwargs : dict of additional keyword arguments for through instance :type kwargs: Any child : child model instance :type child: Model","title":"create_through_instance"},{"location":"api/relations/queryset-proxy/#update_through_instance","text":"1 | async update_through_instance ( child : \"T\" , ** kwargs : Any ) -> None Updates a through model instance in the database for m2m relations. Arguments : kwargs : dict of additional keyword arguments for through instance :type kwargs: Any child : child model instance :type child: Model","title":"update_through_instance"},{"location":"api/relations/queryset-proxy/#upsert_through_instance","text":"1 | async upsert_through_instance ( child : \"T\" , ** kwargs : Any ) -> None Updates a through model instance in the database for m2m relations if it already exists, else creates one. Arguments : kwargs : dict of additional keyword arguments for through instance :type kwargs: Any child : child model instance :type child: Model","title":"upsert_through_instance"},{"location":"api/relations/queryset-proxy/#delete_through_instance","text":"1 | async delete_through_instance ( child : \"T\" ) -> None Removes through model instance from the database for m2m relations. Arguments : child : child model instance :type child: Model","title":"delete_through_instance"},{"location":"api/relations/queryset-proxy/#exists","text":"1 | async exists () -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude if set). Actual call delegated to QuerySet. Returns : result of the check :rtype: bool","title":"exists"},{"location":"api/relations/queryset-proxy/#count","text":"1 | async count () -> int Returns number of rows matching the given criteria (applied with filter and exclude if set before). Actual call delegated to QuerySet. Returns : number of rows :rtype: int","title":"count"},{"location":"api/relations/queryset-proxy/#max","text":"1 | async max ( columns : Union [ str , List [ str ]]) -> Any Returns max value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : max value of column(s) :rtype: Any","title":"max"},{"location":"api/relations/queryset-proxy/#min","text":"1 | async min ( columns : Union [ str , List [ str ]]) -> Any Returns min value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : min value of column(s) :rtype: Any","title":"min"},{"location":"api/relations/queryset-proxy/#sum","text":"1 | async sum ( columns : Union [ str , List [ str ]]) -> Any Returns sum value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : sum value of columns :rtype: int","title":"sum"},{"location":"api/relations/queryset-proxy/#avg","text":"1 | async avg ( columns : Union [ str , List [ str ]]) -> Any Returns avg value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns : avg value of columns :rtype: Union[int, float, List]","title":"avg"},{"location":"api/relations/queryset-proxy/#clear","text":"1 | async clear ( keep_reversed : bool = True ) -> int Removes all related models from given relation. Removes all through models for m2m relation. For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation). Arguments : keep_reversed : flag if reverse models in reverse FK should be deleted or not, keep_reversed=False deletes them from database. :type keep_reversed: bool Returns : number of deleted models :rtype: int","title":"clear"},{"location":"api/relations/queryset-proxy/#values","text":"1 | async values ( fields : Union [ List , str , Set , Dict ] = None , exclude_through : bool = False ) -> List Return a list of dictionaries with column values in order of the fields passed or all fields from queried models. To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values. Note that it always return a list even for one row from database. Arguments : exclude_through : flag if through models should be excluded :type exclude_through: bool fields : field name or list of field names to extract from db :type fields: Union[List, str, Set, Dict]","title":"values"},{"location":"api/relations/queryset-proxy/#values_list","text":"1 | async values_list ( fields : Union [ List , str , Set , Dict ] = None , flatten : bool = False , exclude_through : bool = False ) -> List Return a list of tuples with column values in order of the fields passed or all fields from queried models. When one field is passed you can flatten the list of tuples into list of values of that single field. To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values. Note that it always return a list even for one row from database. Arguments : exclude_through : flag if through models should be excluded :type exclude_through: bool fields : field name or list of field names to extract from db :type fields: Union[str, List[str]] flatten : when one field is passed you can flatten the list of tuples :type flatten: bool","title":"values_list"},{"location":"api/relations/queryset-proxy/#first","text":"1 | async first ( * args : Any , ** kwargs : Any ) -> \"T\" Gets the first row from the db ordered by primary key column ascending. Actual call delegated to QuerySet. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).first() . List of related models is cleared before the call. Arguments : kwargs : :type kwargs: Returns : :rtype: _asyncio.Future","title":"first"},{"location":"api/relations/queryset-proxy/#get_or_none","text":"1 | async get_or_none ( * args : Any , ** kwargs : Any ) -> Optional [ \"T\" ] Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).get_or_none() . If not match is found None will be returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model","title":"get_or_none"},{"location":"api/relations/queryset-proxy/#get","text":"1 | async get ( * args : Any , ** kwargs : Any ) -> \"T\" Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).get() . Actual call delegated to QuerySet. List of related models is cleared before the call. Raises : NoMatch : if no rows are returned MultipleMatches : if more than 1 row is returned. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned model :rtype: Model","title":"get"},{"location":"api/relations/queryset-proxy/#all","text":"1 | async all ( * args : Any , ** kwargs : Any ) -> List [ \"T\" ] Returns all rows from a database for given model for set filter options. Passing args and/or kwargs is a shortcut and equals to calling filter(*args, **kwargs).all() . If there are no rows meeting the criteria an empty list is returned. Actual call delegated to QuerySet. List of related models is cleared before the call. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : list of returned models :rtype: List[Model]","title":"all"},{"location":"api/relations/queryset-proxy/#create","text":"1 | async create ( ** kwargs : Any ) -> \"T\" Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. For m2m relation the through model is created automatically. Actual call delegated to QuerySet. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : created model :rtype: Model","title":"create"},{"location":"api/relations/queryset-proxy/#update","text":"1 | async update ( each : bool = False , ** kwargs : Any ) -> int Updates the model table after applying the filters from kwargs. You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table. Arguments : each : flag if whole table should be affected if no filter is passed :type each: bool kwargs : fields names and proper value types :type kwargs: Any Returns : number of updated rows :rtype: int","title":"update"},{"location":"api/relations/queryset-proxy/#get_or_create","text":"1 | async get_or_create ( * args : Any , ** kwargs : Any ) -> \"T\" Combination of create and get methods. Tries to get a row meeting the criteria fro kwargs and if NoMatch exception is raised it creates a new one with given kwargs. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : returned or created Model :rtype: Model","title":"get_or_create"},{"location":"api/relations/queryset-proxy/#update_or_create","text":"1 | async update_or_create ( ** kwargs : Any ) -> \"T\" Updates the model, or in case there is no match in database creates a new one. Actual call delegated to QuerySet. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : updated or created model :rtype: Model","title":"update_or_create"},{"location":"api/relations/queryset-proxy/#filter","text":"1 | filter ( * args : Any , ** kwargs : Any ) -> \"QuerysetProxy[T]\" Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) isnull - like album__name__isnull=True (sql is null) (isnotnull album__name__isnull=False (sql is not null)) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (case insensitive) Actual call delegated to QuerySet. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : filtered QuerysetProxy :rtype: QuerysetProxy","title":"filter"},{"location":"api/relations/queryset-proxy/#exclude","text":"1 | exclude ( * args : Any , ** kwargs : Any ) -> \"QuerysetProxy[T]\" Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which is where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) Actual call delegated to QuerySet. Arguments : kwargs : fields names and proper value types :type kwargs: Any Returns : filtered QuerysetProxy :rtype: QuerysetProxy","title":"exclude"},{"location":"api/relations/queryset-proxy/#select_all","text":"1 | select_all ( follow : bool = False ) -> \"QuerysetProxy[T]\" By default adds only directly related models. If follow=True is set it adds also related models of related models. To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -> Model B -> Model C -> Model A -> Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually. Arguments : follow : flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool Returns : reloaded Model :rtype: Model","title":"select_all"},{"location":"api/relations/queryset-proxy/#select_related","text":"1 | select_related ( related : Union [ List , str ]) -> \"QuerysetProxy[T]\" Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Actual call delegated to QuerySet. Arguments : related : list of relation field names, can be linked by '__' to nest :type related: Union[List, str] Returns : QuerysetProxy :rtype: QuerysetProxy","title":"select_related"},{"location":"api/relations/queryset-proxy/#prefetch_related","text":"1 | prefetch_related ( related : Union [ List , str ]) -> \"QuerysetProxy[T]\" Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Actual call delegated to QuerySet. Arguments : related : list of relation field names, can be linked by '__' to nest :type related: Union[List, str] Returns : QuerysetProxy :rtype: QuerysetProxy","title":"prefetch_related"},{"location":"api/relations/queryset-proxy/#paginate","text":"1 | paginate ( page : int , page_size : int = 20 ) -> \"QuerysetProxy[T]\" You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size. Actual call delegated to QuerySet. Arguments : page_size : numbers of items per page :type page_size: int page : page number :type page: int Returns : QuerySet :rtype: QuerySet","title":"paginate"},{"location":"api/relations/queryset-proxy/#limit","text":"1 | limit ( limit_count : int ) -> \"QuerysetProxy[T]\" You can limit the results to desired number of parent models. Actual call delegated to QuerySet. Arguments : limit_count : number of models to limit :type limit_count: int Returns : QuerysetProxy :rtype: QuerysetProxy","title":"limit"},{"location":"api/relations/queryset-proxy/#offset","text":"1 | offset ( offset : int ) -> \"QuerysetProxy[T]\" You can also offset the results by desired number of main models. Actual call delegated to QuerySet. Arguments : offset : numbers of models to offset :type offset: int Returns : QuerysetProxy :rtype: QuerysetProxy","title":"offset"},{"location":"api/relations/queryset-proxy/#fields","text":"1 | fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerysetProxy[T]\" With fields() you can select subset of model columns to limit the data load. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Actual call delegated to QuerySet. Arguments : columns : columns to include :type columns: Union[List, str, Set, Dict] Returns : QuerysetProxy :rtype: QuerysetProxy","title":"fields"},{"location":"api/relations/queryset-proxy/#exclude_fields","text":"1 | exclude_fields ( columns : Union [ List , str , Set , Dict ]) -> \"QuerysetProxy[T]\" With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Pk column cannot be excluded - it's always auto added even if explicitly excluded. Actual call delegated to QuerySet. Arguments : columns : columns to exclude :type columns: Union[List, str, Set, Dict] Returns : QuerysetProxy :rtype: QuerysetProxy","title":"exclude_fields"},{"location":"api/relations/queryset-proxy/#order_by","text":"1 | order_by ( columns : Union [ List , str , \"OrderAction\" ]) -> \"QuerysetProxy[T]\" With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with fields names. Ordering in sql will be applied in order of names you provide in order_by. By default if you do not provide ordering ormar explicitly orders by all primary keys If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. The main model will never duplicate in the result To order by main model field just provide a field name To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. To sort in descending order provide a hyphen in front of the field name Actual call delegated to QuerySet. Arguments : columns : columns by which models should be sorted :type columns: Union[List, str] Returns : QuerysetProxy :rtype: QuerysetProxy","title":"order_by"},{"location":"api/relations/relation-manager/","text":"relations.relation_manager RelationsManager Objects 1 class RelationsManager () Manages relations on a Model, each Model has it's own instance. __contains__ 1 | __contains__ ( item : str ) -> bool Checks if relation with given name is already registered. Arguments : item : name of attribute :type item: str Returns : result of the check :rtype: bool get 1 | get ( name : str ) -> Optional [ Union [ \"Model\" , Sequence [ \"Model\" ]]] Returns the related model/models if relation is set. Actual call is delegated to Relation instance registered under relation name. Arguments : name : name of the relation :type name: str Returns : related model or list of related models if set :rtype: Optional[Union[Model, List[Model]] add 1 2 | @staticmethod | add ( parent : \"Model\" , child : \"Model\" , field : \"ForeignKeyField\" ) -> None Adds relation on both sides -> meaning on both child and parent models. One side of the relation is always weakref proxy to avoid circular refs. Based on the side from which relation is added and relation name actual names of parent and child relations are established. The related models are registered on both ends. Arguments : parent : parent model on which relation should be registered :type parent: Model child : child model to register :type child: Model field : field with relation definition :type field: ForeignKeyField remove 1 | remove ( name : str , child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> None Removes given child from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the child. Arguments : name : name of the relation :type name: str child : child to remove from relation :type child: Union[Model, Type[Model]] remove_parent 1 2 | @staticmethod | remove_parent ( item : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]], parent : \"Model\" , name : str ) -> None Removes given parent from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the parent. Arguments : item : model with parent registered :type item: Union[Model, Type[Model]] parent : parent Model :type parent: Model name : name of the relation :type name: str _get 1 | _get ( name : str ) -> Optional [ Relation ] Returns the actual relation and not the related model(s). Arguments : name : name of the relation :type name: str Returns : Relation instance :rtype: ormar.relations.relation.Relation _get_relation_type 1 | _get_relation_type ( field : \"BaseField\" ) -> RelationType Returns type of the relation declared on a field. Arguments : field : field with relation declaration :type field: BaseField Returns : type of the relation defined on field :rtype: RelationType _add_relation 1 | _add_relation ( field : \"BaseField\" ) -> None Registers relation in the manager. Adds Relation instance under field.name. Arguments : field : field with relation declaration :type field: BaseField","title":"Relation Manager"},{"location":"api/relations/relation-manager/#relationsrelation_manager","text":"","title":"relations.relation_manager"},{"location":"api/relations/relation-manager/#relationsmanager-objects","text":"1 class RelationsManager () Manages relations on a Model, each Model has it's own instance.","title":"RelationsManager Objects"},{"location":"api/relations/relation-manager/#__contains__","text":"1 | __contains__ ( item : str ) -> bool Checks if relation with given name is already registered. Arguments : item : name of attribute :type item: str Returns : result of the check :rtype: bool","title":"__contains__"},{"location":"api/relations/relation-manager/#get","text":"1 | get ( name : str ) -> Optional [ Union [ \"Model\" , Sequence [ \"Model\" ]]] Returns the related model/models if relation is set. Actual call is delegated to Relation instance registered under relation name. Arguments : name : name of the relation :type name: str Returns : related model or list of related models if set :rtype: Optional[Union[Model, List[Model]]","title":"get"},{"location":"api/relations/relation-manager/#add","text":"1 2 | @staticmethod | add ( parent : \"Model\" , child : \"Model\" , field : \"ForeignKeyField\" ) -> None Adds relation on both sides -> meaning on both child and parent models. One side of the relation is always weakref proxy to avoid circular refs. Based on the side from which relation is added and relation name actual names of parent and child relations are established. The related models are registered on both ends. Arguments : parent : parent model on which relation should be registered :type parent: Model child : child model to register :type child: Model field : field with relation definition :type field: ForeignKeyField","title":"add"},{"location":"api/relations/relation-manager/#remove","text":"1 | remove ( name : str , child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> None Removes given child from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the child. Arguments : name : name of the relation :type name: str child : child to remove from relation :type child: Union[Model, Type[Model]]","title":"remove"},{"location":"api/relations/relation-manager/#remove_parent","text":"1 2 | @staticmethod | remove_parent ( item : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]], parent : \"Model\" , name : str ) -> None Removes given parent from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the parent. Arguments : item : model with parent registered :type item: Union[Model, Type[Model]] parent : parent Model :type parent: Model name : name of the relation :type name: str","title":"remove_parent"},{"location":"api/relations/relation-manager/#_get","text":"1 | _get ( name : str ) -> Optional [ Relation ] Returns the actual relation and not the related model(s). Arguments : name : name of the relation :type name: str Returns : Relation instance :rtype: ormar.relations.relation.Relation","title":"_get"},{"location":"api/relations/relation-manager/#_get_relation_type","text":"1 | _get_relation_type ( field : \"BaseField\" ) -> RelationType Returns type of the relation declared on a field. Arguments : field : field with relation declaration :type field: BaseField Returns : type of the relation defined on field :rtype: RelationType","title":"_get_relation_type"},{"location":"api/relations/relation-manager/#_add_relation","text":"1 | _add_relation ( field : \"BaseField\" ) -> None Registers relation in the manager. Adds Relation instance under field.name. Arguments : field : field with relation declaration :type field: BaseField","title":"_add_relation"},{"location":"api/relations/relation-proxy/","text":"relations.relation_proxy RelationProxy Objects 1 class RelationProxy ( Generic [ T ], list ) Proxy of the Relation that is a list with special methods. related_field_name 1 2 | @property | related_field_name () -> str On first access calculates the name of the related field, later stored in _related_field_name property. Returns : name of the related field :rtype: str __getattribute__ 1 | __getattribute__ ( item : str ) -> Any Since some QuerySetProxy methods overwrite builtin list methods we catch calls to them and delegate it to QuerySetProxy instead. Arguments : item : name of attribute :type item: str Returns : value of attribute :rtype: Any __getattr__ 1 | __getattr__ ( item : str ) -> Any Delegates calls for non existing attributes to QuerySetProxy. Arguments : item : name of attribute/method :type item: str Returns : method from QuerySetProxy if exists :rtype: method _initialize_queryset 1 | _initialize_queryset () -> None Initializes the QuerySetProxy if not yet initialized. _check_if_queryset_is_initialized 1 | _check_if_queryset_is_initialized () -> bool Checks if the QuerySetProxy is already set and ready. Returns : result of the check :rtype: bool _check_if_model_saved 1 | _check_if_model_saved () -> None Verifies if the parent model of the relation has been already saved. Otherwise QuerySetProxy cannot filter by parent primary key. _set_queryset 1 | _set_queryset () -> \"QuerySet[T]\" Creates new QuerySet with relation model and pre filters it with currents parent model primary key, so all queries by definition are already related to the parent model only, without need for user to filter them. Returns : initialized QuerySet :rtype: QuerySet remove 1 | async remove ( item : \"T\" , keep_reversed : bool = True ) -> None Removes the related from relation with parent. Through models are automatically deleted for m2m relations. For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation). Arguments : item : child to remove from relation :type item: Model keep_reversed : flag if the reversed model should be kept or deleted too :type keep_reversed: bool add 1 | async add ( item : \"T\" , ** kwargs : Any ) -> None Adds child model to relation. For ManyToMany relations through instance is automatically created. Arguments : kwargs : dict of additional keyword arguments for through instance :type kwargs: Any item : child to add to relation :type item: Model","title":"Relation Proxy"},{"location":"api/relations/relation-proxy/#relationsrelation_proxy","text":"","title":"relations.relation_proxy"},{"location":"api/relations/relation-proxy/#relationproxy-objects","text":"1 class RelationProxy ( Generic [ T ], list ) Proxy of the Relation that is a list with special methods.","title":"RelationProxy Objects"},{"location":"api/relations/relation-proxy/#related_field_name","text":"1 2 | @property | related_field_name () -> str On first access calculates the name of the related field, later stored in _related_field_name property. Returns : name of the related field :rtype: str","title":"related_field_name"},{"location":"api/relations/relation-proxy/#__getattribute__","text":"1 | __getattribute__ ( item : str ) -> Any Since some QuerySetProxy methods overwrite builtin list methods we catch calls to them and delegate it to QuerySetProxy instead. Arguments : item : name of attribute :type item: str Returns : value of attribute :rtype: Any","title":"__getattribute__"},{"location":"api/relations/relation-proxy/#__getattr__","text":"1 | __getattr__ ( item : str ) -> Any Delegates calls for non existing attributes to QuerySetProxy. Arguments : item : name of attribute/method :type item: str Returns : method from QuerySetProxy if exists :rtype: method","title":"__getattr__"},{"location":"api/relations/relation-proxy/#_initialize_queryset","text":"1 | _initialize_queryset () -> None Initializes the QuerySetProxy if not yet initialized.","title":"_initialize_queryset"},{"location":"api/relations/relation-proxy/#_check_if_queryset_is_initialized","text":"1 | _check_if_queryset_is_initialized () -> bool Checks if the QuerySetProxy is already set and ready. Returns : result of the check :rtype: bool","title":"_check_if_queryset_is_initialized"},{"location":"api/relations/relation-proxy/#_check_if_model_saved","text":"1 | _check_if_model_saved () -> None Verifies if the parent model of the relation has been already saved. Otherwise QuerySetProxy cannot filter by parent primary key.","title":"_check_if_model_saved"},{"location":"api/relations/relation-proxy/#_set_queryset","text":"1 | _set_queryset () -> \"QuerySet[T]\" Creates new QuerySet with relation model and pre filters it with currents parent model primary key, so all queries by definition are already related to the parent model only, without need for user to filter them. Returns : initialized QuerySet :rtype: QuerySet","title":"_set_queryset"},{"location":"api/relations/relation-proxy/#remove","text":"1 | async remove ( item : \"T\" , keep_reversed : bool = True ) -> None Removes the related from relation with parent. Through models are automatically deleted for m2m relations. For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation). Arguments : item : child to remove from relation :type item: Model keep_reversed : flag if the reversed model should be kept or deleted too :type keep_reversed: bool","title":"remove"},{"location":"api/relations/relation-proxy/#add","text":"1 | async add ( item : \"T\" , ** kwargs : Any ) -> None Adds child model to relation. For ManyToMany relations through instance is automatically created. Arguments : kwargs : dict of additional keyword arguments for through instance :type kwargs: Any item : child to add to relation :type item: Model","title":"add"},{"location":"api/relations/relation/","text":"relations.relation RelationType Objects 1 class RelationType ( Enum ) Different types of relations supported by ormar: ForeignKey = PRIMARY reverse ForeignKey = REVERSE ManyToMany = MULTIPLE Relation Objects 1 class Relation ( Generic [ T ]) Keeps related Models and handles adding/removing of the children. __init__ 1 | __init__ ( manager : \"RelationsManager\" , type_ : RelationType , field_name : str , to : Type [ \"T\" ], through : Type [ \"Model\" ] = None ) -> None Initialize the Relation and keep the related models either as instances of passed Model, or as a RelationProxy which is basically a list of models with some special behavior, as it exposes QuerySetProxy and allows querying the related models already pre filtered by parent model. Arguments : manager : reference to relation manager :type manager: RelationsManager type_ : type of the relation :type type_: RelationType field_name : name of the relation field :type field_name: str to : model to which relation leads to :type to: Type[Model] through : model through which relation goes for m2m relations :type through: Type[Model] _clean_related 1 | _clean_related () -> None Removes dead weakrefs from RelationProxy. _find_existing 1 | _find_existing ( child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> Optional [ int ] Find child model in RelationProxy if exists. Arguments : child : child model to find :type child: Model Returns : index of child in RelationProxy :rtype: Optional[ind] add 1 | add ( child : \"Model\" ) -> None Adds child Model to relation, either sets child as related model or adds it to the list in RelationProxy depending on relation type. Arguments : child : model to add to relation :type child: Model remove 1 | remove ( child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> None Removes child Model from relation, either sets None as related model or removes it from the list in RelationProxy depending on relation type. Arguments : child : model to remove from relation :type child: Model get 1 | get () -> Optional [ Union [ List [ \"Model\" ], \"Model\" ]] Return the related model or models from RelationProxy. Returns : related model/models if set :rtype: Optional[Union[List[Model], Model]]","title":"Relation"},{"location":"api/relations/relation/#relationsrelation","text":"","title":"relations.relation"},{"location":"api/relations/relation/#relationtype-objects","text":"1 class RelationType ( Enum ) Different types of relations supported by ormar: ForeignKey = PRIMARY reverse ForeignKey = REVERSE ManyToMany = MULTIPLE","title":"RelationType Objects"},{"location":"api/relations/relation/#relation-objects","text":"1 class Relation ( Generic [ T ]) Keeps related Models and handles adding/removing of the children.","title":"Relation Objects"},{"location":"api/relations/relation/#__init__","text":"1 | __init__ ( manager : \"RelationsManager\" , type_ : RelationType , field_name : str , to : Type [ \"T\" ], through : Type [ \"Model\" ] = None ) -> None Initialize the Relation and keep the related models either as instances of passed Model, or as a RelationProxy which is basically a list of models with some special behavior, as it exposes QuerySetProxy and allows querying the related models already pre filtered by parent model. Arguments : manager : reference to relation manager :type manager: RelationsManager type_ : type of the relation :type type_: RelationType field_name : name of the relation field :type field_name: str to : model to which relation leads to :type to: Type[Model] through : model through which relation goes for m2m relations :type through: Type[Model]","title":"__init__"},{"location":"api/relations/relation/#_clean_related","text":"1 | _clean_related () -> None Removes dead weakrefs from RelationProxy.","title":"_clean_related"},{"location":"api/relations/relation/#_find_existing","text":"1 | _find_existing ( child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> Optional [ int ] Find child model in RelationProxy if exists. Arguments : child : child model to find :type child: Model Returns : index of child in RelationProxy :rtype: Optional[ind]","title":"_find_existing"},{"location":"api/relations/relation/#add","text":"1 | add ( child : \"Model\" ) -> None Adds child Model to relation, either sets child as related model or adds it to the list in RelationProxy depending on relation type. Arguments : child : model to add to relation :type child: Model","title":"add"},{"location":"api/relations/relation/#remove","text":"1 | remove ( child : Union [ \"NewBaseModel\" , Type [ \"NewBaseModel\" ]]) -> None Removes child Model from relation, either sets None as related model or removes it from the list in RelationProxy depending on relation type. Arguments : child : model to remove from relation :type child: Model","title":"remove"},{"location":"api/relations/relation/#get","text":"1 | get () -> Optional [ Union [ List [ \"Model\" ], \"Model\" ]] Return the related model or models from RelationProxy. Returns : related model/models if set :rtype: Optional[Union[List[Model], Model]]","title":"get"},{"location":"api/relations/utils/","text":"relations.utils get_relations_sides_and_names 1 get_relations_sides_and_names ( to_field : ForeignKeyField , parent : \"Model\" , child : \"Model\" ) -> Tuple [ \"Model\" , \"Model\" , str , str ] Determines the names of child and parent relations names, as well as changes one of the sides of the relation into weakref.proxy to model. Arguments : to_field : field with relation definition :type to_field: ForeignKeyField parent : parent model :type parent: Model child : child model :type child: Model Returns : parent, child, child_name, to_name :rtype: Tuple[\"Model\", \"Model\", str, str]","title":"Utils"},{"location":"api/relations/utils/#relationsutils","text":"","title":"relations.utils"},{"location":"api/relations/utils/#get_relations_sides_and_names","text":"1 get_relations_sides_and_names ( to_field : ForeignKeyField , parent : \"Model\" , child : \"Model\" ) -> Tuple [ \"Model\" , \"Model\" , str , str ] Determines the names of child and parent relations names, as well as changes one of the sides of the relation into weakref.proxy to model. Arguments : to_field : field with relation definition :type to_field: ForeignKeyField parent : parent model :type parent: Model child : child model :type child: Model Returns : parent, child, child_name, to_name :rtype: Tuple[\"Model\", \"Model\", str, str]","title":"get_relations_sides_and_names"},{"location":"api/signals/decorators/","text":"decorators.signals receiver 1 receiver ( signal : str , senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for given signal name. Arguments : signal : name of the signal to register to :type signal: str senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable post_save 1 post_save ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_save signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable post_update 1 post_update ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_update signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable post_delete 1 post_delete ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_delete signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable pre_save 1 pre_save ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_save signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable pre_update 1 pre_update ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_update signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable pre_delete 1 pre_delete ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_delete signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable pre_relation_add 1 pre_relation_add ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_relation_add signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable post_relation_add 1 post_relation_add ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_relation_add signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable pre_relation_remove 1 pre_relation_remove ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_relation_remove signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable post_relation_remove 1 post_relation_remove ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_relation_remove signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"Decorators"},{"location":"api/signals/decorators/#decoratorssignals","text":"","title":"decorators.signals"},{"location":"api/signals/decorators/#receiver","text":"1 receiver ( signal : str , senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for given signal name. Arguments : signal : name of the signal to register to :type signal: str senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"receiver"},{"location":"api/signals/decorators/#post_save","text":"1 post_save ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_save signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"post_save"},{"location":"api/signals/decorators/#post_update","text":"1 post_update ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_update signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"post_update"},{"location":"api/signals/decorators/#post_delete","text":"1 post_delete ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_delete signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"post_delete"},{"location":"api/signals/decorators/#pre_save","text":"1 pre_save ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_save signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"pre_save"},{"location":"api/signals/decorators/#pre_update","text":"1 pre_update ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_update signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"pre_update"},{"location":"api/signals/decorators/#pre_delete","text":"1 pre_delete ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_delete signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"pre_delete"},{"location":"api/signals/decorators/#pre_relation_add","text":"1 pre_relation_add ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_relation_add signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"pre_relation_add"},{"location":"api/signals/decorators/#post_relation_add","text":"1 post_relation_add ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_relation_add signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"post_relation_add"},{"location":"api/signals/decorators/#pre_relation_remove","text":"1 pre_relation_remove ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for pre_relation_remove signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"pre_relation_remove"},{"location":"api/signals/decorators/#post_relation_remove","text":"1 post_relation_remove ( senders : Union [ Type [ \"Model\" ], List [ Type [ \"Model\" ]]]) -> Callable Connect given function to all senders for post_relation_remove signal. Arguments : senders : one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] Returns : returns the original function untouched :rtype: Callable","title":"post_relation_remove"},{"location":"api/signals/signal/","text":"signals.signal callable_accepts_kwargs 1 callable_accepts_kwargs ( func : Callable ) -> bool Checks if function accepts **kwargs. Arguments : func : function which signature needs to be checked :type func: function Returns : result of the check :rtype: bool make_id 1 make_id ( target : Any ) -> Union [ int , Tuple [ int , int ]] Creates id of a function or method to be used as key to store signal Arguments : target : target which id we want :type target: Any Returns : id of the target :rtype: int Signal Objects 1 class Signal () Signal that notifies all receiver functions. In ormar used by models to send pre_save, post_save etc. signals. connect 1 | connect ( receiver : Callable ) -> None Connects given receiver function to the signal. Raises : SignalDefinitionError : if receiver is not callable or not accept **kwargs Arguments : receiver : receiver function :type receiver: Callable disconnect 1 | disconnect ( receiver : Callable ) -> bool Removes the receiver function from the signal. Arguments : receiver : receiver function :type receiver: Callable Returns : flag if receiver was removed :rtype: bool send 1 | async send ( sender : Type [ \"Model\" ], ** kwargs : Any ) -> None Notifies all receiver functions with given kwargs Arguments : sender : model that sends the signal :type sender: Type[\"Model\"] kwargs : arguments passed to receivers :type kwargs: Any SignalEmitter Objects 1 class SignalEmitter () Emitter that registers the signals in internal dictionary. If signal with given name does not exist it's auto added on access.","title":"Signal"},{"location":"api/signals/signal/#signalssignal","text":"","title":"signals.signal"},{"location":"api/signals/signal/#callable_accepts_kwargs","text":"1 callable_accepts_kwargs ( func : Callable ) -> bool Checks if function accepts **kwargs. Arguments : func : function which signature needs to be checked :type func: function Returns : result of the check :rtype: bool","title":"callable_accepts_kwargs"},{"location":"api/signals/signal/#make_id","text":"1 make_id ( target : Any ) -> Union [ int , Tuple [ int , int ]] Creates id of a function or method to be used as key to store signal Arguments : target : target which id we want :type target: Any Returns : id of the target :rtype: int","title":"make_id"},{"location":"api/signals/signal/#signal-objects","text":"1 class Signal () Signal that notifies all receiver functions. In ormar used by models to send pre_save, post_save etc. signals.","title":"Signal Objects"},{"location":"api/signals/signal/#connect","text":"1 | connect ( receiver : Callable ) -> None Connects given receiver function to the signal. Raises : SignalDefinitionError : if receiver is not callable or not accept **kwargs Arguments : receiver : receiver function :type receiver: Callable","title":"connect"},{"location":"api/signals/signal/#disconnect","text":"1 | disconnect ( receiver : Callable ) -> bool Removes the receiver function from the signal. Arguments : receiver : receiver function :type receiver: Callable Returns : flag if receiver was removed :rtype: bool","title":"disconnect"},{"location":"api/signals/signal/#send","text":"1 | async send ( sender : Type [ \"Model\" ], ** kwargs : Any ) -> None Notifies all receiver functions with given kwargs Arguments : sender : model that sends the signal :type sender: Type[\"Model\"] kwargs : arguments passed to receivers :type kwargs: Any","title":"send"},{"location":"api/signals/signal/#signalemitter-objects","text":"1 class SignalEmitter () Emitter that registers the signals in internal dictionary. If signal with given name does not exist it's auto added on access.","title":"SignalEmitter Objects"},{"location":"fastapi/","text":"Fastapi The use of ormar with fastapi is quite simple. Apart from connecting to databases at startup everything else you need to do is substitute pydantic models with ormar models. Here you can find a very simple sample application code. Warning This example assumes that you already have a database created. If that is not the case please visit database initialization section. Tip The following example (all sections) should be put in one file. It's divided into subsections for clarity. Note If you want to read more on how you can use ormar models in fastapi requests and responses check the responses and requests documentation. Quick Start Note Note that you can find the full quick start script in the github repo under examples. Imports and initialization First take care of the imports and initialization 1 2 3 4 5 6 7 8 9 10 11 12 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database Database connection Next define startup and shutdown events (or use middleware) - note that this is databases specific setting not the ormar one 1 2 3 4 5 6 7 8 9 10 11 12 @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () Info You can read more on connecting to databases in fastapi documentation Models definition Define ormar models with appropriate fields. Those models will be used instead of pydantic ones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) Tip You can read more on defining Models in models section. Fastapi endpoints definition Define your desired endpoints, note how ormar models are used both as response_model and as a requests parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Note Note how ormar Model methods like save() are available straight out of the box after fastapi initializes it for you. Note Note that you can return a Model (or list of Models ) directly - fastapi will jsonize it for you Test the application Run fastapi If you want to run this script and play with fastapi swagger install uvicorn first pip install uvicorn And launch the fastapi. uvicorn <filename_without_extension>:app --reload Now you can navigate to your browser (by default fastapi address is 127.0.0.1:8000/docs ) and play with the api. Info You can read more about running fastapi in fastapi docs. Test with pytest Here you have a sample test that will prove that everything works as intended. Be sure to create the tables first. If you are using pytest you can use a fixture. 1 2 3 4 5 6 @pytest . fixture ( autouse = True , scope = \"module\" ) def create_test_database (): engine = sqlalchemy . create_engine ( DATABASE_URL ) metadata . create_all ( engine ) yield metadata . drop_all ( engine ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # here is a sample test to check the working of the ormar with fastapi from starlette.testclient import TestClient def test_all_endpoints (): # note that TestClient is only sync, don't use asyns here client = TestClient ( app ) # note that you need to connect to database manually # or use client as contextmanager during tests with client as client : response = client . post ( \"/categories/\" , json = { \"name\" : \"test cat\" }) category = response . json () response = client . post ( \"/items/\" , json = { \"name\" : \"test\" , \"id\" : 1 , \"category\" : category } ) item = Item ( ** response . json ()) assert item . pk is not None response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] == item item . name = \"New name\" response = client . put ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () == item . dict () response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] . name == \"New name\" response = client . delete ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () . get ( \"deleted_rows\" , \"__UNDEFINED__\" ) != \"__UNDEFINED__\" response = client . get ( \"/items/\" ) items = response . json () assert len ( items ) == 0 Tip If you want to see more test cases and how to test ormar/fastapi see tests directory in the github repo Info You can read more on testing fastapi in fastapi docs.","title":"Quick Start"},{"location":"fastapi/#fastapi","text":"The use of ormar with fastapi is quite simple. Apart from connecting to databases at startup everything else you need to do is substitute pydantic models with ormar models. Here you can find a very simple sample application code. Warning This example assumes that you already have a database created. If that is not the case please visit database initialization section. Tip The following example (all sections) should be put in one file. It's divided into subsections for clarity. Note If you want to read more on how you can use ormar models in fastapi requests and responses check the responses and requests documentation.","title":"Fastapi"},{"location":"fastapi/#quick-start","text":"Note Note that you can find the full quick start script in the github repo under examples.","title":"Quick Start"},{"location":"fastapi/#imports-and-initialization","text":"First take care of the imports and initialization 1 2 3 4 5 6 7 8 9 10 11 12 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database","title":"Imports and initialization"},{"location":"fastapi/#database-connection","text":"Next define startup and shutdown events (or use middleware) - note that this is databases specific setting not the ormar one 1 2 3 4 5 6 7 8 9 10 11 12 @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () Info You can read more on connecting to databases in fastapi documentation","title":"Database connection"},{"location":"fastapi/#models-definition","text":"Define ormar models with appropriate fields. Those models will be used instead of pydantic ones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) Tip You can read more on defining Models in models section.","title":"Models definition"},{"location":"fastapi/#fastapi-endpoints-definition","text":"Define your desired endpoints, note how ormar models are used both as response_model and as a requests parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Note Note how ormar Model methods like save() are available straight out of the box after fastapi initializes it for you. Note Note that you can return a Model (or list of Models ) directly - fastapi will jsonize it for you","title":"Fastapi endpoints definition"},{"location":"fastapi/#test-the-application","text":"","title":"Test the application"},{"location":"fastapi/#run-fastapi","text":"If you want to run this script and play with fastapi swagger install uvicorn first pip install uvicorn And launch the fastapi. uvicorn <filename_without_extension>:app --reload Now you can navigate to your browser (by default fastapi address is 127.0.0.1:8000/docs ) and play with the api. Info You can read more about running fastapi in fastapi docs.","title":"Run fastapi"},{"location":"fastapi/#test-with-pytest","text":"Here you have a sample test that will prove that everything works as intended. Be sure to create the tables first. If you are using pytest you can use a fixture. 1 2 3 4 5 6 @pytest . fixture ( autouse = True , scope = \"module\" ) def create_test_database (): engine = sqlalchemy . create_engine ( DATABASE_URL ) metadata . create_all ( engine ) yield metadata . drop_all ( engine ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # here is a sample test to check the working of the ormar with fastapi from starlette.testclient import TestClient def test_all_endpoints (): # note that TestClient is only sync, don't use asyns here client = TestClient ( app ) # note that you need to connect to database manually # or use client as contextmanager during tests with client as client : response = client . post ( \"/categories/\" , json = { \"name\" : \"test cat\" }) category = response . json () response = client . post ( \"/items/\" , json = { \"name\" : \"test\" , \"id\" : 1 , \"category\" : category } ) item = Item ( ** response . json ()) assert item . pk is not None response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] == item item . name = \"New name\" response = client . put ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () == item . dict () response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] . name == \"New name\" response = client . delete ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () . get ( \"deleted_rows\" , \"__UNDEFINED__\" ) != \"__UNDEFINED__\" response = client . get ( \"/items/\" ) items = response . json () assert len ( items ) == 0 Tip If you want to see more test cases and how to test ormar/fastapi see tests directory in the github repo Info You can read more on testing fastapi in fastapi docs.","title":"Test with pytest"},{"location":"fastapi/requests/","text":"Request You can use ormar Models in fastapi request Body parameters instead of pydantic models. You can of course also mix ormar.Model s with pydantic ones if you need to. One of the most common tasks in requests is excluding certain fields that you do not want to include in the payload you send to API. This can be achieved in several ways in ormar so below you can review your options and select the one most suitable for your situation. Excluding fields in request Optional fields Note that each field that is optional is not required, that means that Optional fields can be skipped both in response and in requests. Field is not required if (any/many/all) of following: Field is marked with nullable=True Field has default value or function provided, i.e. default=\"Test\" Field has a server_default value set Field is an autoincrement=True primary_key field (note that ormar.Integer primary_key is autoincrement by default) Example: 1 2 3 4 5 6 7 8 9 10 11 12 class User ( ormar . Model ): class Meta : tablename : str = \"users\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 , nullable = True ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , default = \"User\" ) In above example fields id (is an autoincrement Integer ), first_name ( has nullable=True ) and category (has default ) are optional and can be skipped in response and model wil still validate. If the field is nullable you don't have to include it in payload during creation as well as in response, so given example above you can: Warning Note that although you do not have to pass the optional field, you still can do it. And if someone will pass a value it will be used later unless you take measures to prevent it. 1 2 3 4 # note that app is an FastApi app @app . post ( \"/users/\" , response_model = User ) # here we use ormar.Model in response async def create_user ( user : User ): # here we use ormar.Model in request parameter return await user . save () That means that if you do not pass i.e. first_name in request it will validate correctly (as field is optional), None will be saved in the database. Generate pydantic model from ormar.Model Since task of excluding fields is so common ormar has a special way to generate pydantic models from existing ormar.Models without you needing to retype all the fields. That method is get_pydantic() method available on all models classes. 1 2 3 4 5 6 # generate a tree of models without password on User and without priority on nested Category RequestUser = User . get_pydantic ( exclude = { \"password\" : ... , \"category\" : { \"priority\" }}) @app . post ( \"/users3/\" , response_model = User ) # here you can also use both ormar/pydantic async def create_user3 ( user : RequestUser ): # use the generated model here # note how now user is pydantic and not ormar Model so you need to convert return await User ( ** user . dict ()) . save () Note To see more examples and read more visit get_pydantic part of the documentation. Warning The get_pydantic method generates all models in a tree of nested models according to an algorithm that allows to avoid loops in models (same algorithm that is used in dict() , select_all() etc.) That means that nested models won't have reference to parent model (by default ormar relation is biderectional). Note also that if given model exists in a tree more than once it will be doubled in pydantic models (each occurance will have separate own model). That way you can exclude/include different fields on different leafs of the tree. Mypy and type checking Note that assigning a function as a python type passes at runtime (as it's not checked) the static type checkers like mypy will complain. Although result of the function call will always be the same for given model using a dynamically created type is not allowed. Therefore you have two options: First one is to simply add # type: ignore to skip the type checking 1 2 3 4 5 RequestUser = User . get_pydantic ( exclude = { \"password\" : ... , \"category\" : { \"priority\" }}) @app . post ( \"/users3/\" , response_model = User ) async def create_user3 ( user : RequestUser ): # type: ignore # note how now user is not ormar Model so you need to convert return await User ( ** user . dict ()) . save () The second one is a little bit more hacky and utilizes a way in which fastapi extract function parameters. You can overwrite the __annotations__ entry for given param. 1 2 3 4 5 6 7 8 RequestUser = User . get_pydantic ( exclude = { \"password\" : ... , \"category\" : { \"priority\" }}) # do not use the app decorator async def create_user3 ( user : User ): # use ormar model here return await User ( ** user . dict ()) . save () # overwrite the function annotations entry for user param with generated model create_user3 . __annotations__ [ \"user\" ] = RequestUser # manually call app functions (app.get, app.post etc.) and pass your function reference app . post ( \"/categories/\" , response_model = User )( create_user3 ) Note that this will cause mypy to \"think\" that user is an ormar model but since in request it doesn't matter that much (you pass jsonized dict anyway and you need to convert before saving). That still should work fine as generated model will be a subset of fields, so all needed fields will validate, and all not used fields will fail at runtime. Separate pydantic model The final solution is to just create separate pydantic model manually. That works exactly the same as with normal fastapi application, so you can have different models for response and requests etc. Sample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import pydantic class UserCreate ( pydantic . BaseModel ): class Config : orm_mode = True email : str first_name : str last_name : str password : str @app . post ( \"/users3/\" , response_model = User ) # use ormar model here (but of course you CAN use pydantic also here) async def create_user3 ( user : UserCreate ): # use pydantic model here # note how now request param is a pydantic model and not the ormar one # so you need to parse/convert it to ormar before you can use database return await User ( ** user . dict ()) . save ()","title":"Using ormar in requests"},{"location":"fastapi/requests/#request","text":"You can use ormar Models in fastapi request Body parameters instead of pydantic models. You can of course also mix ormar.Model s with pydantic ones if you need to. One of the most common tasks in requests is excluding certain fields that you do not want to include in the payload you send to API. This can be achieved in several ways in ormar so below you can review your options and select the one most suitable for your situation.","title":"Request"},{"location":"fastapi/requests/#excluding-fields-in-request","text":"","title":"Excluding fields in request"},{"location":"fastapi/requests/#optional-fields","text":"Note that each field that is optional is not required, that means that Optional fields can be skipped both in response and in requests. Field is not required if (any/many/all) of following: Field is marked with nullable=True Field has default value or function provided, i.e. default=\"Test\" Field has a server_default value set Field is an autoincrement=True primary_key field (note that ormar.Integer primary_key is autoincrement by default) Example: 1 2 3 4 5 6 7 8 9 10 11 12 class User ( ormar . Model ): class Meta : tablename : str = \"users\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 , nullable = True ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , default = \"User\" ) In above example fields id (is an autoincrement Integer ), first_name ( has nullable=True ) and category (has default ) are optional and can be skipped in response and model wil still validate. If the field is nullable you don't have to include it in payload during creation as well as in response, so given example above you can: Warning Note that although you do not have to pass the optional field, you still can do it. And if someone will pass a value it will be used later unless you take measures to prevent it. 1 2 3 4 # note that app is an FastApi app @app . post ( \"/users/\" , response_model = User ) # here we use ormar.Model in response async def create_user ( user : User ): # here we use ormar.Model in request parameter return await user . save () That means that if you do not pass i.e. first_name in request it will validate correctly (as field is optional), None will be saved in the database.","title":"Optional fields"},{"location":"fastapi/requests/#generate-pydantic-model-from-ormarmodel","text":"Since task of excluding fields is so common ormar has a special way to generate pydantic models from existing ormar.Models without you needing to retype all the fields. That method is get_pydantic() method available on all models classes. 1 2 3 4 5 6 # generate a tree of models without password on User and without priority on nested Category RequestUser = User . get_pydantic ( exclude = { \"password\" : ... , \"category\" : { \"priority\" }}) @app . post ( \"/users3/\" , response_model = User ) # here you can also use both ormar/pydantic async def create_user3 ( user : RequestUser ): # use the generated model here # note how now user is pydantic and not ormar Model so you need to convert return await User ( ** user . dict ()) . save () Note To see more examples and read more visit get_pydantic part of the documentation. Warning The get_pydantic method generates all models in a tree of nested models according to an algorithm that allows to avoid loops in models (same algorithm that is used in dict() , select_all() etc.) That means that nested models won't have reference to parent model (by default ormar relation is biderectional). Note also that if given model exists in a tree more than once it will be doubled in pydantic models (each occurance will have separate own model). That way you can exclude/include different fields on different leafs of the tree.","title":"Generate pydantic model from ormar.Model"},{"location":"fastapi/requests/#mypy-and-type-checking","text":"Note that assigning a function as a python type passes at runtime (as it's not checked) the static type checkers like mypy will complain. Although result of the function call will always be the same for given model using a dynamically created type is not allowed. Therefore you have two options: First one is to simply add # type: ignore to skip the type checking 1 2 3 4 5 RequestUser = User . get_pydantic ( exclude = { \"password\" : ... , \"category\" : { \"priority\" }}) @app . post ( \"/users3/\" , response_model = User ) async def create_user3 ( user : RequestUser ): # type: ignore # note how now user is not ormar Model so you need to convert return await User ( ** user . dict ()) . save () The second one is a little bit more hacky and utilizes a way in which fastapi extract function parameters. You can overwrite the __annotations__ entry for given param. 1 2 3 4 5 6 7 8 RequestUser = User . get_pydantic ( exclude = { \"password\" : ... , \"category\" : { \"priority\" }}) # do not use the app decorator async def create_user3 ( user : User ): # use ormar model here return await User ( ** user . dict ()) . save () # overwrite the function annotations entry for user param with generated model create_user3 . __annotations__ [ \"user\" ] = RequestUser # manually call app functions (app.get, app.post etc.) and pass your function reference app . post ( \"/categories/\" , response_model = User )( create_user3 ) Note that this will cause mypy to \"think\" that user is an ormar model but since in request it doesn't matter that much (you pass jsonized dict anyway and you need to convert before saving). That still should work fine as generated model will be a subset of fields, so all needed fields will validate, and all not used fields will fail at runtime.","title":"Mypy and type checking"},{"location":"fastapi/requests/#separate-pydantic-model","text":"The final solution is to just create separate pydantic model manually. That works exactly the same as with normal fastapi application, so you can have different models for response and requests etc. Sample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import pydantic class UserCreate ( pydantic . BaseModel ): class Config : orm_mode = True email : str first_name : str last_name : str password : str @app . post ( \"/users3/\" , response_model = User ) # use ormar model here (but of course you CAN use pydantic also here) async def create_user3 ( user : UserCreate ): # use pydantic model here # note how now request param is a pydantic model and not the ormar one # so you need to parse/convert it to ormar before you can use database return await User ( ** user . dict ()) . save ()","title":"Separate pydantic model"},{"location":"fastapi/response/","text":"Response You can use ormar Models in fastapi response_model instead of pydantic models. You can of course also mix ormar.Model s with pydantic ones if you need to. One of the most common tasks in responses is excluding certain fields that you do not want to include in response data. This can be achieved in several ways in ormar so below you can review your options and select the one most suitable for your situation. Excluding fields in response Optional fields Note that each field that is optional is not required, that means that Optional fields can be skipped both in response and in requests. Field is not required if (any/many/all) of following: Field is marked with nullable=True Field has default value or function provided, i.e. default=\"Test\" Field has a server_default value set Field is an autoincrement=True primary_key field (note that ormar.Integer primary_key is autoincrement by default) Example: 1 2 3 4 5 6 7 8 9 10 11 12 class User ( ormar . Model ): class Meta : tablename : str = \"users\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 , nullable = True ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , default = \"User\" ) In above example fields id (is an autoincrement Integer ), first_name ( has nullable=True ) and category (has default ) are optional and can be skipped in response and model wil still validate. If the field is nullable you don't have to include it in payload during creation as well as in response, so given example above you can: 1 2 3 4 # note that app is an FastApi app @app . post ( \"/users/\" , response_model = User ) # here we use ormar.Model in response async def create_user ( user : User ): # here we use ormar.Model in request parameter return await user . save () That means that if you do not pass i.e. first_name in request it will validate correctly (as field is optional), save in the database and return the saved record without this field (which will also pass validation). Note Note that although you do not pass the field value , the field itself is still present in the response_model that means it will be present in response data and set to None . If you want to fully exclude the field from the result read on. FastApi response_model_exclude Fastapi has response_model_exclude that accepts a set (or a list) of field names. That has it's limitation as ormar and pydantic accepts also dictionaries in which you can set exclude/include columns also on nested models (more on this below) Warning Note that you cannot exclude required fields when using response_model as it will fail during validation. 1 2 3 @app . post ( \"/users/\" , response_model = User , response_model_exclude = { \"password\" }) async def create_user ( user : User ): return await user . save () Above endpoint can be queried like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from starlette.testclient import TestClient client = TestClient ( app ) with client as client : # note there is no pk user = { \"email\" : \"test@domain.com\" , \"password\" : \"^*^%A*DA*IAAA\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , } response = client . post ( \"/users/\" , json = user ) # note that the excluded field is fully gone from response assert \"password\" not in response . json () # read the response and initialize model out of it created_user = User ( ** response . json ()) # note pk is populated by autoincrement assert created_user . pk is not None # note that password is missing in initialized model too assert created_user . password is None Note Note how in above example password field is fully gone from the response data. Note that you can use this method only for non-required fields. Nested models excludes Despite the fact that fastapi allows passing only set of field names, so simple excludes, when using response_model_exclude , ormar is smarter. In ormar you can exclude nested models using two types of notations. One is a dictionary with nested fields that represents the model tree structure, and the second one is double underscore separated path of field names. Assume for a second that our user's category is a separate model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename : str = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 255 ) priority : int = ormar . Integer ( nullable = True ) class User ( ormar . Model ): class Meta ( BaseMeta ): tablename : str = \"users\" id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 , nullable = True ) last_name : str = ormar . String ( max_length = 255 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , related_name = \"categories\" ) If you want to exclude priority from category in your response, you can still use fastapi parameter. 1 2 3 @app . post ( \"/users/\" , response_model = User , response_model_exclude = { \"category__priority\" }) async def create_user ( user : User ): return await user . save () Note that you can go in deeper models with double underscore, and if you wan't to exclude multiple fields from nested model you need to prefix them with full path. In example response_model_exclude={\"category__priority\", \"category__other_field\", category__nested_model__nested_model_field} etc. Note To read more about possible excludes and how to structure your exclude dictionary or set visit fields section of documentation Note Note that apart from response_model_exclude parameter fastapi supports also other parameters inherited from pydantic . All of them works also with ormar, but can have some nuances so best to read dict part of the documentation. Exclude in Model.dict() Alternatively you can just return a dict from ormar.Model and use . Like this you can also set exclude/include as dict and exclude fields on nested models too. Warning Not using a response_model will cause api documentation having no response example and schema since in theory response can have any format. 1 2 3 4 5 @app . post ( \"/users2/\" , response_model = User ) async def create_user2 ( user : User ): user = await user . save () return user . dict ( exclude = { 'password' }) # could be also something like return user.dict(exclude={'category': {'priority'}}) to exclude category priority Note Note that above example will nullify the password field even if you pass it in request, but the field will be still there as it's part of the response schema, the value will be set to None . If you want to fully exclude the field with this approach simply don't use response_model and exclude in Model's dict() Alternatively you can just return a dict from ormar model. Like this you can also set exclude/include as dict and exclude fields on nested models. Note In theory you loose validation of response here but since you operate on ormar.Models the response data have already been validated after db query (as ormar model is pydantic model). So if you skip response_model altogether you can do something like this: 1 2 3 4 @app . post ( \"/users4/\" ) # note no response_model async def create_user4 ( user : User ): user = await user . save () return user . dict ( exclude = { 'last_name' }) Note Note that when you skip the response_model you can now exclude also required fields as the response is no longer validated after being returned. The cost of this solution is that you loose also api documentation as response schema in unknown from fastapi perspective. Generate pydantic model from ormar.Model Since task of excluding fields is so common ormar has a special way to generate pydantic models from existing ormar.Models without you needing to retype all the fields. That method is get_pydantic() method available on all models classes. 1 2 3 4 5 # generate a tree of models without password on User and without priority on nested Category ResponseUser = User . get_pydantic ( exclude = { \"password\" : ... , \"category\" : { \"priority\" }}) @app . post ( \"/users3/\" , response_model = ResponseUser ) # use the generated model here async def create_user3 ( user : User ): return await user . save () Note To see more examples and read more visit get_pydantic part of the documentation. Warning The get_pydantic method generates all models in a tree of nested models according to an algorithm that allows to avoid loops in models (same algorithm that is used in dict() , select_all() etc.) That means that nested models won't have reference to parent model (by default ormar relation is biderectional). Note also that if given model exists in a tree more than once it will be doubled in pydantic models (each occurance will have separate own model). That way you can exclude/include different fields on different leafs of the tree. Separate pydantic model The final solution is to just create separate pydantic model manually. That works exactly the same as with normal fastapi application so you can have different models for response and requests etc. Sample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pydantic class UserBase ( pydantic . BaseModel ): class Config : orm_mode = True email : str first_name : str last_name : str @app . post ( \"/users3/\" , response_model = UserBase ) # use pydantic model here async def create_user3 ( user : User ): #use ormar model here (but of course you CAN use pydantic also here) return await user . save ()","title":"Using ormar in responses"},{"location":"fastapi/response/#response","text":"You can use ormar Models in fastapi response_model instead of pydantic models. You can of course also mix ormar.Model s with pydantic ones if you need to. One of the most common tasks in responses is excluding certain fields that you do not want to include in response data. This can be achieved in several ways in ormar so below you can review your options and select the one most suitable for your situation.","title":"Response"},{"location":"fastapi/response/#excluding-fields-in-response","text":"","title":"Excluding fields in response"},{"location":"fastapi/response/#optional-fields","text":"Note that each field that is optional is not required, that means that Optional fields can be skipped both in response and in requests. Field is not required if (any/many/all) of following: Field is marked with nullable=True Field has default value or function provided, i.e. default=\"Test\" Field has a server_default value set Field is an autoincrement=True primary_key field (note that ormar.Integer primary_key is autoincrement by default) Example: 1 2 3 4 5 6 7 8 9 10 11 12 class User ( ormar . Model ): class Meta : tablename : str = \"users\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 , nullable = True ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , default = \"User\" ) In above example fields id (is an autoincrement Integer ), first_name ( has nullable=True ) and category (has default ) are optional and can be skipped in response and model wil still validate. If the field is nullable you don't have to include it in payload during creation as well as in response, so given example above you can: 1 2 3 4 # note that app is an FastApi app @app . post ( \"/users/\" , response_model = User ) # here we use ormar.Model in response async def create_user ( user : User ): # here we use ormar.Model in request parameter return await user . save () That means that if you do not pass i.e. first_name in request it will validate correctly (as field is optional), save in the database and return the saved record without this field (which will also pass validation). Note Note that although you do not pass the field value , the field itself is still present in the response_model that means it will be present in response data and set to None . If you want to fully exclude the field from the result read on.","title":"Optional fields"},{"location":"fastapi/response/#fastapi-response_model_exclude","text":"Fastapi has response_model_exclude that accepts a set (or a list) of field names. That has it's limitation as ormar and pydantic accepts also dictionaries in which you can set exclude/include columns also on nested models (more on this below) Warning Note that you cannot exclude required fields when using response_model as it will fail during validation. 1 2 3 @app . post ( \"/users/\" , response_model = User , response_model_exclude = { \"password\" }) async def create_user ( user : User ): return await user . save () Above endpoint can be queried like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from starlette.testclient import TestClient client = TestClient ( app ) with client as client : # note there is no pk user = { \"email\" : \"test@domain.com\" , \"password\" : \"^*^%A*DA*IAAA\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , } response = client . post ( \"/users/\" , json = user ) # note that the excluded field is fully gone from response assert \"password\" not in response . json () # read the response and initialize model out of it created_user = User ( ** response . json ()) # note pk is populated by autoincrement assert created_user . pk is not None # note that password is missing in initialized model too assert created_user . password is None Note Note how in above example password field is fully gone from the response data. Note that you can use this method only for non-required fields.","title":"FastApi response_model_exclude"},{"location":"fastapi/response/#nested-models-excludes","text":"Despite the fact that fastapi allows passing only set of field names, so simple excludes, when using response_model_exclude , ormar is smarter. In ormar you can exclude nested models using two types of notations. One is a dictionary with nested fields that represents the model tree structure, and the second one is double underscore separated path of field names. Assume for a second that our user's category is a separate model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename : str = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 255 ) priority : int = ormar . Integer ( nullable = True ) class User ( ormar . Model ): class Meta ( BaseMeta ): tablename : str = \"users\" id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 , nullable = True ) last_name : str = ormar . String ( max_length = 255 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , related_name = \"categories\" ) If you want to exclude priority from category in your response, you can still use fastapi parameter. 1 2 3 @app . post ( \"/users/\" , response_model = User , response_model_exclude = { \"category__priority\" }) async def create_user ( user : User ): return await user . save () Note that you can go in deeper models with double underscore, and if you wan't to exclude multiple fields from nested model you need to prefix them with full path. In example response_model_exclude={\"category__priority\", \"category__other_field\", category__nested_model__nested_model_field} etc. Note To read more about possible excludes and how to structure your exclude dictionary or set visit fields section of documentation Note Note that apart from response_model_exclude parameter fastapi supports also other parameters inherited from pydantic . All of them works also with ormar, but can have some nuances so best to read dict part of the documentation.","title":"Nested models excludes"},{"location":"fastapi/response/#exclude-in-modeldict","text":"Alternatively you can just return a dict from ormar.Model and use . Like this you can also set exclude/include as dict and exclude fields on nested models too. Warning Not using a response_model will cause api documentation having no response example and schema since in theory response can have any format. 1 2 3 4 5 @app . post ( \"/users2/\" , response_model = User ) async def create_user2 ( user : User ): user = await user . save () return user . dict ( exclude = { 'password' }) # could be also something like return user.dict(exclude={'category': {'priority'}}) to exclude category priority Note Note that above example will nullify the password field even if you pass it in request, but the field will be still there as it's part of the response schema, the value will be set to None . If you want to fully exclude the field with this approach simply don't use response_model and exclude in Model's dict() Alternatively you can just return a dict from ormar model. Like this you can also set exclude/include as dict and exclude fields on nested models. Note In theory you loose validation of response here but since you operate on ormar.Models the response data have already been validated after db query (as ormar model is pydantic model). So if you skip response_model altogether you can do something like this: 1 2 3 4 @app . post ( \"/users4/\" ) # note no response_model async def create_user4 ( user : User ): user = await user . save () return user . dict ( exclude = { 'last_name' }) Note Note that when you skip the response_model you can now exclude also required fields as the response is no longer validated after being returned. The cost of this solution is that you loose also api documentation as response schema in unknown from fastapi perspective.","title":"Exclude in Model.dict()"},{"location":"fastapi/response/#generate-pydantic-model-from-ormarmodel","text":"Since task of excluding fields is so common ormar has a special way to generate pydantic models from existing ormar.Models without you needing to retype all the fields. That method is get_pydantic() method available on all models classes. 1 2 3 4 5 # generate a tree of models without password on User and without priority on nested Category ResponseUser = User . get_pydantic ( exclude = { \"password\" : ... , \"category\" : { \"priority\" }}) @app . post ( \"/users3/\" , response_model = ResponseUser ) # use the generated model here async def create_user3 ( user : User ): return await user . save () Note To see more examples and read more visit get_pydantic part of the documentation. Warning The get_pydantic method generates all models in a tree of nested models according to an algorithm that allows to avoid loops in models (same algorithm that is used in dict() , select_all() etc.) That means that nested models won't have reference to parent model (by default ormar relation is biderectional). Note also that if given model exists in a tree more than once it will be doubled in pydantic models (each occurance will have separate own model). That way you can exclude/include different fields on different leafs of the tree.","title":"Generate pydantic model from ormar.Model"},{"location":"fastapi/response/#separate-pydantic-model","text":"The final solution is to just create separate pydantic model manually. That works exactly the same as with normal fastapi application so you can have different models for response and requests etc. Sample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pydantic class UserBase ( pydantic . BaseModel ): class Config : orm_mode = True email : str first_name : str last_name : str @app . post ( \"/users3/\" , response_model = UserBase ) # use pydantic model here async def create_user3 ( user : User ): #use ormar model here (but of course you CAN use pydantic also here) return await user . save ()","title":"Separate pydantic model"},{"location":"fields/common-parameters/","text":"Common Parameters All Field types have a set of common parameters. primary_key primary_key : bool = False -> by default False. Sets the primary key column on a table, foreign keys always refer to the pk of the Model . Used in sql only. autoincrement autoincrement : bool = primary_key and type == int -> defaults to True if column is a primary key and of type Integer, otherwise False. Can be only used with int/bigint fields. If a field has autoincrement it becomes optional. Used both in sql and pydantic (changes pk field to optional for autoincrement). nullable nullable : bool = not primary_key -> defaults to False for primary key column, and True for all other. Specifies if field is optional or required, used both with sql and pydantic. Note By default all ForeignKeys are also nullable, meaning the related Model is not required. If you change the ForeignKey column to nullable=False , it becomes required. Info If you want to know more about how you can preload related models during queries and how the relations work read the queries and relations sections. default default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on an insert, used during pydantic model definition. If the field has a default value it becomes optional. You can pass a static value or a Callable (function etc.) Used both in sql and pydantic. Sample usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # note the distinction between passing a value and Callable pointer # value name : str = ormar . String ( max_length = 200 , default = \"Name\" ) # note that when you call a function it's not a pointer to Callable # a definition like this will call the function at startup and assign # the result of the function to the default, so it will be constant value for all instances created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ()) # if you want to pass Callable reference (note that it cannot have arguments) # note lack of the parenthesis -> ormar will call this function for you on each model created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # Callable can be a function, builtin, class etc. server default server_default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on the server side so you can pass i.e. sql function (like now() or query/value wrapped in sqlalchemy text() clause). If the field has a server_default value it becomes optional. You can pass a static value or a Callable (function etc.) Used in sql only. Sample usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from datetime import datetime import databases import sqlalchemy from sqlalchemy import func , text import ormar database = databases . Database ( \"sqlite:///test.db\" ) metadata = sqlalchemy . MetaData () class Product ( ormar . Model ): class Meta : tablename = \"product\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) company : str = ormar . String ( max_length = 200 , server_default = \"Acme\" ) sort_order : int = ormar . Integer ( server_default = text ( \"10\" )) created : datetime = ormar . DateTime ( server_default = func . now ()) Warning server_default accepts str , sqlalchemy.sql.elements.ClauseElement or sqlalchemy.sql.elements.TextClause so if you want to set i.e. Integer value you need to wrap it in sqlalchemy.text() function like above Tip You can pass also valid sql (dialect specific) wrapped in sqlalchemy.text() For example func.now() above could be exchanged for text('(CURRENT_TIMESTAMP)') for sqlite backend Info server_default is passed straight to sqlalchemy table definition so you can read more in server default sqlalchemy documentation index index : bool = False -> by default False, Sets the index on a table's column. Used in sql only. unique unique : bool = False Sets the unique constraint on a table's column. Used in sql only. pydantic_only ( DEPRECATED ) This parameter is deprecated and will be removed in one of next releases! To check how to declare pydantic only fields that are not saved into database see pydantic fields section pydantic_only : bool = False Prevents creation of a sql column for given field. Used for data related to given model but not to be stored in the database. Used in pydantic only. choices choices : Sequence = [] A set of choices allowed to be used for given field. Used for data validation on pydantic side. Prevents insertion of value not present in the choices list. Used in pydantic only.","title":"Common parameters"},{"location":"fields/common-parameters/#common-parameters","text":"All Field types have a set of common parameters.","title":"Common Parameters"},{"location":"fields/common-parameters/#primary_key","text":"primary_key : bool = False -> by default False. Sets the primary key column on a table, foreign keys always refer to the pk of the Model . Used in sql only.","title":"primary_key"},{"location":"fields/common-parameters/#autoincrement","text":"autoincrement : bool = primary_key and type == int -> defaults to True if column is a primary key and of type Integer, otherwise False. Can be only used with int/bigint fields. If a field has autoincrement it becomes optional. Used both in sql and pydantic (changes pk field to optional for autoincrement).","title":"autoincrement"},{"location":"fields/common-parameters/#nullable","text":"nullable : bool = not primary_key -> defaults to False for primary key column, and True for all other. Specifies if field is optional or required, used both with sql and pydantic. Note By default all ForeignKeys are also nullable, meaning the related Model is not required. If you change the ForeignKey column to nullable=False , it becomes required. Info If you want to know more about how you can preload related models during queries and how the relations work read the queries and relations sections.","title":"nullable"},{"location":"fields/common-parameters/#default","text":"default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on an insert, used during pydantic model definition. If the field has a default value it becomes optional. You can pass a static value or a Callable (function etc.) Used both in sql and pydantic. Sample usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # note the distinction between passing a value and Callable pointer # value name : str = ormar . String ( max_length = 200 , default = \"Name\" ) # note that when you call a function it's not a pointer to Callable # a definition like this will call the function at startup and assign # the result of the function to the default, so it will be constant value for all instances created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ()) # if you want to pass Callable reference (note that it cannot have arguments) # note lack of the parenthesis -> ormar will call this function for you on each model created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # Callable can be a function, builtin, class etc.","title":"default"},{"location":"fields/common-parameters/#server-default","text":"server_default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on the server side so you can pass i.e. sql function (like now() or query/value wrapped in sqlalchemy text() clause). If the field has a server_default value it becomes optional. You can pass a static value or a Callable (function etc.) Used in sql only. Sample usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from datetime import datetime import databases import sqlalchemy from sqlalchemy import func , text import ormar database = databases . Database ( \"sqlite:///test.db\" ) metadata = sqlalchemy . MetaData () class Product ( ormar . Model ): class Meta : tablename = \"product\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) company : str = ormar . String ( max_length = 200 , server_default = \"Acme\" ) sort_order : int = ormar . Integer ( server_default = text ( \"10\" )) created : datetime = ormar . DateTime ( server_default = func . now ()) Warning server_default accepts str , sqlalchemy.sql.elements.ClauseElement or sqlalchemy.sql.elements.TextClause so if you want to set i.e. Integer value you need to wrap it in sqlalchemy.text() function like above Tip You can pass also valid sql (dialect specific) wrapped in sqlalchemy.text() For example func.now() above could be exchanged for text('(CURRENT_TIMESTAMP)') for sqlite backend Info server_default is passed straight to sqlalchemy table definition so you can read more in server default sqlalchemy documentation","title":"server default"},{"location":"fields/common-parameters/#index","text":"index : bool = False -> by default False, Sets the index on a table's column. Used in sql only.","title":"index"},{"location":"fields/common-parameters/#unique","text":"unique : bool = False Sets the unique constraint on a table's column. Used in sql only.","title":"unique"},{"location":"fields/common-parameters/#pydantic_only-deprecated","text":"This parameter is deprecated and will be removed in one of next releases! To check how to declare pydantic only fields that are not saved into database see pydantic fields section pydantic_only : bool = False Prevents creation of a sql column for given field. Used for data related to given model but not to be stored in the database. Used in pydantic only.","title":"pydantic_only (DEPRECATED)"},{"location":"fields/common-parameters/#choices","text":"choices : Sequence = [] A set of choices allowed to be used for given field. Used for data validation on pydantic side. Prevents insertion of value not present in the choices list. Used in pydantic only.","title":"choices"},{"location":"fields/encryption/","text":"Encryption ormar provides you with a way to encrypt a field in the database only. Provided encryption backends allow for both one-way encryption ( HASH backend) as well as both-way encryption/decryption ( FERNET backend). Warning Note that in order for encryption to work you need to install optional cryptography package. You can do it manually pip install cryptography or with ormar by pip install ormar[crypto] Warning Note that adding encrypt_backend changes the database column type to TEXT , which needs to be reflected in db either by migration ( alembic ) or manual change Defining a field encryption To encrypt a field you need to pass at minimum encrypt_secret and encrypt_backend parameters. 1 2 3 4 5 6 7 8 class Filter ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"filters\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , encrypt_secret = \"secret123\" , encrypt_backend = ormar . EncryptBackends . FERNET ) Warning You can encrypt all Field types apart from primary_key column and relation columns ( ForeignKey and ManyToMany ). Check backends details for more information. Available backends HASH HASH is a one-way hash (like for password), never decrypted on retrieval To set it up pass appropriate backend value. 1 2 3 4 ... # rest of model definition password : str = ormar . String ( max_length = 128 , encrypt_secret = \"secret123\" , encrypt_backend = ormar . EncryptBackends . HASH ) Note that since this backend never decrypt the stored value it's only applicable for String fields. Used hash is a sha512 hash, so the field length has to be >=128. Warning Note that in HASH backend you can filter by full value but filters like contain will not work as comparison is make on encrypted values Note Note that provided encrypt_secret is first hashed itself and used as salt, so in order to compare to stored string you need to recreate this steps. The order_by will not work as encrypted strings are compared so you cannot reliably order by. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Hash ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"hashes\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 128 , encrypt_secret = \"udxc32\" , encrypt_backend = ormar . EncryptBackends . HASH ) await Hash ( name = 'test1' ) . save () # note the steps to recreate the stored value # you can use also cryptography package instead of hashlib secret = hashlib . sha256 ( \"udxc32\" . encode ()) . digest () secret = base64 . urlsafe_b64encode ( secret ) hashed_test1 = hashlib . sha512 ( secret + 'test1' . encode ()) . hexdigest () # full value comparison works hash1 = await Hash . objects . get ( name = 'test1' ) assert hash1 . name == hashed_test1 # but partial comparison does not (hashed strings are compared) with pytest . raises ( NoMatch ): await Filter . objects . get ( name__icontains = 'test' ) FERNET FERNET is a two-way encrypt/decrypt backend To set it up pass appropriate backend value. 1 2 3 ... # rest of model definition year : int = ormar . Integer ( encrypt_secret = \"secret123\" , encrypt_backend = ormar . EncryptBackends . FERNET ) Value is encrypted on way to database end decrypted on way out. Can be used on all types, as the returned value is parsed to corresponding python type. Warning Note that in FERNET backend you loose filter ing possibility altogether as part of the encrypted value is a timestamp. The same goes for order_by as encrypted strings are compared so you cannot reliably order by. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Filter ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"filters\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , encrypt_secret = \"asd123\" , encrypt_backend = ormar . EncryptBackends . FERNET ) await Filter ( name = 'test1' ) . save () await Filter ( name = 'test1' ) . save () # values are properly encrypted and later decrypted filters = await Filter . objects . all () assert filters [ 0 ] . name == filters [ 1 ] . name == 'test1' # but you cannot filter at all since part of the fernet hash is a timestamp # which means that even if you encrypt the same string 2 times it will be different with pytest . raises ( NoMatch ): await Filter . objects . get ( name = 'test1' ) Custom Backends If you wish to support other type of encryption (i.e. AES) you can provide your own EncryptionBackend . To setup a backend all you need to do is subclass ormar.fields.EncryptBackend class and provide required backend. Sample dummy backend (that does nothing) can look like following: 1 2 3 4 5 6 7 8 9 class DummyBackend ( ormar . fields . EncryptBackend ): def _initialize_backend ( self , secret_key : bytes ) -> None : pass def encrypt ( self , value : Any ) -> str : return value def decrypt ( self , value : Any ) -> str : return value To use this backend set encrypt_backend to CUSTOM and provide your backend as argument by encrypt_custom_backend . 1 2 3 4 5 6 7 8 9 10 class Filter ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"filters\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , encrypt_secret = \"secret123\" , encrypt_backend = ormar . EncryptBackends . CUSTOM , encrypt_custom_backend = DummyBackend )","title":"Fields encryption"},{"location":"fields/encryption/#encryption","text":"ormar provides you with a way to encrypt a field in the database only. Provided encryption backends allow for both one-way encryption ( HASH backend) as well as both-way encryption/decryption ( FERNET backend). Warning Note that in order for encryption to work you need to install optional cryptography package. You can do it manually pip install cryptography or with ormar by pip install ormar[crypto] Warning Note that adding encrypt_backend changes the database column type to TEXT , which needs to be reflected in db either by migration ( alembic ) or manual change","title":"Encryption"},{"location":"fields/encryption/#defining-a-field-encryption","text":"To encrypt a field you need to pass at minimum encrypt_secret and encrypt_backend parameters. 1 2 3 4 5 6 7 8 class Filter ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"filters\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , encrypt_secret = \"secret123\" , encrypt_backend = ormar . EncryptBackends . FERNET ) Warning You can encrypt all Field types apart from primary_key column and relation columns ( ForeignKey and ManyToMany ). Check backends details for more information.","title":"Defining a field encryption"},{"location":"fields/encryption/#available-backends","text":"","title":"Available backends"},{"location":"fields/encryption/#hash","text":"HASH is a one-way hash (like for password), never decrypted on retrieval To set it up pass appropriate backend value. 1 2 3 4 ... # rest of model definition password : str = ormar . String ( max_length = 128 , encrypt_secret = \"secret123\" , encrypt_backend = ormar . EncryptBackends . HASH ) Note that since this backend never decrypt the stored value it's only applicable for String fields. Used hash is a sha512 hash, so the field length has to be >=128. Warning Note that in HASH backend you can filter by full value but filters like contain will not work as comparison is make on encrypted values Note Note that provided encrypt_secret is first hashed itself and used as salt, so in order to compare to stored string you need to recreate this steps. The order_by will not work as encrypted strings are compared so you cannot reliably order by. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Hash ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"hashes\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 128 , encrypt_secret = \"udxc32\" , encrypt_backend = ormar . EncryptBackends . HASH ) await Hash ( name = 'test1' ) . save () # note the steps to recreate the stored value # you can use also cryptography package instead of hashlib secret = hashlib . sha256 ( \"udxc32\" . encode ()) . digest () secret = base64 . urlsafe_b64encode ( secret ) hashed_test1 = hashlib . sha512 ( secret + 'test1' . encode ()) . hexdigest () # full value comparison works hash1 = await Hash . objects . get ( name = 'test1' ) assert hash1 . name == hashed_test1 # but partial comparison does not (hashed strings are compared) with pytest . raises ( NoMatch ): await Filter . objects . get ( name__icontains = 'test' )","title":"HASH"},{"location":"fields/encryption/#fernet","text":"FERNET is a two-way encrypt/decrypt backend To set it up pass appropriate backend value. 1 2 3 ... # rest of model definition year : int = ormar . Integer ( encrypt_secret = \"secret123\" , encrypt_backend = ormar . EncryptBackends . FERNET ) Value is encrypted on way to database end decrypted on way out. Can be used on all types, as the returned value is parsed to corresponding python type. Warning Note that in FERNET backend you loose filter ing possibility altogether as part of the encrypted value is a timestamp. The same goes for order_by as encrypted strings are compared so you cannot reliably order by. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Filter ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"filters\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , encrypt_secret = \"asd123\" , encrypt_backend = ormar . EncryptBackends . FERNET ) await Filter ( name = 'test1' ) . save () await Filter ( name = 'test1' ) . save () # values are properly encrypted and later decrypted filters = await Filter . objects . all () assert filters [ 0 ] . name == filters [ 1 ] . name == 'test1' # but you cannot filter at all since part of the fernet hash is a timestamp # which means that even if you encrypt the same string 2 times it will be different with pytest . raises ( NoMatch ): await Filter . objects . get ( name = 'test1' )","title":"FERNET"},{"location":"fields/encryption/#custom-backends","text":"If you wish to support other type of encryption (i.e. AES) you can provide your own EncryptionBackend . To setup a backend all you need to do is subclass ormar.fields.EncryptBackend class and provide required backend. Sample dummy backend (that does nothing) can look like following: 1 2 3 4 5 6 7 8 9 class DummyBackend ( ormar . fields . EncryptBackend ): def _initialize_backend ( self , secret_key : bytes ) -> None : pass def encrypt ( self , value : Any ) -> str : return value def decrypt ( self , value : Any ) -> str : return value To use this backend set encrypt_backend to CUSTOM and provide your backend as argument by encrypt_custom_backend . 1 2 3 4 5 6 7 8 9 10 class Filter ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"filters\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , encrypt_secret = \"secret123\" , encrypt_backend = ormar . EncryptBackends . CUSTOM , encrypt_custom_backend = DummyBackend )","title":"Custom Backends"},{"location":"fields/field-types/","text":"Fields There are 12 basic model field types and a special ForeignKey and Many2Many fields to establish relationships between models. Tip For explanation of ForeignKey and Many2Many fields check relations . Each of the Fields has assigned both sqlalchemy column class and python type that is used to create pydantic model. Fields Types String String(max_length: int, min_length: int = None, regex: str = None,) has a required max_length parameter. Sqlalchemy column: sqlalchemy.String Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation. Text Text() has no required parameters. Sqlalchemy column: sqlalchemy.Text Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation. Boolean Boolean() has no required parameters. Sqlalchemy column: sqlalchemy.Boolean Type (used for pydantic): bool Integer Integer(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Integer Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation. BigInteger BigInteger(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.BigInteger Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation. SmallInteger SmallInteger(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.SmallInteger Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation. Float Float(minimum: float = None, maximum: float = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Float Type (used for pydantic): float Tip For explanation of other parameters check pydantic documentation. Decimal Decimal(minimum: float = None, maximum: float = None, multiple_of: int = None, precision: int = None, scale: int = None, max_digits: int = None, decimal_places: int = None) has no required parameters You can use either length and precision parameters or max_digits and decimal_places . Sqlalchemy column: sqlalchemy.DECIMAL Type (used for pydantic): decimal.Decimal Tip For explanation of other parameters check pydantic documentation. Date Date() has no required parameters. Sqlalchemy column: sqlalchemy.Date Type (used for pydantic): datetime.date Time Time(timezone: bool = False) has no required parameters. You can pass timezone=True for timezone aware database column. Sqlalchemy column: sqlalchemy.Time Type (used for pydantic): datetime.time DateTime DateTime(timezone: bool = False) has no required parameters. You can pass timezone=True for timezone aware database column. Sqlalchemy column: sqlalchemy.DateTime Type (used for pydantic): datetime.datetime JSON JSON() has no required parameters. Sqlalchemy column: sqlalchemy.JSON Type (used for pydantic): pydantic.Json LargeBinary LargeBinary(max_length) has a required max_length parameter. Sqlalchemy column: sqlalchemy.LargeBinary Type (used for pydantic): bytes LargeBinary length is used in some backend (i.e. mysql) to determine the size of the field, in other backends it's simply ignored yet in ormar it's always required. It should be max size of the file/bytes in bytes. LargeBinary has also optional represent_as_base64_str: bool = False flag. When set to True ormar will auto-convert bytes value to base64 decoded string, you can also set value by passing a base64 encoded string. That way you can i.e. set the value by API, even if value is not utf-8 compatible and would otherwise fail during json conversion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import base64 ... # other imports skipped for brevity class LargeBinaryStr ( ormar . Model ): class Meta : tablename = \"my_str_blobs\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) test_binary : str = ormar . LargeBinary ( max_length = 100000 , represent_as_base64_str = True ) # set non utf-8 compliant value - note this can be passed by api (i.e. fastapi) in json item = LargeBinaryStr ( test_binary = base64 . b64encode ( b \" \\xc3\\x28 \" ) . decode ()) assert item . test_binary == base64 . b64encode ( b \" \\xc3\\x28 \" ) . decode () # technical note that underlying value is still bytes and will be saved as so assert item . __dict__ [ \"test_binary\" ] == b \" \\xc3\\x28 \" UUID UUID(uuid_format: str = 'hex') has no required parameters. Sqlalchemy column: ormar.UUID based on sqlalchemy.CHAR(36) or sqlalchemy.CHAR(32) field (for string or hex format respectively) Type (used for pydantic): uuid.UUID uuid_format parameters allow 'hex'(default) or 'string' values. Depending on the format either 32 or 36 char is used in the database. Sample: 'hex' format value = c616ab438cce49dbbf4380d109251dce (CHAR(32)) 'string' value = c616ab43-8cce-49db-bf43-80d109251dce (CHAR(36)) When loaded it's always python UUID so you can compare it and compare two formats values between each other. Enum Although there is no dedicated field type for Enums in ormar you can change any field into Enum like field by passing a choices list that is accepted by all Field types. It will add both: validation in pydantic model and will display available options in schema, therefore it will be available in docs of fastapi . If you still want to use Enum in your application you can do this by passing a Enum into choices and later pass value of given option to a given field (note tha Enum is not JsonSerializable). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # not that imports and endpoints declaration # is skipped here for brevity from enum import Enum class TestEnum ( Enum ): val1 = 'Val1' val2 = 'Val2' class TestModel ( ormar . Model ): class Meta : tablename = \"org\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) # pass list(Enum) to choices enum_string : str = ormar . String ( max_length = 100 , choices = list ( TestEnum )) # sample payload coming to fastapi response = client . post ( \"/test_models/\" , json = { \"id\" : 1 , # you need to refer to the value of the `Enum` option # if called like this, alternatively just use value # string \"Val1\" in this case \"enum_string\" : TestEnum . val1 . value }, )","title":"Fields types"},{"location":"fields/field-types/#fields","text":"There are 12 basic model field types and a special ForeignKey and Many2Many fields to establish relationships between models. Tip For explanation of ForeignKey and Many2Many fields check relations . Each of the Fields has assigned both sqlalchemy column class and python type that is used to create pydantic model.","title":"Fields"},{"location":"fields/field-types/#fields-types","text":"","title":"Fields Types"},{"location":"fields/field-types/#string","text":"String(max_length: int, min_length: int = None, regex: str = None,) has a required max_length parameter. Sqlalchemy column: sqlalchemy.String Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation.","title":"String"},{"location":"fields/field-types/#text","text":"Text() has no required parameters. Sqlalchemy column: sqlalchemy.Text Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation.","title":"Text"},{"location":"fields/field-types/#boolean","text":"Boolean() has no required parameters. Sqlalchemy column: sqlalchemy.Boolean Type (used for pydantic): bool","title":"Boolean"},{"location":"fields/field-types/#integer","text":"Integer(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Integer Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation.","title":"Integer"},{"location":"fields/field-types/#biginteger","text":"BigInteger(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.BigInteger Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation.","title":"BigInteger"},{"location":"fields/field-types/#smallinteger","text":"SmallInteger(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.SmallInteger Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation.","title":"SmallInteger"},{"location":"fields/field-types/#float","text":"Float(minimum: float = None, maximum: float = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Float Type (used for pydantic): float Tip For explanation of other parameters check pydantic documentation.","title":"Float"},{"location":"fields/field-types/#decimal","text":"Decimal(minimum: float = None, maximum: float = None, multiple_of: int = None, precision: int = None, scale: int = None, max_digits: int = None, decimal_places: int = None) has no required parameters You can use either length and precision parameters or max_digits and decimal_places . Sqlalchemy column: sqlalchemy.DECIMAL Type (used for pydantic): decimal.Decimal Tip For explanation of other parameters check pydantic documentation.","title":"Decimal"},{"location":"fields/field-types/#date","text":"Date() has no required parameters. Sqlalchemy column: sqlalchemy.Date Type (used for pydantic): datetime.date","title":"Date"},{"location":"fields/field-types/#time","text":"Time(timezone: bool = False) has no required parameters. You can pass timezone=True for timezone aware database column. Sqlalchemy column: sqlalchemy.Time Type (used for pydantic): datetime.time","title":"Time"},{"location":"fields/field-types/#datetime","text":"DateTime(timezone: bool = False) has no required parameters. You can pass timezone=True for timezone aware database column. Sqlalchemy column: sqlalchemy.DateTime Type (used for pydantic): datetime.datetime","title":"DateTime"},{"location":"fields/field-types/#json","text":"JSON() has no required parameters. Sqlalchemy column: sqlalchemy.JSON Type (used for pydantic): pydantic.Json","title":"JSON"},{"location":"fields/field-types/#largebinary","text":"LargeBinary(max_length) has a required max_length parameter. Sqlalchemy column: sqlalchemy.LargeBinary Type (used for pydantic): bytes LargeBinary length is used in some backend (i.e. mysql) to determine the size of the field, in other backends it's simply ignored yet in ormar it's always required. It should be max size of the file/bytes in bytes. LargeBinary has also optional represent_as_base64_str: bool = False flag. When set to True ormar will auto-convert bytes value to base64 decoded string, you can also set value by passing a base64 encoded string. That way you can i.e. set the value by API, even if value is not utf-8 compatible and would otherwise fail during json conversion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import base64 ... # other imports skipped for brevity class LargeBinaryStr ( ormar . Model ): class Meta : tablename = \"my_str_blobs\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) test_binary : str = ormar . LargeBinary ( max_length = 100000 , represent_as_base64_str = True ) # set non utf-8 compliant value - note this can be passed by api (i.e. fastapi) in json item = LargeBinaryStr ( test_binary = base64 . b64encode ( b \" \\xc3\\x28 \" ) . decode ()) assert item . test_binary == base64 . b64encode ( b \" \\xc3\\x28 \" ) . decode () # technical note that underlying value is still bytes and will be saved as so assert item . __dict__ [ \"test_binary\" ] == b \" \\xc3\\x28 \"","title":"LargeBinary"},{"location":"fields/field-types/#uuid","text":"UUID(uuid_format: str = 'hex') has no required parameters. Sqlalchemy column: ormar.UUID based on sqlalchemy.CHAR(36) or sqlalchemy.CHAR(32) field (for string or hex format respectively) Type (used for pydantic): uuid.UUID uuid_format parameters allow 'hex'(default) or 'string' values. Depending on the format either 32 or 36 char is used in the database. Sample: 'hex' format value = c616ab438cce49dbbf4380d109251dce (CHAR(32)) 'string' value = c616ab43-8cce-49db-bf43-80d109251dce (CHAR(36)) When loaded it's always python UUID so you can compare it and compare two formats values between each other.","title":"UUID"},{"location":"fields/field-types/#enum","text":"Although there is no dedicated field type for Enums in ormar you can change any field into Enum like field by passing a choices list that is accepted by all Field types. It will add both: validation in pydantic model and will display available options in schema, therefore it will be available in docs of fastapi . If you still want to use Enum in your application you can do this by passing a Enum into choices and later pass value of given option to a given field (note tha Enum is not JsonSerializable). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # not that imports and endpoints declaration # is skipped here for brevity from enum import Enum class TestEnum ( Enum ): val1 = 'Val1' val2 = 'Val2' class TestModel ( ormar . Model ): class Meta : tablename = \"org\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) # pass list(Enum) to choices enum_string : str = ormar . String ( max_length = 100 , choices = list ( TestEnum )) # sample payload coming to fastapi response = client . post ( \"/test_models/\" , json = { \"id\" : 1 , # you need to refer to the value of the `Enum` option # if called like this, alternatively just use value # string \"Val1\" in this case \"enum_string\" : TestEnum . val1 . value }, )","title":"Enum"},{"location":"fields/pydantic-fields/","text":"Pydantic only fields Ormar allows you to declare normal pydantic fields in its model, so you have access to all basic and custom pydantic fields like str , int , HttpUrl , PaymentCardNumber etc. You can even declare fields leading to nested pydantic only Models, not only single fields. Since those fields are not stored in database (that's the whole point of those fields), you have to provide a meaningful value for them, either by setting a default one or providing one during model initialization. If ormar cannot resolve the value for pydantic field it will fail during loading data from the database, with missing required value for declared pydantic field. Options to provide a value are described below. Of course you can combine few or all of them in one model. Optional field If you set a field as Optional , it defaults to None if not provided and that's exactly what's going to happen during loading from database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class ModelTest ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) number : Optional [ PaymentCardNumber ] test = ModelTest ( name = \"Test\" ) assert test . name == \"Test\" assert test . number is None test . number = \"123456789015\" await test . save () test_check = await ModelTest . objects . get () assert test_check . name == \"Test\" # after load it's back to None assert test_check . number is None Field with default value By setting a default value, this value will be set on initialization and database load. Note that setting a default to None is the same as setting the field to Optional . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class ModelTest ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) url : HttpUrl = \"https://www.example.com\" test = ModelTest ( name = \"Test\" ) assert test . name == \"Test\" assert test . url == \"https://www.example.com\" test . url = \"https://www.sdta.ada.pt\" assert test . url == \"https://www.sdta.ada.pt\" await test . save () test_check = await ModelTest . objects . get () assert test_check . name == \"Test\" # after load it's back to default assert test_check . url == \"https://www.example.com\" Default factory function By setting a default_factory function, this result of the function call will be set on initialization and each database load. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from pydantic import Field , PaymentCardNumber # ... database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database CARD_NUMBERS = [ \"123456789007\" , \"123456789015\" , \"123456789023\" , \"123456789031\" , \"123456789049\" , ] def get_number (): return random . choice ( CARD_NUMBERS ) class ModelTest2 ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) # note that you do not call the function, just pass reference number : PaymentCardNumber = Field ( default_factory = get_number ) # note that you still CAN provide a value test = ModelTest2 ( name = \"Test2\" , number = \"4000000000000002\" ) assert test . name == \"Test2\" assert test . number == \"4000000000000002\" await test . save () test_check = await ModelTest2 . objects . get () assert test_check . name == \"Test2\" # after load value is set to be one of the CARD_NUMBERS assert test_check . number in CARD_NUMBERS assert test_check . number != test . number Custom setup in __init__ You can provide a value for the field in your __init__() method before calling a super() init method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pydantic import BaseModel # ... database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class PydanticTest ( BaseModel ): aa : str bb : int class ModelTest3 ( ormar . Model ): class Meta ( BaseMeta ): pass # provide your custom init function def __init__ ( self , ** kwargs ): # add value for required field without default value kwargs [ \"pydantic_test\" ] = PydanticTest ( aa = \"random\" , bb = 42 ) # remember to call ormar.Model init! super () . __init__ ( ** kwargs ) id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) pydantic_test : PydanticTest test = ModelTest3 ( name = \"Test3\" ) assert test . name == \"Test3\" assert test . pydantic_test . bb == 42 test . pydantic . aa = \"new value\" assert test . pydantic . aa == \"new value\" await test . save () test_check = await ModelTest3 . objects . get () assert test_check . name == \"Test3\" # after load it's back to value provided in init assert test_check . pydantic_test . aa == \"random\" Warning If you do not provide a value in one of the above ways ValidationError will be raised on load from database.","title":"Pydantic only fields"},{"location":"fields/pydantic-fields/#pydantic-only-fields","text":"Ormar allows you to declare normal pydantic fields in its model, so you have access to all basic and custom pydantic fields like str , int , HttpUrl , PaymentCardNumber etc. You can even declare fields leading to nested pydantic only Models, not only single fields. Since those fields are not stored in database (that's the whole point of those fields), you have to provide a meaningful value for them, either by setting a default one or providing one during model initialization. If ormar cannot resolve the value for pydantic field it will fail during loading data from the database, with missing required value for declared pydantic field. Options to provide a value are described below. Of course you can combine few or all of them in one model.","title":"Pydantic only fields"},{"location":"fields/pydantic-fields/#optional-field","text":"If you set a field as Optional , it defaults to None if not provided and that's exactly what's going to happen during loading from database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class ModelTest ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) number : Optional [ PaymentCardNumber ] test = ModelTest ( name = \"Test\" ) assert test . name == \"Test\" assert test . number is None test . number = \"123456789015\" await test . save () test_check = await ModelTest . objects . get () assert test_check . name == \"Test\" # after load it's back to None assert test_check . number is None","title":"Optional field"},{"location":"fields/pydantic-fields/#field-with-default-value","text":"By setting a default value, this value will be set on initialization and database load. Note that setting a default to None is the same as setting the field to Optional . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class ModelTest ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) url : HttpUrl = \"https://www.example.com\" test = ModelTest ( name = \"Test\" ) assert test . name == \"Test\" assert test . url == \"https://www.example.com\" test . url = \"https://www.sdta.ada.pt\" assert test . url == \"https://www.sdta.ada.pt\" await test . save () test_check = await ModelTest . objects . get () assert test_check . name == \"Test\" # after load it's back to default assert test_check . url == \"https://www.example.com\"","title":"Field with default value"},{"location":"fields/pydantic-fields/#default-factory-function","text":"By setting a default_factory function, this result of the function call will be set on initialization and each database load. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from pydantic import Field , PaymentCardNumber # ... database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database CARD_NUMBERS = [ \"123456789007\" , \"123456789015\" , \"123456789023\" , \"123456789031\" , \"123456789049\" , ] def get_number (): return random . choice ( CARD_NUMBERS ) class ModelTest2 ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) # note that you do not call the function, just pass reference number : PaymentCardNumber = Field ( default_factory = get_number ) # note that you still CAN provide a value test = ModelTest2 ( name = \"Test2\" , number = \"4000000000000002\" ) assert test . name == \"Test2\" assert test . number == \"4000000000000002\" await test . save () test_check = await ModelTest2 . objects . get () assert test_check . name == \"Test2\" # after load value is set to be one of the CARD_NUMBERS assert test_check . number in CARD_NUMBERS assert test_check . number != test . number","title":"Default factory function"},{"location":"fields/pydantic-fields/#custom-setup-in-__init__","text":"You can provide a value for the field in your __init__() method before calling a super() init method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pydantic import BaseModel # ... database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class PydanticTest ( BaseModel ): aa : str bb : int class ModelTest3 ( ormar . Model ): class Meta ( BaseMeta ): pass # provide your custom init function def __init__ ( self , ** kwargs ): # add value for required field without default value kwargs [ \"pydantic_test\" ] = PydanticTest ( aa = \"random\" , bb = 42 ) # remember to call ormar.Model init! super () . __init__ ( ** kwargs ) id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) pydantic_test : PydanticTest test = ModelTest3 ( name = \"Test3\" ) assert test . name == \"Test3\" assert test . pydantic_test . bb == 42 test . pydantic . aa = \"new value\" assert test . pydantic . aa == \"new value\" await test . save () test_check = await ModelTest3 . objects . get () assert test_check . name == \"Test3\" # after load it's back to value provided in init assert test_check . pydantic_test . aa == \"random\" Warning If you do not provide a value in one of the above ways ValidationError will be raised on load from database.","title":"Custom setup in __init__"},{"location":"models/","text":"Models Defining models By defining an ormar Model you get corresponding Pydantic model as well as Sqlalchemy table for free. They are being managed in the background and you do not have to create them on your own. Model Class To build an ormar model you simply need to inherit a ormar.Model class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Defining Fields Next assign one or more of the Fields as a class level variables. Basic Field Types Each table has to have a primary key column, which you specify by setting primary_key=True on selected field. Only one primary key column is allowed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Warning Not assigning primary_key column or assigning more than one column per Model will raise ModelDefinitionError exception. By default if you assign primary key to Integer field, the autoincrement option is set to true. You can disable by passing autoincrement=False . 1 id : int = ormar . Integer ( primary_key = True , autoincrement = False ) Non Database Fields Note that if you need a normal pydantic field in your model (used to store value on model or pass around some value) you can define a field with parameter pydantic_only=True . Fields created like this are added to the pydantic model fields -> so are subject to validation according to Field type, also appear in dict() and json() result. The difference is that those fields are not saved in the database . So they won't be included in underlying sqlalchemy columns , or table variables (check Internals section below to see how you can access those if you need). Subsequently pydantic_only fields won't be included in migrations or any database operation (like save , update etc.) Fields like those can be passed around into payload in fastapi request and will be returned in fastapi response (of course only if you set their value somewhere in your code as the value is not fetched from the db. If you pass a value in fastapi request and return the same instance that fastapi constructs for you in request_model you should get back exactly same value in response .). Warning pydantic_only=True fields are always Optional and it cannot be changed (otherwise db load validation would fail) Tip pydantic_only=True fields are a good solution if you need to pass additional information from outside of your API (i.e. frontend). They are not stored in db but you can access them in your APIRoute code and they also have pydantic validation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) non_db_field : str = ormar . String ( max_length = 100 , pydantic_only = True ) If you combine pydantic_only=True field with default parameter and do not pass actual value in request you will always get default value. Since it can be a function you can set default=datetime.datetime.now and get current timestamp each time you call an endpoint etc. Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==related of code removed for clarity==> class User ( ormar . Model ): class Meta : tablename : str = \"users2\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 , nullable = False ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , nullable = True ) timestamp : datetime . datetime = ormar . DateTime ( pydantic_only = True , default = datetime . datetime . now ) # <==related of code removed for clarity==> app = FastAPI () @app . post ( \"/users/\" ) async def create_user ( user : User ): return await user . save () # <==related of code removed for clarity==> def test_excluding_fields_in_endpoints (): client = TestClient ( app ) with client as client : timestamp = datetime . datetime . now () user = { \"email\" : \"test@domain.com\" , \"password\" : \"^*^%A*DA*IAAA\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"timestamp\" : str ( timestamp ), } response = client . post ( \"/users/\" , json = user ) assert list ( response . json () . keys ()) == [ \"id\" , \"email\" , \"first_name\" , \"last_name\" , \"category\" , \"timestamp\" , ] # returned is the same timestamp assert response . json () . get ( \"timestamp\" ) == str ( timestamp ) . replace ( \" \" , \"T\" ) # <==related of code removed for clarity==> Property fields Sometimes it's desirable to do some kind of calculation on the model instance. One of the most common examples can be concatenating two or more fields. Imagine you have first_name and last_name fields on your model, but would like to have full_name in the result of the fastapi query. You can create a new pydantic model with a method that accepts only self (so like default python @property ) and populate it in your code. But it's so common that ormar has you covered. You can \"materialize\" a property_field on you Model . Warning property_field fields are always Optional and it cannot be changed (otherwise db load validation would fail) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar from ormar import property_field database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) @property_field def prefixed_name ( self ): return 'custom_prefix__' + self . name Warning The decorated function has to accept only one parameter, and that parameter have to be self . If you try to decorate a function with more parameters ormar will raise ModelDefinitionError . Sample: 1 2 3 4 5 6 7 8 9 10 # will raise ModelDefinitionError @property_field def prefixed_name ( self , prefix = \"prefix_\" ): return 'custom_prefix__' + self . name # will raise ModelDefinitionError # (calling first param something else than 'self' is a bad practice anyway) @property_field def prefixed_name ( instance ): return 'custom_prefix__' + self . name Note that property_field decorated methods do not go through verification (but that might change in future) and are only available in the response from fastapi and dict() and json() methods. You cannot pass a value for this field in the request (or rather you can but it will be discarded by ormar so really no point but no Exception will be raised). Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. Tip Note that @property_field decorator is designed to replace the python @property decorator, you do not have to combine them. In theory you can cause ormar have a failsafe mechanism, but note that i.e. mypy will complain about re-decorating a property. 1 2 3 4 5 # valid and working but unnecessary and mypy will complain @property_field @property def prefixed_name ( self ): return 'custom_prefix__' + self . name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==related of code removed for clarity==> def gen_pass (): # note: NOT production ready choices = string . ascii_letters + string . digits + \"!@#$%^&*()\" return \"\" . join ( random . choice ( choices ) for _ in range ( 20 )) class RandomModel ( ormar . Model ): class Meta : tablename : str = \"random_users\" metadata = metadata database = database include_props_in_dict = True id : int = ormar . Integer ( primary_key = True ) password : str = ormar . String ( max_length = 255 , default = gen_pass ) first_name : str = ormar . String ( max_length = 255 , default = \"John\" ) last_name : str = ormar . String ( max_length = 255 ) created_date : datetime . datetime = ormar . DateTime ( server_default = sqlalchemy . func . now () ) @property_field def full_name ( self ) -> str : return \" \" . join ([ self . first_name , self . last_name ]) # <==related of code removed for clarity==> app = FastAPI () # explicitly exclude property_field in this endpoint @app . post ( \"/random/\" , response_model = RandomModel , response_model_exclude = { \"full_name\" }) async def create_user ( user : RandomModel ): return await user . save () # <==related of code removed for clarity==> def test_excluding_property_field_in_endpoints2 (): client = TestClient ( app ) with client as client : RandomModel . Meta . include_props_in_dict = True user3 = { \"last_name\" : \"Test\" } response = client . post ( \"/random3/\" , json = user3 ) assert list ( response . json () . keys ()) == [ \"id\" , \"password\" , \"first_name\" , \"last_name\" , \"created_date\" , ] # despite being decorated with property_field if you explictly exclude it it will be gone assert response . json () . get ( \"full_name\" ) is None # <==related of code removed for clarity==> Fields names vs Column names By default names of the fields will be used for both the underlying pydantic model and sqlalchemy table. If for whatever reason you prefer to change the name in the database but keep the name in the model you can do this with specifying name parameter during Field declaration Here you have a sample model with changed names 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Child ( ormar . Model ): class Meta : tablename = \"children\" metadata = metadata database = database id : int = ormar . Integer ( name = \"child_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year_born\" , nullable = True ) Note that you can also change the ForeignKey column name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from typing import Optional import databases import sqlalchemy import ormar from .docs010 import Artist # previous example database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"music_albums\" metadata = metadata database = database id : int = ormar . Integer ( name = \"album_id\" , primary_key = True ) name : str = ormar . String ( name = \"album_name\" , max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist , name = \"artist_id\" ) But for now you cannot change the ManyToMany column names as they go through other Model anyway. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import sqlalchemy import ormar from .docs008 import Child database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class ArtistChildren ( ormar . Model ): class Meta : tablename = \"children_x_artists\" metadata = metadata database = database class Artist ( ormar . Model ): class Meta : tablename = \"artists\" metadata = metadata database = database id : int = ormar . Integer ( name = \"artist_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) children = ormar . ManyToMany ( Child , through = ArtistChildren ) Type Hints & Legacy Before version 0.4.0 ormar supported only one way of defining Fields on a Model using python type hints as pydantic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () But that didn't play well with static type checkers like mypy and pydantic PyCharm plugin. Therefore from version >=0.4.0 ormar switched to new notation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Note that type hints are optional so perfectly valid ormar code can look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Warning Even if you use type hints ormar does not use them to construct pydantic fields! Type hints are there only to support static checkers and linting, ormar construct annotations used by pydantic from own fields. Dependencies Since ormar depends on databases and sqlalchemy-core for database connection and table creation you need to assign each Model with two special parameters. Databases One is Database instance created with your database url in sqlalchemy connection string format. Created instance needs to be passed to every Model with Meta class database parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the Database instance only once and use it for all models. You can create several ones if you want to use multiple databases. Sqlalchemy Second dependency is sqlalchemy MetaData instance. Created instance needs to be passed to every Model with Meta class metadata parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the MetaData instance only once and use it for all models. You can create several ones if you want to use multiple databases. Best practice Only thing that ormar expects is a class with name Meta and two class variables: metadata and databases . So instead of providing the same parameters over and over again for all models you should creata a class and subclass it in all models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () # note that you do not have to subclass ModelMeta, # it's useful for type hints and code completion class MainMeta ( ormar . ModelMeta ): metadata = metadata database = database class Artist ( ormar . Model ): class Meta ( MainMeta ): # note that tablename is optional # if not provided ormar will user class.__name__.lower()+'s' # -> artists in this example pass id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 100 ) last_name : str = ormar . String ( max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) class Album ( ormar . Model ): class Meta ( MainMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist ) Warning You need to subclass your MainMeta class in each Model class as those classes store configuration variables that otherwise would be overwritten by each Model . Table Names By default table name is created from Model class name as lowercase name plus 's'. You can overwrite this parameter by providing Meta class tablename argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : # if you omit this parameter it will be created automatically # as class.__name__.lower()+'s' -> \"courses\" in this example tablename = \"my_courses\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Constraints On a model level you can also set model-wise constraints on sql columns. Right now only UniqueColumns constraint is present. Tip To read more about columns constraints like primary_key , unique , ForeignKey etc. visit fields . You can set this parameter by providing Meta class constraints argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata # define your constraints in Meta class of the model # it's a list that can contain multiple constraints # hera a combination of name and column will have to be unique in db constraints = [ ormar . UniqueColumns ( \"name\" , \"completed\" )] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Note Note that constraints are meant for combination of columns that should be unique. To set one column as unique use unique common parameter. Of course you can set many columns as unique with this param but each of them will be checked separately. Pydantic configuration As each ormar.Model is also a pydantic model, you might want to tweak the settings of the pydantic configuration. The way to do this in pydantic is to adjust the settings on the Config class provided to your model, and it works exactly the same for ormer.Models. So in order to set your own preferences you need to provide not only the Meta class but also the Config class to your model. Note To read more about available settings visit the pydantic config page. Note that if you do not provide your own configuration, ormar will do it for you. The default config provided is as follows: 1 2 3 class Config ( pydantic . BaseConfig ): orm_mode = True validate_assignment = True So to overwrite setting or provide your own a sample model can look like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata class Config : allow_mutation = False id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Model sort order When querying the database with given model by default the Model is ordered by the primary_key column ascending. If you wish to change the default behaviour you can do it by providing orders_by parameter to model Meta class. Sample default ordering: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database # default sort by column id ascending class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) Modified 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database # now default sort by name descending class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" orders_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) Model Initialization There are two ways to create and persist the Model instance in the database. Tip Use ipython to try this from the console, since it supports await . If you plan to modify the instance in the later execution of your program you can initiate your Model as a normal class and later await a save() call. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) If you want to initiate your Model and at the same time save in in the database use a QuerySet's method create() . For creating multiple objects at once a bulk_create() QuerySet's method is available. Each model has a QuerySet initialised as objects parameter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) Info To read more about QuerySets (including bulk operations) and available methods visit queries Model save status Each model instance is a separate python object and they do not know anything about each other. 1 2 3 4 5 6 7 8 track1 = await Track . objects . get ( name = 'The Bird' ) track2 = await Track . objects . get ( name = 'The Bird' ) assert track1 == track2 # True track1 . name = 'The Bird2' await track1 . save () assert track1 . name == track2 . name # False # track2 does not update and knows nothing about track1 The objects itself have a saved status, which is set as following: Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantiation with __init__ (w/o QuerySet.create or before calling save ) You can check if model is saved with ModelInstance.saved property","title":"Definition"},{"location":"models/#models","text":"","title":"Models"},{"location":"models/#defining-models","text":"By defining an ormar Model you get corresponding Pydantic model as well as Sqlalchemy table for free. They are being managed in the background and you do not have to create them on your own.","title":"Defining models"},{"location":"models/#model-class","text":"To build an ormar model you simply need to inherit a ormar.Model class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Model Class"},{"location":"models/#defining-fields","text":"Next assign one or more of the Fields as a class level variables.","title":"Defining Fields"},{"location":"models/#basic-field-types","text":"Each table has to have a primary key column, which you specify by setting primary_key=True on selected field. Only one primary key column is allowed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Warning Not assigning primary_key column or assigning more than one column per Model will raise ModelDefinitionError exception. By default if you assign primary key to Integer field, the autoincrement option is set to true. You can disable by passing autoincrement=False . 1 id : int = ormar . Integer ( primary_key = True , autoincrement = False )","title":"Basic Field Types"},{"location":"models/#non-database-fields","text":"Note that if you need a normal pydantic field in your model (used to store value on model or pass around some value) you can define a field with parameter pydantic_only=True . Fields created like this are added to the pydantic model fields -> so are subject to validation according to Field type, also appear in dict() and json() result. The difference is that those fields are not saved in the database . So they won't be included in underlying sqlalchemy columns , or table variables (check Internals section below to see how you can access those if you need). Subsequently pydantic_only fields won't be included in migrations or any database operation (like save , update etc.) Fields like those can be passed around into payload in fastapi request and will be returned in fastapi response (of course only if you set their value somewhere in your code as the value is not fetched from the db. If you pass a value in fastapi request and return the same instance that fastapi constructs for you in request_model you should get back exactly same value in response .). Warning pydantic_only=True fields are always Optional and it cannot be changed (otherwise db load validation would fail) Tip pydantic_only=True fields are a good solution if you need to pass additional information from outside of your API (i.e. frontend). They are not stored in db but you can access them in your APIRoute code and they also have pydantic validation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) non_db_field : str = ormar . String ( max_length = 100 , pydantic_only = True ) If you combine pydantic_only=True field with default parameter and do not pass actual value in request you will always get default value. Since it can be a function you can set default=datetime.datetime.now and get current timestamp each time you call an endpoint etc. Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==related of code removed for clarity==> class User ( ormar . Model ): class Meta : tablename : str = \"users2\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 , nullable = False ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , nullable = True ) timestamp : datetime . datetime = ormar . DateTime ( pydantic_only = True , default = datetime . datetime . now ) # <==related of code removed for clarity==> app = FastAPI () @app . post ( \"/users/\" ) async def create_user ( user : User ): return await user . save () # <==related of code removed for clarity==> def test_excluding_fields_in_endpoints (): client = TestClient ( app ) with client as client : timestamp = datetime . datetime . now () user = { \"email\" : \"test@domain.com\" , \"password\" : \"^*^%A*DA*IAAA\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"timestamp\" : str ( timestamp ), } response = client . post ( \"/users/\" , json = user ) assert list ( response . json () . keys ()) == [ \"id\" , \"email\" , \"first_name\" , \"last_name\" , \"category\" , \"timestamp\" , ] # returned is the same timestamp assert response . json () . get ( \"timestamp\" ) == str ( timestamp ) . replace ( \" \" , \"T\" ) # <==related of code removed for clarity==>","title":"Non Database Fields"},{"location":"models/#property-fields","text":"Sometimes it's desirable to do some kind of calculation on the model instance. One of the most common examples can be concatenating two or more fields. Imagine you have first_name and last_name fields on your model, but would like to have full_name in the result of the fastapi query. You can create a new pydantic model with a method that accepts only self (so like default python @property ) and populate it in your code. But it's so common that ormar has you covered. You can \"materialize\" a property_field on you Model . Warning property_field fields are always Optional and it cannot be changed (otherwise db load validation would fail) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar from ormar import property_field database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) @property_field def prefixed_name ( self ): return 'custom_prefix__' + self . name Warning The decorated function has to accept only one parameter, and that parameter have to be self . If you try to decorate a function with more parameters ormar will raise ModelDefinitionError . Sample: 1 2 3 4 5 6 7 8 9 10 # will raise ModelDefinitionError @property_field def prefixed_name ( self , prefix = \"prefix_\" ): return 'custom_prefix__' + self . name # will raise ModelDefinitionError # (calling first param something else than 'self' is a bad practice anyway) @property_field def prefixed_name ( instance ): return 'custom_prefix__' + self . name Note that property_field decorated methods do not go through verification (but that might change in future) and are only available in the response from fastapi and dict() and json() methods. You cannot pass a value for this field in the request (or rather you can but it will be discarded by ormar so really no point but no Exception will be raised). Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. Tip Note that @property_field decorator is designed to replace the python @property decorator, you do not have to combine them. In theory you can cause ormar have a failsafe mechanism, but note that i.e. mypy will complain about re-decorating a property. 1 2 3 4 5 # valid and working but unnecessary and mypy will complain @property_field @property def prefixed_name ( self ): return 'custom_prefix__' + self . name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==related of code removed for clarity==> def gen_pass (): # note: NOT production ready choices = string . ascii_letters + string . digits + \"!@#$%^&*()\" return \"\" . join ( random . choice ( choices ) for _ in range ( 20 )) class RandomModel ( ormar . Model ): class Meta : tablename : str = \"random_users\" metadata = metadata database = database include_props_in_dict = True id : int = ormar . Integer ( primary_key = True ) password : str = ormar . String ( max_length = 255 , default = gen_pass ) first_name : str = ormar . String ( max_length = 255 , default = \"John\" ) last_name : str = ormar . String ( max_length = 255 ) created_date : datetime . datetime = ormar . DateTime ( server_default = sqlalchemy . func . now () ) @property_field def full_name ( self ) -> str : return \" \" . join ([ self . first_name , self . last_name ]) # <==related of code removed for clarity==> app = FastAPI () # explicitly exclude property_field in this endpoint @app . post ( \"/random/\" , response_model = RandomModel , response_model_exclude = { \"full_name\" }) async def create_user ( user : RandomModel ): return await user . save () # <==related of code removed for clarity==> def test_excluding_property_field_in_endpoints2 (): client = TestClient ( app ) with client as client : RandomModel . Meta . include_props_in_dict = True user3 = { \"last_name\" : \"Test\" } response = client . post ( \"/random3/\" , json = user3 ) assert list ( response . json () . keys ()) == [ \"id\" , \"password\" , \"first_name\" , \"last_name\" , \"created_date\" , ] # despite being decorated with property_field if you explictly exclude it it will be gone assert response . json () . get ( \"full_name\" ) is None # <==related of code removed for clarity==>","title":"Property fields"},{"location":"models/#fields-names-vs-column-names","text":"By default names of the fields will be used for both the underlying pydantic model and sqlalchemy table. If for whatever reason you prefer to change the name in the database but keep the name in the model you can do this with specifying name parameter during Field declaration Here you have a sample model with changed names 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Child ( ormar . Model ): class Meta : tablename = \"children\" metadata = metadata database = database id : int = ormar . Integer ( name = \"child_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year_born\" , nullable = True ) Note that you can also change the ForeignKey column name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from typing import Optional import databases import sqlalchemy import ormar from .docs010 import Artist # previous example database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"music_albums\" metadata = metadata database = database id : int = ormar . Integer ( name = \"album_id\" , primary_key = True ) name : str = ormar . String ( name = \"album_name\" , max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist , name = \"artist_id\" ) But for now you cannot change the ManyToMany column names as they go through other Model anyway. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import sqlalchemy import ormar from .docs008 import Child database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class ArtistChildren ( ormar . Model ): class Meta : tablename = \"children_x_artists\" metadata = metadata database = database class Artist ( ormar . Model ): class Meta : tablename = \"artists\" metadata = metadata database = database id : int = ormar . Integer ( name = \"artist_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) children = ormar . ManyToMany ( Child , through = ArtistChildren )","title":"Fields names vs Column names"},{"location":"models/#type-hints-legacy","text":"Before version 0.4.0 ormar supported only one way of defining Fields on a Model using python type hints as pydantic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () But that didn't play well with static type checkers like mypy and pydantic PyCharm plugin. Therefore from version >=0.4.0 ormar switched to new notation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Note that type hints are optional so perfectly valid ormar code can look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Warning Even if you use type hints ormar does not use them to construct pydantic fields! Type hints are there only to support static checkers and linting, ormar construct annotations used by pydantic from own fields.","title":"Type Hints &amp; Legacy"},{"location":"models/#dependencies","text":"Since ormar depends on databases and sqlalchemy-core for database connection and table creation you need to assign each Model with two special parameters.","title":"Dependencies"},{"location":"models/#databases","text":"One is Database instance created with your database url in sqlalchemy connection string format. Created instance needs to be passed to every Model with Meta class database parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the Database instance only once and use it for all models. You can create several ones if you want to use multiple databases.","title":"Databases"},{"location":"models/#sqlalchemy","text":"Second dependency is sqlalchemy MetaData instance. Created instance needs to be passed to every Model with Meta class metadata parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the MetaData instance only once and use it for all models. You can create several ones if you want to use multiple databases.","title":"Sqlalchemy"},{"location":"models/#best-practice","text":"Only thing that ormar expects is a class with name Meta and two class variables: metadata and databases . So instead of providing the same parameters over and over again for all models you should creata a class and subclass it in all models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () # note that you do not have to subclass ModelMeta, # it's useful for type hints and code completion class MainMeta ( ormar . ModelMeta ): metadata = metadata database = database class Artist ( ormar . Model ): class Meta ( MainMeta ): # note that tablename is optional # if not provided ormar will user class.__name__.lower()+'s' # -> artists in this example pass id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 100 ) last_name : str = ormar . String ( max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) class Album ( ormar . Model ): class Meta ( MainMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist ) Warning You need to subclass your MainMeta class in each Model class as those classes store configuration variables that otherwise would be overwritten by each Model .","title":"Best practice"},{"location":"models/#table-names","text":"By default table name is created from Model class name as lowercase name plus 's'. You can overwrite this parameter by providing Meta class tablename argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : # if you omit this parameter it will be created automatically # as class.__name__.lower()+'s' -> \"courses\" in this example tablename = \"my_courses\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Table Names"},{"location":"models/#constraints","text":"On a model level you can also set model-wise constraints on sql columns. Right now only UniqueColumns constraint is present. Tip To read more about columns constraints like primary_key , unique , ForeignKey etc. visit fields . You can set this parameter by providing Meta class constraints argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata # define your constraints in Meta class of the model # it's a list that can contain multiple constraints # hera a combination of name and column will have to be unique in db constraints = [ ormar . UniqueColumns ( \"name\" , \"completed\" )] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Note Note that constraints are meant for combination of columns that should be unique. To set one column as unique use unique common parameter. Of course you can set many columns as unique with this param but each of them will be checked separately.","title":"Constraints"},{"location":"models/#pydantic-configuration","text":"As each ormar.Model is also a pydantic model, you might want to tweak the settings of the pydantic configuration. The way to do this in pydantic is to adjust the settings on the Config class provided to your model, and it works exactly the same for ormer.Models. So in order to set your own preferences you need to provide not only the Meta class but also the Config class to your model. Note To read more about available settings visit the pydantic config page. Note that if you do not provide your own configuration, ormar will do it for you. The default config provided is as follows: 1 2 3 class Config ( pydantic . BaseConfig ): orm_mode = True validate_assignment = True So to overwrite setting or provide your own a sample model can look like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata class Config : allow_mutation = False id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Pydantic configuration"},{"location":"models/#model-sort-order","text":"When querying the database with given model by default the Model is ordered by the primary_key column ascending. If you wish to change the default behaviour you can do it by providing orders_by parameter to model Meta class. Sample default ordering: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database # default sort by column id ascending class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) Modified 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database # now default sort by name descending class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" orders_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 )","title":"Model sort order"},{"location":"models/#model-initialization","text":"There are two ways to create and persist the Model instance in the database. Tip Use ipython to try this from the console, since it supports await . If you plan to modify the instance in the later execution of your program you can initiate your Model as a normal class and later await a save() call. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) If you want to initiate your Model and at the same time save in in the database use a QuerySet's method create() . For creating multiple objects at once a bulk_create() QuerySet's method is available. Each model has a QuerySet initialised as objects parameter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) Info To read more about QuerySets (including bulk operations) and available methods visit queries","title":"Model Initialization"},{"location":"models/#model-save-status","text":"Each model instance is a separate python object and they do not know anything about each other. 1 2 3 4 5 6 7 8 track1 = await Track . objects . get ( name = 'The Bird' ) track2 = await Track . objects . get ( name = 'The Bird' ) assert track1 == track2 # True track1 . name = 'The Bird2' await track1 . save () assert track1 . name == track2 . name # False # track2 does not update and knows nothing about track1 The objects itself have a saved status, which is set as following: Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantiation with __init__ (w/o QuerySet.create or before calling save ) You can check if model is saved with ModelInstance.saved property","title":"Model save status"},{"location":"models/inheritance/","text":"Inheritance Out of various types of ORM models inheritance ormar currently supports two of them: Mixins Concrete table inheritance (with parents set to abstract=True ) Types of inheritance The short summary of different types of inheritance is: Mixins [SUPPORTED] - don't subclass ormar.Model , just define fields that are later used on different models (like created_date and updated_date on each model), only actual models create tables, but those fields from mixins are added Concrete table inheritance [SUPPORTED] - means that parent is marked as abstract and each child has its own table with columns from a parent and own child columns, kind of similar to Mixins but parent also is a Model Single table inheritance [NOT SUPPORTED] - means that only one table is created with fields that are combination/sum of the parent and all children models but child models use only subset of column in db (all parent and own ones, skipping the other children ones) Multi/ Joined table inheritance [NOT SUPPORTED] - means that part of the columns is saved on parent model and part is saved on child model that are connected to each other by kind of one to one relation and under the hood you operate on two models at once Proxy models [NOT SUPPORTED] - means that only parent has an actual table, children just add methods, modify settings etc. Mixins To use Mixins just define a class that is not inheriting from an ormar.Model but is defining ormar.Fields as class variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # a mixin defines the fields but is a normal python class class AuditMixin : created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) class DateFieldsMixins : created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # a models can inherit from one or more mixins class Category ( ormar . Model , DateFieldsMixins , AuditMixin ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () Tip Note that Mixins are not models, so you still need to inherit from ormar.Model as well as define Meta class in the final model. A Category class above will have four additional fields: created_date , updated_date , created_by and updated_by . There will be only one table created for model Category ( categories ), with Category class fields combined with all Mixins fields. Note that Mixin in class name is optional but is a good python practice. Concrete table inheritance In concept concrete table inheritance is very similar to Mixins, but uses actual ormar.Models as base classes. Warning Note that base classes have abstract=True set in Meta class, if you try to inherit from non abstract marked class ModelDefinitionError will be raised. Since this abstract Model will never be initialized you can skip metadata and database in it's Meta definition. But if you provide it - it will be inherited, that way you do not have to provide metadata and databases in the final/concrete class Note that you can always overwrite it in child/concrete class if you need to. More over at least one of the classes in inheritance chain have to provide both database and metadata - otherwise an error will be raised. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # note that base classes have abstract=True # since this model will never be initialized you can skip metadata and database class AuditModel ( ormar . Model ): class Meta : abstract = True created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) # but if you provide it it will be inherited - DRY (Don't Repeat Yourself) in action class DateFieldsModel ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # that way you do not have to provide metadata and databases in concrete class class Category ( DateFieldsModel , AuditModel ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () The list of inherited options/settings is as follows: metadata , database and constraints . Also methods decorated with @property_field decorator will be inherited/recognized. Of course apart from that all fields from base classes are combined and created in the concrete table of the final Model. Tip Note how you don't have to provide abstarct=False in the final class - it's the default setting that is not inherited. Redefining fields in subclasses Note that you can redefine previously created fields like in normal python class inheritance. Whenever you define a field with same name and new definition it will completely replace the previously defined one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # base class class DateFieldsModel ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db # note that UniqueColumns need sqlalchemy db columns names not the ormar ones constraints = [ ormar . UniqueColumns ( \"creation_date\" , \"modification_date\" )] created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"creation_date\" ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"modification_date\" ) class RedefinedField ( DateFieldsModel ): class Meta ( ormar . ModelMeta ): tablename = \"redefines\" metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) # here the created_date is replaced by the String field created_date : str = ormar . String ( max_length = 200 , name = \"creation_date\" ) # you can verify that the final field is correctly declared and created changed_field = RedefinedField . Meta . model_fields [ \"created_date\" ] assert changed_field . default is None assert changed_field . alias == \"creation_date\" assert any ( x . name == \"creation_date\" for x in RedefinedField . Meta . table . columns ) assert isinstance ( RedefinedField . Meta . table . columns [ \"creation_date\" ] . type , sqlalchemy . sql . sqltypes . String , ) Warning If you declare UniqueColumns constraint with column names, the final model has to have a column with the same name declared. Otherwise, the ModelDefinitionError will be raised. So in example above if you do not provide name for created_date in RedefinedField model ormar will complain. created_date: str = ormar.String(max_length=200) # exception created_date: str = ormar.String(max_length=200, name=\"creation_date2\") # exception Relations in inheritance You can declare relations in every step of inheritance, so both in parent and child classes. When you define a relation on a child model level it's either overwriting the relation defined in parent model (if the same field name is used), or is accessible only to this child if you define a new relation. When inheriting relations, you always need to be aware of related_name parameter, that has to be unique across a related model, when you define multiple child classes that inherit the same relation. If you do not provide related_name parameter ormar calculates it for you. This works with inheritance as all child models have to have different class names, which are used to calculate the default related_name (class.name.lower()+'s'). But, if you provide a related_name this name cannot be reused in all child models as they would overwrite each other on the related model side. Therefore, you have two options: redefine relation field in child models and manually provide different related_name parameters let this for ormar to handle -> auto adjusted related_name are: original related_name + \"_\" + child model table name That might sound complicated but let's look at the following example: ForeignKey relations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # normal model used in relation class Person ( ormar . Model ): class Meta : metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # parent model - needs to be abstract class Car ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 ) owner : Person = ormar . ForeignKey ( Person ) # note that we refer to the Person model again so we **have to** provide related_name co_owner : Person = ormar . ForeignKey ( Person , related_name = \"coowned\" ) created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) class Truck ( Car ): class Meta : pass max_capacity : int = ormar . Integer () class Bus ( Car ): class Meta : # default naming is name.lower()+'s' so it's ugly for buss ;) tablename = \"buses\" max_persons : int = ormar . Integer () Now when you will inspect the fields on Person model you will get: 1 2 3 4 5 6 7 8 9 Person . Meta . model_fields \"\"\" {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'buss': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_buses': <class 'ormar.fields.foreign_key.ForeignKey'>} \"\"\" Note how you have trucks and buss fields that leads to Truck and Bus class that this Person owns. There were no related_name parameter so default names were used. At the same time the co-owned cars need to be referenced by coowned_trucks and coowned_buses . Ormar appended _trucks and _buses suffixes taken from child model table names. Seems fine, but the default name for owned trucks is ok ( trucks ) but the buss is ugly, so how can we change it? The solution is pretty simple - just redefine the field in Bus class and provide different related_name parameter. 1 2 3 4 5 6 7 8 # rest of the above example remains the same class Bus ( Car ): class Meta : tablename = \"buses\" # new field that changes the related_name owner : Person = ormar . ForeignKey ( Person , related_name = \"buses\" ) max_persons : int = ormar . Integer () Now the columns looks much better. 1 2 3 4 5 6 7 8 9 Person . Meta . model_fields \"\"\" {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'buses': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_buses': <class 'ormar.fields.foreign_key.ForeignKey'>} \"\"\" Note You could also provide related_name for the owner field, that way the proper suffixes would be added. owner: Person = ormar.ForeignKey(Person, related_name=\"owned\") and model fields for Person owned cars would become owned_trucks and owned_buses . ManyToMany relations Similarly, you can inherit from Models that have ManyToMany relations declared but there is one, but substantial difference - the Through model. Since in the future the Through model will be able to hold additional fields and now it links only two Tables ( from and to ones), each child that inherits the m2m relation field has to have separate Through model. Of course, you can overwrite the relation in each Child model, but that requires additional code and undermines the point of the whole inheritance. Ormar will handle this for you if you agree with default naming convention, which you can always manually overwrite in children if needed. Again, let's look at the example to easier grasp the concepts. We will modify the previous example described above to use m2m relation for co_owners. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # person remain the same as above class Person ( ormar . Model ): class Meta : metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # new through model between Person and Car2 class PersonsCar ( ormar . Model ): class Meta : tablename = \"cars_x_persons\" metadata = metadata database = db # note how co_owners is now ManyToMany relation class Car2 ( ormar . Model ): class Meta : # parent class needs to be marked abstract abstract = True metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 ) # note the related_name - needs to be unique across Person # model, regardless of how many different models leads to Person owner : Person = ormar . ForeignKey ( Person , related_name = \"owned\" ) co_owners : List [ Person ] = ormar . ManyToMany ( Person , through = PersonsCar , related_name = \"coowned\" ) created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # child models define only additional Fields class Truck2 ( Car2 ): class Meta : # note how you don't have to provide inherited Meta params tablename = \"trucks2\" max_capacity : int = ormar . Integer () class Bus2 ( Car2 ): class Meta : tablename = \"buses2\" max_persons : int = ormar . Integer () Ormar automatically modifies related_name of the fields to include the table name of the children models. The dafault name is original related_name + '_' + child table name. That way for class Truck2 the relation defined in owner: Person = ormar.ForeignKey(Person, related_name=\"owned\") becomes owned_trucks2 You can verify the names by inspecting the list of fields present on Person model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Person . Meta . model_fields { # note how all relation fields need to be unique on Person # regardless if autogenerated or manually overwritten 'id' : < class ' ormar . fields . model_fields . Integer '>, 'name' : < class ' ormar . fields . model_fields . String '>, # note that we expanded on previous example so all 'old' fields are here 'trucks' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_trucks' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'buses' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_buses' : < class ' ormar . fields . foreign_key . ForeignKey '>, # newly defined related fields 'owned_trucks2' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_trucks2' : < class ' abc . ManyToMany '>, 'owned_buses2' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_buses2' : < class ' abc . ManyToMany '> } But that's not all. It's kind of internal to ormar but affects the data structure in the database, so let's examine the through models for both Bus2 and Truck2 models. 1 2 3 4 5 6 7 8 9 Bus2 . Meta . model_fields [ 'co_owners' ] . through < class ' abc . PersonsCarBus2 '> Bus2 . Meta . model_fields [ 'co_owners' ] . through . Meta . tablename 'cars_x_persons_buses2' Truck2 . Meta . model_fields [ 'co_owners' ] . through < class ' abc . PersonsCarTruck2 '> Truck2 . Meta . model_fields [ 'co_owners' ] . through . Meta . tablename 'cars_x_persons_trucks2' As you can see above ormar cloned the Through model for each of the Child classes and added Child class name at the end, while changing the table names of the cloned fields the name of the table from the child is used. Note that original model is not only not used, the table for this model is removed from metadata: 1 2 3 Bus2 . Meta . metadata . tables . keys () dict_keys ([ 'test_date_models' , 'categories' , 'subjects' , 'persons' , 'trucks' , 'buses' , 'cars_x_persons_trucks2' , 'trucks2' , 'cars_x_persons_buses2' , 'buses2' ]) So be aware that if you introduce inheritance along the way and convert a model into abstract parent model you may lose your data on through table if not careful. Note Note that original table name and model name of the Through model is never used. Only the cloned models tables are created and used. Warning Note that each subclass of the Model that has ManyToMany relation defined generates a new Through model, meaning also new database table . That means that each time you define a Child model you need to either manually create the table in the database, or run a migration (with alembic). exclude_parent_fields Ormar allows you to skip certain fields in inherited model that are coming from a parent model. Note Note that the same behaviour can be achieved by splitting the model into more abstract models and mixins - which is a preferred way in normal circumstances. To skip certain fields from a child model, list all fields that you want to skip in model.Meta.exclude_parent_fields parameter like follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 metadata = sa . MetaData () db = databases . Database ( DATABASE_URL ) class AuditModel ( ormar . Model ): class Meta : abstract = True created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) class DateFieldsModel ( ormar . Model ): class Meta ( ormar . ModelMeta ): abstract = True metadata = metadata database = db created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"creation_date\" ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"modification_date\" ) class Category ( DateFieldsModel , AuditModel ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" # set fields that should be skipped exclude_parent_fields = [ \"updated_by\" , \"updated_date\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () # Note that now the update fields in Category are gone in all places -> ormar fields, pydantic fields and sqlachemy table columns # so full list of available fileds in Category is: [\"created_by\", \"created_date\", \"id\", \"name\", \"code\"] Note how you simply need to provide field names and it will exclude the parent field regardless of from which parent model the field is coming from. Note Note that if you want to overwrite a field in child model you do not have to exclude it, simpy overwrite the field declaration in child model with same field name. Warning Note that this kind of behavior can confuse mypy and static type checkers, yet accessing the non existing fields will fail at runtime. That's why splitting the base classes is preferred. The same effect can be achieved by splitting base classes like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 metadata = sa . MetaData () db = databases . Database ( DATABASE_URL ) class AuditCreateModel ( ormar . Model ): class Meta : abstract = True created_by : str = ormar . String ( max_length = 100 ) class AuditUpdateModel ( ormar . Model ): class Meta : abstract = True updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) class CreateDateFieldsModel ( ormar . Model ): class Meta ( ormar . ModelMeta ): abstract = True metadata = metadata database = db created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"creation_date\" ) class UpdateDateFieldsModel ( ormar . Model ): class Meta ( ormar . ModelMeta ): abstract = True metadata = metadata database = db updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"modification_date\" ) class Category ( CreateDateFieldsModel , AuditCreateModel ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () That way you can inherit from both create and update classes if needed, and only one of them otherwise.","title":"Inheritance"},{"location":"models/inheritance/#inheritance","text":"Out of various types of ORM models inheritance ormar currently supports two of them: Mixins Concrete table inheritance (with parents set to abstract=True )","title":"Inheritance"},{"location":"models/inheritance/#types-of-inheritance","text":"The short summary of different types of inheritance is: Mixins [SUPPORTED] - don't subclass ormar.Model , just define fields that are later used on different models (like created_date and updated_date on each model), only actual models create tables, but those fields from mixins are added Concrete table inheritance [SUPPORTED] - means that parent is marked as abstract and each child has its own table with columns from a parent and own child columns, kind of similar to Mixins but parent also is a Model Single table inheritance [NOT SUPPORTED] - means that only one table is created with fields that are combination/sum of the parent and all children models but child models use only subset of column in db (all parent and own ones, skipping the other children ones) Multi/ Joined table inheritance [NOT SUPPORTED] - means that part of the columns is saved on parent model and part is saved on child model that are connected to each other by kind of one to one relation and under the hood you operate on two models at once Proxy models [NOT SUPPORTED] - means that only parent has an actual table, children just add methods, modify settings etc.","title":"Types of inheritance"},{"location":"models/inheritance/#mixins","text":"To use Mixins just define a class that is not inheriting from an ormar.Model but is defining ormar.Fields as class variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # a mixin defines the fields but is a normal python class class AuditMixin : created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) class DateFieldsMixins : created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # a models can inherit from one or more mixins class Category ( ormar . Model , DateFieldsMixins , AuditMixin ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () Tip Note that Mixins are not models, so you still need to inherit from ormar.Model as well as define Meta class in the final model. A Category class above will have four additional fields: created_date , updated_date , created_by and updated_by . There will be only one table created for model Category ( categories ), with Category class fields combined with all Mixins fields. Note that Mixin in class name is optional but is a good python practice.","title":"Mixins"},{"location":"models/inheritance/#concrete-table-inheritance","text":"In concept concrete table inheritance is very similar to Mixins, but uses actual ormar.Models as base classes. Warning Note that base classes have abstract=True set in Meta class, if you try to inherit from non abstract marked class ModelDefinitionError will be raised. Since this abstract Model will never be initialized you can skip metadata and database in it's Meta definition. But if you provide it - it will be inherited, that way you do not have to provide metadata and databases in the final/concrete class Note that you can always overwrite it in child/concrete class if you need to. More over at least one of the classes in inheritance chain have to provide both database and metadata - otherwise an error will be raised. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # note that base classes have abstract=True # since this model will never be initialized you can skip metadata and database class AuditModel ( ormar . Model ): class Meta : abstract = True created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) # but if you provide it it will be inherited - DRY (Don't Repeat Yourself) in action class DateFieldsModel ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # that way you do not have to provide metadata and databases in concrete class class Category ( DateFieldsModel , AuditModel ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () The list of inherited options/settings is as follows: metadata , database and constraints . Also methods decorated with @property_field decorator will be inherited/recognized. Of course apart from that all fields from base classes are combined and created in the concrete table of the final Model. Tip Note how you don't have to provide abstarct=False in the final class - it's the default setting that is not inherited.","title":"Concrete table inheritance"},{"location":"models/inheritance/#redefining-fields-in-subclasses","text":"Note that you can redefine previously created fields like in normal python class inheritance. Whenever you define a field with same name and new definition it will completely replace the previously defined one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # base class class DateFieldsModel ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db # note that UniqueColumns need sqlalchemy db columns names not the ormar ones constraints = [ ormar . UniqueColumns ( \"creation_date\" , \"modification_date\" )] created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"creation_date\" ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"modification_date\" ) class RedefinedField ( DateFieldsModel ): class Meta ( ormar . ModelMeta ): tablename = \"redefines\" metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) # here the created_date is replaced by the String field created_date : str = ormar . String ( max_length = 200 , name = \"creation_date\" ) # you can verify that the final field is correctly declared and created changed_field = RedefinedField . Meta . model_fields [ \"created_date\" ] assert changed_field . default is None assert changed_field . alias == \"creation_date\" assert any ( x . name == \"creation_date\" for x in RedefinedField . Meta . table . columns ) assert isinstance ( RedefinedField . Meta . table . columns [ \"creation_date\" ] . type , sqlalchemy . sql . sqltypes . String , ) Warning If you declare UniqueColumns constraint with column names, the final model has to have a column with the same name declared. Otherwise, the ModelDefinitionError will be raised. So in example above if you do not provide name for created_date in RedefinedField model ormar will complain. created_date: str = ormar.String(max_length=200) # exception created_date: str = ormar.String(max_length=200, name=\"creation_date2\") # exception","title":"Redefining fields in subclasses"},{"location":"models/inheritance/#relations-in-inheritance","text":"You can declare relations in every step of inheritance, so both in parent and child classes. When you define a relation on a child model level it's either overwriting the relation defined in parent model (if the same field name is used), or is accessible only to this child if you define a new relation. When inheriting relations, you always need to be aware of related_name parameter, that has to be unique across a related model, when you define multiple child classes that inherit the same relation. If you do not provide related_name parameter ormar calculates it for you. This works with inheritance as all child models have to have different class names, which are used to calculate the default related_name (class.name.lower()+'s'). But, if you provide a related_name this name cannot be reused in all child models as they would overwrite each other on the related model side. Therefore, you have two options: redefine relation field in child models and manually provide different related_name parameters let this for ormar to handle -> auto adjusted related_name are: original related_name + \"_\" + child model table name That might sound complicated but let's look at the following example:","title":"Relations in inheritance"},{"location":"models/inheritance/#foreignkey-relations","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # normal model used in relation class Person ( ormar . Model ): class Meta : metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # parent model - needs to be abstract class Car ( ormar . Model ): class Meta : abstract = True metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 ) owner : Person = ormar . ForeignKey ( Person ) # note that we refer to the Person model again so we **have to** provide related_name co_owner : Person = ormar . ForeignKey ( Person , related_name = \"coowned\" ) created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) class Truck ( Car ): class Meta : pass max_capacity : int = ormar . Integer () class Bus ( Car ): class Meta : # default naming is name.lower()+'s' so it's ugly for buss ;) tablename = \"buses\" max_persons : int = ormar . Integer () Now when you will inspect the fields on Person model you will get: 1 2 3 4 5 6 7 8 9 Person . Meta . model_fields \"\"\" {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'buss': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_buses': <class 'ormar.fields.foreign_key.ForeignKey'>} \"\"\" Note how you have trucks and buss fields that leads to Truck and Bus class that this Person owns. There were no related_name parameter so default names were used. At the same time the co-owned cars need to be referenced by coowned_trucks and coowned_buses . Ormar appended _trucks and _buses suffixes taken from child model table names. Seems fine, but the default name for owned trucks is ok ( trucks ) but the buss is ugly, so how can we change it? The solution is pretty simple - just redefine the field in Bus class and provide different related_name parameter. 1 2 3 4 5 6 7 8 # rest of the above example remains the same class Bus ( Car ): class Meta : tablename = \"buses\" # new field that changes the related_name owner : Person = ormar . ForeignKey ( Person , related_name = \"buses\" ) max_persons : int = ormar . Integer () Now the columns looks much better. 1 2 3 4 5 6 7 8 9 Person . Meta . model_fields \"\"\" {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_trucks': <class 'ormar.fields.foreign_key.ForeignKey'>, 'buses': <class 'ormar.fields.foreign_key.ForeignKey'>, 'coowned_buses': <class 'ormar.fields.foreign_key.ForeignKey'>} \"\"\" Note You could also provide related_name for the owner field, that way the proper suffixes would be added. owner: Person = ormar.ForeignKey(Person, related_name=\"owned\") and model fields for Person owned cars would become owned_trucks and owned_buses .","title":"ForeignKey relations"},{"location":"models/inheritance/#manytomany-relations","text":"Similarly, you can inherit from Models that have ManyToMany relations declared but there is one, but substantial difference - the Through model. Since in the future the Through model will be able to hold additional fields and now it links only two Tables ( from and to ones), each child that inherits the m2m relation field has to have separate Through model. Of course, you can overwrite the relation in each Child model, but that requires additional code and undermines the point of the whole inheritance. Ormar will handle this for you if you agree with default naming convention, which you can always manually overwrite in children if needed. Again, let's look at the example to easier grasp the concepts. We will modify the previous example described above to use m2m relation for co_owners. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # person remain the same as above class Person ( ormar . Model ): class Meta : metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # new through model between Person and Car2 class PersonsCar ( ormar . Model ): class Meta : tablename = \"cars_x_persons\" metadata = metadata database = db # note how co_owners is now ManyToMany relation class Car2 ( ormar . Model ): class Meta : # parent class needs to be marked abstract abstract = True metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 ) # note the related_name - needs to be unique across Person # model, regardless of how many different models leads to Person owner : Person = ormar . ForeignKey ( Person , related_name = \"owned\" ) co_owners : List [ Person ] = ormar . ManyToMany ( Person , through = PersonsCar , related_name = \"coowned\" ) created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now ) # child models define only additional Fields class Truck2 ( Car2 ): class Meta : # note how you don't have to provide inherited Meta params tablename = \"trucks2\" max_capacity : int = ormar . Integer () class Bus2 ( Car2 ): class Meta : tablename = \"buses2\" max_persons : int = ormar . Integer () Ormar automatically modifies related_name of the fields to include the table name of the children models. The dafault name is original related_name + '_' + child table name. That way for class Truck2 the relation defined in owner: Person = ormar.ForeignKey(Person, related_name=\"owned\") becomes owned_trucks2 You can verify the names by inspecting the list of fields present on Person model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Person . Meta . model_fields { # note how all relation fields need to be unique on Person # regardless if autogenerated or manually overwritten 'id' : < class ' ormar . fields . model_fields . Integer '>, 'name' : < class ' ormar . fields . model_fields . String '>, # note that we expanded on previous example so all 'old' fields are here 'trucks' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_trucks' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'buses' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_buses' : < class ' ormar . fields . foreign_key . ForeignKey '>, # newly defined related fields 'owned_trucks2' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_trucks2' : < class ' abc . ManyToMany '>, 'owned_buses2' : < class ' ormar . fields . foreign_key . ForeignKey '>, 'coowned_buses2' : < class ' abc . ManyToMany '> } But that's not all. It's kind of internal to ormar but affects the data structure in the database, so let's examine the through models for both Bus2 and Truck2 models. 1 2 3 4 5 6 7 8 9 Bus2 . Meta . model_fields [ 'co_owners' ] . through < class ' abc . PersonsCarBus2 '> Bus2 . Meta . model_fields [ 'co_owners' ] . through . Meta . tablename 'cars_x_persons_buses2' Truck2 . Meta . model_fields [ 'co_owners' ] . through < class ' abc . PersonsCarTruck2 '> Truck2 . Meta . model_fields [ 'co_owners' ] . through . Meta . tablename 'cars_x_persons_trucks2' As you can see above ormar cloned the Through model for each of the Child classes and added Child class name at the end, while changing the table names of the cloned fields the name of the table from the child is used. Note that original model is not only not used, the table for this model is removed from metadata: 1 2 3 Bus2 . Meta . metadata . tables . keys () dict_keys ([ 'test_date_models' , 'categories' , 'subjects' , 'persons' , 'trucks' , 'buses' , 'cars_x_persons_trucks2' , 'trucks2' , 'cars_x_persons_buses2' , 'buses2' ]) So be aware that if you introduce inheritance along the way and convert a model into abstract parent model you may lose your data on through table if not careful. Note Note that original table name and model name of the Through model is never used. Only the cloned models tables are created and used. Warning Note that each subclass of the Model that has ManyToMany relation defined generates a new Through model, meaning also new database table . That means that each time you define a Child model you need to either manually create the table in the database, or run a migration (with alembic).","title":"ManyToMany relations"},{"location":"models/inheritance/#exclude_parent_fields","text":"Ormar allows you to skip certain fields in inherited model that are coming from a parent model. Note Note that the same behaviour can be achieved by splitting the model into more abstract models and mixins - which is a preferred way in normal circumstances. To skip certain fields from a child model, list all fields that you want to skip in model.Meta.exclude_parent_fields parameter like follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 metadata = sa . MetaData () db = databases . Database ( DATABASE_URL ) class AuditModel ( ormar . Model ): class Meta : abstract = True created_by : str = ormar . String ( max_length = 100 ) updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) class DateFieldsModel ( ormar . Model ): class Meta ( ormar . ModelMeta ): abstract = True metadata = metadata database = db created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"creation_date\" ) updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"modification_date\" ) class Category ( DateFieldsModel , AuditModel ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" # set fields that should be skipped exclude_parent_fields = [ \"updated_by\" , \"updated_date\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () # Note that now the update fields in Category are gone in all places -> ormar fields, pydantic fields and sqlachemy table columns # so full list of available fileds in Category is: [\"created_by\", \"created_date\", \"id\", \"name\", \"code\"] Note how you simply need to provide field names and it will exclude the parent field regardless of from which parent model the field is coming from. Note Note that if you want to overwrite a field in child model you do not have to exclude it, simpy overwrite the field declaration in child model with same field name. Warning Note that this kind of behavior can confuse mypy and static type checkers, yet accessing the non existing fields will fail at runtime. That's why splitting the base classes is preferred. The same effect can be achieved by splitting base classes like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 metadata = sa . MetaData () db = databases . Database ( DATABASE_URL ) class AuditCreateModel ( ormar . Model ): class Meta : abstract = True created_by : str = ormar . String ( max_length = 100 ) class AuditUpdateModel ( ormar . Model ): class Meta : abstract = True updated_by : str = ormar . String ( max_length = 100 , default = \"Sam\" ) class CreateDateFieldsModel ( ormar . Model ): class Meta ( ormar . ModelMeta ): abstract = True metadata = metadata database = db created_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"creation_date\" ) class UpdateDateFieldsModel ( ormar . Model ): class Meta ( ormar . ModelMeta ): abstract = True metadata = metadata database = db updated_date : datetime . datetime = ormar . DateTime ( default = datetime . datetime . now , name = \"modification_date\" ) class Category ( CreateDateFieldsModel , AuditCreateModel ): class Meta ( ormar . ModelMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 50 , unique = True , index = True ) code : int = ormar . Integer () That way you can inherit from both create and update classes if needed, and only one of them otherwise.","title":"exclude_parent_fields"},{"location":"models/internals/","text":"Internals Apart from special parameters defined in the Model during definition (tablename, metadata etc.) the Model provides you with useful internals. Pydantic Model All Model classes inherit from pydantic.BaseModel so you can access all normal attributes of pydantic models. For example to list pydantic model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . __fields__ ) \"\"\" Will produce: {'id': ModelField(name='id', type=Optional[int], required=False, default=None), 'name': ModelField(name='name', type=Optional[str], required=False, default=None), 'completed': ModelField(name='completed', type=bool, required=False, default=False)} \"\"\" Tip Note how the primary key id field is optional as Integer primary key by default has autoincrement set to True . Info For more options visit official pydantic documentation. Sqlalchemy Table To access auto created sqlalchemy table you can use Model.Meta.table parameter For example to list table columns you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): # note you don't have to subclass - but it's recommended for ide completion and mypy database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . Meta . table . columns ) \"\"\" Will produce: ['courses.id', 'courses.name', 'courses.completed'] \"\"\" Tip You can access table primary key name by Course.Meta.pkname Info For more options visit official sqlalchemy-metadata documentation. Fields Definition To access ormar Fields you can use Model.Meta.model_fields parameter For example to list table model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ({ x : v . __dict__ for x , v in Course . Meta . model_fields . items ()}) \"\"\" Will produce: {'completed': mappingproxy({'autoincrement': False, 'choices': set(), 'column_type': Boolean(), 'default': False, 'index': False, 'name': 'completed', 'nullable': True, 'primary_key': False, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'id': mappingproxy({'autoincrement': True, 'choices': set(), 'column_type': Integer(), 'default': None, 'ge': None, 'index': False, 'le': None, 'maximum': None, 'minimum': None, 'multiple_of': None, 'name': 'id', 'nullable': False, 'primary_key': True, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'name': mappingproxy({'allow_blank': False, 'autoincrement': False, 'choices': set(), 'column_type': String(max_length=100), 'curtail_length': None, 'default': None, 'index': False, 'max_length': 100, 'min_length': None, 'name': 'name', 'nullable': False, 'primary_key': False, 'pydantic_only': False, 'regex': None, 'server_default': None, 'strip_whitespace': False, 'unique': False})} \"\"\" Info Note that fields stored on a model are classes not instances . So if you print just model fields you will get: {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'completed': <class 'ormar.fields.model_fields.Boolean'>}","title":"Internals"},{"location":"models/internals/#internals","text":"Apart from special parameters defined in the Model during definition (tablename, metadata etc.) the Model provides you with useful internals.","title":"Internals"},{"location":"models/internals/#pydantic-model","text":"All Model classes inherit from pydantic.BaseModel so you can access all normal attributes of pydantic models. For example to list pydantic model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . __fields__ ) \"\"\" Will produce: {'id': ModelField(name='id', type=Optional[int], required=False, default=None), 'name': ModelField(name='name', type=Optional[str], required=False, default=None), 'completed': ModelField(name='completed', type=bool, required=False, default=False)} \"\"\" Tip Note how the primary key id field is optional as Integer primary key by default has autoincrement set to True . Info For more options visit official pydantic documentation.","title":"Pydantic Model"},{"location":"models/internals/#sqlalchemy-table","text":"To access auto created sqlalchemy table you can use Model.Meta.table parameter For example to list table columns you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): # note you don't have to subclass - but it's recommended for ide completion and mypy database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . Meta . table . columns ) \"\"\" Will produce: ['courses.id', 'courses.name', 'courses.completed'] \"\"\" Tip You can access table primary key name by Course.Meta.pkname Info For more options visit official sqlalchemy-metadata documentation.","title":"Sqlalchemy Table"},{"location":"models/internals/#fields-definition","text":"To access ormar Fields you can use Model.Meta.model_fields parameter For example to list table model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ({ x : v . __dict__ for x , v in Course . Meta . model_fields . items ()}) \"\"\" Will produce: {'completed': mappingproxy({'autoincrement': False, 'choices': set(), 'column_type': Boolean(), 'default': False, 'index': False, 'name': 'completed', 'nullable': True, 'primary_key': False, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'id': mappingproxy({'autoincrement': True, 'choices': set(), 'column_type': Integer(), 'default': None, 'ge': None, 'index': False, 'le': None, 'maximum': None, 'minimum': None, 'multiple_of': None, 'name': 'id', 'nullable': False, 'primary_key': True, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'name': mappingproxy({'allow_blank': False, 'autoincrement': False, 'choices': set(), 'column_type': String(max_length=100), 'curtail_length': None, 'default': None, 'index': False, 'max_length': 100, 'min_length': None, 'name': 'name', 'nullable': False, 'primary_key': False, 'pydantic_only': False, 'regex': None, 'server_default': None, 'strip_whitespace': False, 'unique': False})} \"\"\" Info Note that fields stored on a model are classes not instances . So if you print just model fields you will get: {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'completed': <class 'ormar.fields.model_fields.Boolean'>}","title":"Fields Definition"},{"location":"models/methods/","text":"Model methods Tip Main interaction with the databases is exposed through a QuerySet object exposed on each model as Model.objects similar to the django orm. To read more about quering, joining tables, excluding fields etc. visit queries section. Each model instance have a set of methods to save , update or load itself. Available methods are described below. pydantic methods Note that each ormar.Model is also a pydantic.BaseModel , so all pydantic methods are also available on a model, especially dict() and json() methods that can also accept exclude , include and other parameters. To read more check pydantic documentation dict dict is a method inherited from pydantic , yet ormar adds its own parameters and has some nuances when working with default values, therefore it's listed here for clarity. dict as the name suggests export data from model tree to dictionary. Explanation of dict parameters: include ( ormar modifed) include: Union[Set, Dict] = None Set or dictionary of field names to include in returned dictionary. Note that pydantic has an uncommon pattern of including/ excluding fields in lists (so also nested models) by an index. And if you want to exclude the field in all children you need to pass a __all__ key to dictionary. You cannot exclude nested models in Set s in pydantic but you can in ormar (by adding double underscore on relation name i.e. to exclude name of category for a book you cen use exclude={\"book__category__name\"} ) ormar does not support by index exclusion/ inclusions and accepts a simplified and more user-friendly notation. To check how you can include/exclude fields, including nested fields check out fields section that has an explanation and a lot of samples. Note The fact that in ormar you can exclude nested models in sets, you can exclude from a whole model tree in response_model_exclude and response_model_include in fastapi! exclude ( ormar modified) exclude: Union[Set, Dict] = None Set or dictionary of field names to exclude in returned dictionary. Note that pydantic has an uncommon pattern of including/ excluding fields in lists (so also nested models) by an index. And if you want to exclude the field in all children you need to pass a __all__ key to dictionary. You cannot exclude nested models in Set s in pydantic but you can in ormar (by adding double underscore on relation name i.e. to exclude name of category for a book you cen use exclude={\"book__category__name\"} ) ormar does not support by index exclusion/ inclusions and accepts a simplified and more user-friendly notation. To check how you can include/exclude fields, including nested fields check out fields section that has an explanation and a lot of samples. Note The fact that in ormar you can exclude nested models in sets, you can exclude from a whole model tree in response_model_exclude and response_model_include in fastapi! exclude_unset exclude_unset: bool = False Flag indicates whether fields which were not explicitly set when creating the model should be excluded from the returned dictionary. Warning Note that after you save data into database each field has its own value -> either provided by you, default, or None . That means that when you load the data from database, all fields are set, and this flag basically stop working! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , default = \"Test\" ) visibility : bool = ormar . Boolean ( default = True ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) price : float = ormar . Float ( default = 9.99 ) categories : List [ Category ] = ormar . ManyToMany ( Category ) category = Category ( name = \"Test 2\" ) assert category . dict () == { 'id' : None , 'items' : [], 'name' : 'Test 2' , 'visibility' : True } assert category . dict ( exclude_unset = True ) == { 'items' : [], 'name' : 'Test 2' } await category . save () category2 = await Category . objects . get () assert category2 . dict () == { 'id' : 1 , 'items' : [], 'name' : 'Test 2' , 'visibility' : True } # NOTE how after loading from db all fields are set explicitly # as this is what happens when you populate a model from db assert category2 . dict ( exclude_unset = True ) == { 'id' : 1 , 'items' : [], 'name' : 'Test 2' , 'visibility' : True } exclude_defaults exclude_defaults: bool = False Flag indicates are equal to their default values (whether set or otherwise) should be excluded from the returned dictionary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , default = \"Test\" ) visibility : bool = ormar . Boolean ( default = True ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) price : float = ormar . Float ( default = 9.99 ) categories : List [ Category ] = ormar . ManyToMany ( Category ) category = Category () # note that Integer pk is by default autoincrement so optional assert category . dict () == { 'id' : None , 'items' : [], 'name' : 'Test' , 'visibility' : True } assert category . dict ( exclude_defaults = True ) == { 'items' : []} # save and reload the data await category . save () category2 = await Category . objects . get () assert category2 . dict () == { 'id' : 1 , 'items' : [], 'name' : 'Test' , 'visibility' : True } assert category2 . dict ( exclude_defaults = True ) == { 'id' : 1 , 'items' : []} exclude_none exclude_none: bool = False Flag indicates whether fields which are equal to None should be excluded from the returned dictionary. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , default = \"Test\" , nullable = True ) visibility : bool = ormar . Boolean ( default = True ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) price : float = ormar . Float ( default = 9.99 ) categories : List [ Category ] = ormar . ManyToMany ( Category ) category = Category ( name = None ) assert category . dict () == { 'id' : None , 'items' : [], 'name' : None , 'visibility' : True } # note the id is not set yet so None and excluded assert category . dict ( exclude_none = True ) == { 'items' : [], 'visibility' : True } await category . save () category2 = await Category . objects . get () assert category2 . dict () == { 'id' : 1 , 'items' : [], 'name' : None , 'visibility' : True } assert category2 . dict ( exclude_none = True ) == { 'id' : 1 , 'items' : [], 'visibility' : True } exclude_primary_keys ( ormar only) exclude_primary_keys: bool = False Setting flag to True will exclude all primary key columns in a tree, including nested models. 1 2 3 4 5 6 7 8 9 10 11 12 class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) item1 = Item ( id = 1 , name = \"Test Item\" ) assert item1 . dict () == { \"id\" : 1 , \"name\" : \"Test Item\" } assert item1 . dict ( exclude_primary_keys = True ) == { \"name\" : \"Test Item\" } exclude_through_models ( ormar only) exclude_through_models: bool = False Through models are auto added for every ManyToMany relation, and they hold additional parameters on linking model/table. Setting the exclude_through_models=True will exclude all through models, including Through models of submodels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) categories : List [ Category ] = ormar . ManyToMany ( Category ) # tree defining the models item_dict = { \"name\" : \"test\" , \"categories\" : [{ \"name\" : \"test cat\" }, { \"name\" : \"test cat2\" }], } # save whole tree await Item ( ** item_dict ) . save_related ( follow = True , save_all = True ) # get the saved values item = await Item . objects . select_related ( \"categories\" ) . get () # by default you can see the through models (itemcategory) assert item . dict () == { 'id' : 1 , 'name' : 'test' , 'categories' : [ { 'id' : 1 , 'name' : 'test cat' , 'itemcategory' : { 'id' : 1 , 'category' : None , 'item' : None }}, { 'id' : 2 , 'name' : 'test cat2' , 'itemcategory' : { 'id' : 2 , 'category' : None , 'item' : None }} ]} # you can exclude those fields/ models assert item . dict ( exclude_through_models = True ) == { 'id' : 1 , 'name' : 'test' , 'categories' : [ { 'id' : 1 , 'name' : 'test cat' }, { 'id' : 2 , 'name' : 'test cat2' } ]} json json() has exactly the same parameters as dict() so check above. Of course the end result is a string with json representation and not a dictionary. get_pydantic get_pydantic(include: Union[Set, Dict] = None, exclude: Union[Set, Dict] = None) This method allows you to generate pydantic models from your ormar models without you needing to retype all the fields. Note that if you have nested models, it will generate whole tree of pydantic models for you! Moreover, you can pass exclude and/or include parameters to keep only the fields that you want to, including in nested models. That means that this way you can effortlessly create pydantic models for requests and responses in fastapi . Note To read more about possible excludes/includes and how to structure your exclude dictionary or set visit fields section of documentation Given sample ormar models like follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 metadata = sqlalchemy . MetaData () database = databases . Database ( DATABASE_URL , force_rollback = True ) class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , default = \"test\" ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) You can generate pydantic models out of it with a one simple call. 1 PydanticCategory = Category . get_pydantic ( include = { \"id\" , \"name\" } Which will generate model equivalent of: 1 2 3 class Category ( BaseModel ): id : Optional [ int ] name : Optional [ str ] = \"test\" Warning Note that it's not a good practice to have several classes with same name in one module, as well as it would break fastapi docs. Thats's why ormar adds random 3 uppercase letters to the class name. In example above it means that in reality class would be named i.e. Category_XIP(BaseModel) . To exclude or include nested fields you can use dict or double underscores. 1 2 3 # both calls are equivalent PydanticCategory = Category . get_pydantic ( include = { \"id\" , \"items__id\" }) PydanticCategory = Category . get_pydantic ( include = { \"id\" : ... , \"items\" : { \"id\" }}) and results in a generated structure as follows: 1 2 3 4 5 6 class Item ( BaseModel ): id : Optional [ int ] class Category ( BaseModel ): id : Optional [ int ] items : Optional [ List [ Item ]] Of course you can use also deeply nested structures and ormar will generate it pydantic equivalent you (in a way that exclude loops). Note how Item model above does not have a reference to Category although in ormar the relation is bidirectional (and ormar.Item has categories field). load By default when you query a table without prefetching related models, the ormar will still construct your related models, but populate them only with the pk value. You can load the related model by calling load() method. load() can also be used to refresh the model from the database (if it was changed by some other process). 1 2 3 4 5 6 7 track = await Track . objects . get ( name = 'The Bird' ) track . album . pk # will return malibu album pk (1) track . album . name # will return None # you need to actually load the data first await track . album . load () track . album . name # will return 'Malibu' load_all load_all(follow: bool = False, exclude: Union[List, str, Set, Dict] = None) -> Model Method works like load() but also goes through all relations of the Model on which the method is called, and reloads them from database. By default the load_all method loads only models that are directly related (one step away) to the model on which the method is called. But you can specify the follow=True parameter to traverse through nested models and load all of them in the relation tree. Warning To avoid circular updates with follow=True set, load_all keeps a set of already visited Models, and won't perform nested loads on Models that were already visited. So if you have a diamond or circular relations types you need to perform the loads in a manual way. 1 2 # in example like this the second Street (coming from City) won't be load_all, so ZipCode won't be reloaded Street -> District -> City -> Street -> ZipCode Method accepts also optional exclude parameter that works exactly the same as exclude_fields method in QuerySet . That way you can remove fields from related models being refreshed or skip whole related models. Method performs one database query so it's more efficient than nested calls to load() and all() on related models. Tip To read more about exclude read exclude_fields Warning All relations are cleared on load_all() , so if you exclude some nested models they will be empty after call. save save() -> self You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. save() can also be used to persist changes that you made to the model, but only if the primary key is not set or the model does not exist in database. The save() method does not check if the model exists in db, so if it does you will get a integrity error from your selected db backend if trying to save model with already existing primary key. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . save () # will persist the model in database track = await Track . objects . get ( name = 'The Bird' ) await track . save () # will raise integrity error as pk is populated update update(_columns: List[str] = None, **kwargs) -> self You can update models by using QuerySet.update() method or by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. To persist a newly created model use save() or upsert(**kwargs) methods. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . update ( name = 'The Bird Strikes Again' ) To update only selected columns from model into the database provide a list of columns that should be updated to _columns argument. In example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Movie ( ormar . Model ): class Meta : tablename = \"movies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , nullable = False , name = \"title\" ) year : int = ormar . Integer () profit : float = ormar . Float () terminator = await Movie ( name = 'Terminator' , year = 1984 , profit = 0.078 ) . save () terminator . name = \"Terminator 2\" terminator . year = 1991 terminator . profit = 0.520 # update only name await terminator . update ( _columns = [ \"name\" ]) # note that terminator instance was not reloaded so assert terminator . year == 1991 # but once you load the data from db you see it was not updated await terminator . load () assert terminator . year == 1984 Warning Note that update() does not refresh the instance of the Model, so if you change more columns than you pass in _columns list your Model instance will have different values than the database! upsert upsert(**kwargs) -> self It's a proxy to either save() or update(**kwargs) methods described above. If the primary key is set -> the update method will be called. If the pk is not set the save() method will be called. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . upsert () # will call save as the pk is empty track = await Track . objects . get ( name = 'The Bird' ) await track . upsert ( name = 'The Bird Strikes Again' ) # will call update as pk is already populated delete You can delete models by using QuerySet.delete() method or by using your model and calling delete() method. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . delete () # will delete the model from database Tip Note that that track object stays the same, only record in the database is removed. save_related save_related(follow: bool = False, save_all: bool = False, exclude=Optional[Union[Set, Dict]]) -> None Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. To understand when a model is saved check save status section above. By default the save_related method saved only models that are directly related (one step away) to the model on which the method is called. But you can specify the follow=True parameter to traverse through nested models and save all of them in the relation tree. By default save_related saves only model that has not saved status, meaning that they were modified in current scope. If you want to force saving all of the related methods use save_all=True flag, which will upsert all related models, regardless of their save status. If you want to skip saving some of the relations you can pass exclude parameter. Exclude can be a set of own model relations, or it can be a dictionary that can also contain nested items. Note Note that exclude parameter in save_related accepts only relation fields names, so if you pass any other fields they will be saved anyway Note To read more about the structure of possible values passed to exclude check Queryset.fields method documentation. Warning To avoid circular updates with follow=True set, save_related keeps a set of already visited Models on each branch of relation tree, and won't perform nested save_related on Models that were already visited. So if you have circular relations types you need to perform the updates in a manual way. Note that with save_all=True and follow=True you can use save_related() to save whole relation tree at once. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) department_name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) course_name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean () department : Optional [ Department ] = ormar . ForeignKey ( Department ) class Student ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) courses = ormar . ManyToMany ( Course ) to_save = { \"department_name\" : \"Ormar\" , \"courses\" : [ { \"course_name\" : \"basic1\" , \"completed\" : True , \"students\" : [ { \"name\" : \"Jack\" }, { \"name\" : \"Abi\" } ]}, { \"course_name\" : \"basic2\" , \"completed\" : True , \"students\" : [ { \"name\" : \"Kate\" }, { \"name\" : \"Miranda\" } ] }, ], } # initializa whole tree department = Department ( ** to_save ) # save all at once (one after another) await department . save_related ( follow = True , save_all = True ) department_check = await Department . objects . select_all ( follow = True ) . get () to_exclude = { \"id\" : ... , \"courses\" : { \"id\" : ... , \"students\" : { \"id\" , \"studentcourse\" } } } # after excluding ids and through models you get exact same payload used to # construct whole tree assert department_check . dict ( exclude = to_exclude ) == to_save Warning save_related() iterates all relations and all models and upserts() them one by one, so it will save all models but might not be optimal in regard of number of database queries.","title":"Methods"},{"location":"models/methods/#model-methods","text":"Tip Main interaction with the databases is exposed through a QuerySet object exposed on each model as Model.objects similar to the django orm. To read more about quering, joining tables, excluding fields etc. visit queries section. Each model instance have a set of methods to save , update or load itself. Available methods are described below.","title":"Model methods"},{"location":"models/methods/#pydantic-methods","text":"Note that each ormar.Model is also a pydantic.BaseModel , so all pydantic methods are also available on a model, especially dict() and json() methods that can also accept exclude , include and other parameters. To read more check pydantic documentation","title":"pydantic methods"},{"location":"models/methods/#dict","text":"dict is a method inherited from pydantic , yet ormar adds its own parameters and has some nuances when working with default values, therefore it's listed here for clarity. dict as the name suggests export data from model tree to dictionary. Explanation of dict parameters:","title":"dict"},{"location":"models/methods/#include-ormar-modifed","text":"include: Union[Set, Dict] = None Set or dictionary of field names to include in returned dictionary. Note that pydantic has an uncommon pattern of including/ excluding fields in lists (so also nested models) by an index. And if you want to exclude the field in all children you need to pass a __all__ key to dictionary. You cannot exclude nested models in Set s in pydantic but you can in ormar (by adding double underscore on relation name i.e. to exclude name of category for a book you cen use exclude={\"book__category__name\"} ) ormar does not support by index exclusion/ inclusions and accepts a simplified and more user-friendly notation. To check how you can include/exclude fields, including nested fields check out fields section that has an explanation and a lot of samples. Note The fact that in ormar you can exclude nested models in sets, you can exclude from a whole model tree in response_model_exclude and response_model_include in fastapi!","title":"include (ormar modifed)"},{"location":"models/methods/#exclude-ormar-modified","text":"exclude: Union[Set, Dict] = None Set or dictionary of field names to exclude in returned dictionary. Note that pydantic has an uncommon pattern of including/ excluding fields in lists (so also nested models) by an index. And if you want to exclude the field in all children you need to pass a __all__ key to dictionary. You cannot exclude nested models in Set s in pydantic but you can in ormar (by adding double underscore on relation name i.e. to exclude name of category for a book you cen use exclude={\"book__category__name\"} ) ormar does not support by index exclusion/ inclusions and accepts a simplified and more user-friendly notation. To check how you can include/exclude fields, including nested fields check out fields section that has an explanation and a lot of samples. Note The fact that in ormar you can exclude nested models in sets, you can exclude from a whole model tree in response_model_exclude and response_model_include in fastapi!","title":"exclude (ormar modified)"},{"location":"models/methods/#exclude_unset","text":"exclude_unset: bool = False Flag indicates whether fields which were not explicitly set when creating the model should be excluded from the returned dictionary. Warning Note that after you save data into database each field has its own value -> either provided by you, default, or None . That means that when you load the data from database, all fields are set, and this flag basically stop working! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , default = \"Test\" ) visibility : bool = ormar . Boolean ( default = True ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) price : float = ormar . Float ( default = 9.99 ) categories : List [ Category ] = ormar . ManyToMany ( Category ) category = Category ( name = \"Test 2\" ) assert category . dict () == { 'id' : None , 'items' : [], 'name' : 'Test 2' , 'visibility' : True } assert category . dict ( exclude_unset = True ) == { 'items' : [], 'name' : 'Test 2' } await category . save () category2 = await Category . objects . get () assert category2 . dict () == { 'id' : 1 , 'items' : [], 'name' : 'Test 2' , 'visibility' : True } # NOTE how after loading from db all fields are set explicitly # as this is what happens when you populate a model from db assert category2 . dict ( exclude_unset = True ) == { 'id' : 1 , 'items' : [], 'name' : 'Test 2' , 'visibility' : True }","title":"exclude_unset"},{"location":"models/methods/#exclude_defaults","text":"exclude_defaults: bool = False Flag indicates are equal to their default values (whether set or otherwise) should be excluded from the returned dictionary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , default = \"Test\" ) visibility : bool = ormar . Boolean ( default = True ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) price : float = ormar . Float ( default = 9.99 ) categories : List [ Category ] = ormar . ManyToMany ( Category ) category = Category () # note that Integer pk is by default autoincrement so optional assert category . dict () == { 'id' : None , 'items' : [], 'name' : 'Test' , 'visibility' : True } assert category . dict ( exclude_defaults = True ) == { 'items' : []} # save and reload the data await category . save () category2 = await Category . objects . get () assert category2 . dict () == { 'id' : 1 , 'items' : [], 'name' : 'Test' , 'visibility' : True } assert category2 . dict ( exclude_defaults = True ) == { 'id' : 1 , 'items' : []}","title":"exclude_defaults"},{"location":"models/methods/#exclude_none","text":"exclude_none: bool = False Flag indicates whether fields which are equal to None should be excluded from the returned dictionary. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , default = \"Test\" , nullable = True ) visibility : bool = ormar . Boolean ( default = True ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) price : float = ormar . Float ( default = 9.99 ) categories : List [ Category ] = ormar . ManyToMany ( Category ) category = Category ( name = None ) assert category . dict () == { 'id' : None , 'items' : [], 'name' : None , 'visibility' : True } # note the id is not set yet so None and excluded assert category . dict ( exclude_none = True ) == { 'items' : [], 'visibility' : True } await category . save () category2 = await Category . objects . get () assert category2 . dict () == { 'id' : 1 , 'items' : [], 'name' : None , 'visibility' : True } assert category2 . dict ( exclude_none = True ) == { 'id' : 1 , 'items' : [], 'visibility' : True }","title":"exclude_none"},{"location":"models/methods/#exclude_primary_keys-ormar-only","text":"exclude_primary_keys: bool = False Setting flag to True will exclude all primary key columns in a tree, including nested models. 1 2 3 4 5 6 7 8 9 10 11 12 class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) item1 = Item ( id = 1 , name = \"Test Item\" ) assert item1 . dict () == { \"id\" : 1 , \"name\" : \"Test Item\" } assert item1 . dict ( exclude_primary_keys = True ) == { \"name\" : \"Test Item\" }","title":"exclude_primary_keys (ormar only)"},{"location":"models/methods/#exclude_through_models-ormar-only","text":"exclude_through_models: bool = False Through models are auto added for every ManyToMany relation, and they hold additional parameters on linking model/table. Setting the exclude_through_models=True will exclude all through models, including Through models of submodels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) categories : List [ Category ] = ormar . ManyToMany ( Category ) # tree defining the models item_dict = { \"name\" : \"test\" , \"categories\" : [{ \"name\" : \"test cat\" }, { \"name\" : \"test cat2\" }], } # save whole tree await Item ( ** item_dict ) . save_related ( follow = True , save_all = True ) # get the saved values item = await Item . objects . select_related ( \"categories\" ) . get () # by default you can see the through models (itemcategory) assert item . dict () == { 'id' : 1 , 'name' : 'test' , 'categories' : [ { 'id' : 1 , 'name' : 'test cat' , 'itemcategory' : { 'id' : 1 , 'category' : None , 'item' : None }}, { 'id' : 2 , 'name' : 'test cat2' , 'itemcategory' : { 'id' : 2 , 'category' : None , 'item' : None }} ]} # you can exclude those fields/ models assert item . dict ( exclude_through_models = True ) == { 'id' : 1 , 'name' : 'test' , 'categories' : [ { 'id' : 1 , 'name' : 'test cat' }, { 'id' : 2 , 'name' : 'test cat2' } ]}","title":"exclude_through_models (ormar only)"},{"location":"models/methods/#json","text":"json() has exactly the same parameters as dict() so check above. Of course the end result is a string with json representation and not a dictionary.","title":"json"},{"location":"models/methods/#get_pydantic","text":"get_pydantic(include: Union[Set, Dict] = None, exclude: Union[Set, Dict] = None) This method allows you to generate pydantic models from your ormar models without you needing to retype all the fields. Note that if you have nested models, it will generate whole tree of pydantic models for you! Moreover, you can pass exclude and/or include parameters to keep only the fields that you want to, including in nested models. That means that this way you can effortlessly create pydantic models for requests and responses in fastapi . Note To read more about possible excludes/includes and how to structure your exclude dictionary or set visit fields section of documentation Given sample ormar models like follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 metadata = sqlalchemy . MetaData () database = databases . Database ( DATABASE_URL , force_rollback = True ) class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , default = \"test\" ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) You can generate pydantic models out of it with a one simple call. 1 PydanticCategory = Category . get_pydantic ( include = { \"id\" , \"name\" } Which will generate model equivalent of: 1 2 3 class Category ( BaseModel ): id : Optional [ int ] name : Optional [ str ] = \"test\" Warning Note that it's not a good practice to have several classes with same name in one module, as well as it would break fastapi docs. Thats's why ormar adds random 3 uppercase letters to the class name. In example above it means that in reality class would be named i.e. Category_XIP(BaseModel) . To exclude or include nested fields you can use dict or double underscores. 1 2 3 # both calls are equivalent PydanticCategory = Category . get_pydantic ( include = { \"id\" , \"items__id\" }) PydanticCategory = Category . get_pydantic ( include = { \"id\" : ... , \"items\" : { \"id\" }}) and results in a generated structure as follows: 1 2 3 4 5 6 class Item ( BaseModel ): id : Optional [ int ] class Category ( BaseModel ): id : Optional [ int ] items : Optional [ List [ Item ]] Of course you can use also deeply nested structures and ormar will generate it pydantic equivalent you (in a way that exclude loops). Note how Item model above does not have a reference to Category although in ormar the relation is bidirectional (and ormar.Item has categories field).","title":"get_pydantic"},{"location":"models/methods/#load","text":"By default when you query a table without prefetching related models, the ormar will still construct your related models, but populate them only with the pk value. You can load the related model by calling load() method. load() can also be used to refresh the model from the database (if it was changed by some other process). 1 2 3 4 5 6 7 track = await Track . objects . get ( name = 'The Bird' ) track . album . pk # will return malibu album pk (1) track . album . name # will return None # you need to actually load the data first await track . album . load () track . album . name # will return 'Malibu'","title":"load"},{"location":"models/methods/#load_all","text":"load_all(follow: bool = False, exclude: Union[List, str, Set, Dict] = None) -> Model Method works like load() but also goes through all relations of the Model on which the method is called, and reloads them from database. By default the load_all method loads only models that are directly related (one step away) to the model on which the method is called. But you can specify the follow=True parameter to traverse through nested models and load all of them in the relation tree. Warning To avoid circular updates with follow=True set, load_all keeps a set of already visited Models, and won't perform nested loads on Models that were already visited. So if you have a diamond or circular relations types you need to perform the loads in a manual way. 1 2 # in example like this the second Street (coming from City) won't be load_all, so ZipCode won't be reloaded Street -> District -> City -> Street -> ZipCode Method accepts also optional exclude parameter that works exactly the same as exclude_fields method in QuerySet . That way you can remove fields from related models being refreshed or skip whole related models. Method performs one database query so it's more efficient than nested calls to load() and all() on related models. Tip To read more about exclude read exclude_fields Warning All relations are cleared on load_all() , so if you exclude some nested models they will be empty after call.","title":"load_all"},{"location":"models/methods/#save","text":"save() -> self You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. save() can also be used to persist changes that you made to the model, but only if the primary key is not set or the model does not exist in database. The save() method does not check if the model exists in db, so if it does you will get a integrity error from your selected db backend if trying to save model with already existing primary key. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . save () # will persist the model in database track = await Track . objects . get ( name = 'The Bird' ) await track . save () # will raise integrity error as pk is populated","title":"save"},{"location":"models/methods/#update","text":"update(_columns: List[str] = None, **kwargs) -> self You can update models by using QuerySet.update() method or by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. To persist a newly created model use save() or upsert(**kwargs) methods. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . update ( name = 'The Bird Strikes Again' ) To update only selected columns from model into the database provide a list of columns that should be updated to _columns argument. In example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Movie ( ormar . Model ): class Meta : tablename = \"movies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , nullable = False , name = \"title\" ) year : int = ormar . Integer () profit : float = ormar . Float () terminator = await Movie ( name = 'Terminator' , year = 1984 , profit = 0.078 ) . save () terminator . name = \"Terminator 2\" terminator . year = 1991 terminator . profit = 0.520 # update only name await terminator . update ( _columns = [ \"name\" ]) # note that terminator instance was not reloaded so assert terminator . year == 1991 # but once you load the data from db you see it was not updated await terminator . load () assert terminator . year == 1984 Warning Note that update() does not refresh the instance of the Model, so if you change more columns than you pass in _columns list your Model instance will have different values than the database!","title":"update"},{"location":"models/methods/#upsert","text":"upsert(**kwargs) -> self It's a proxy to either save() or update(**kwargs) methods described above. If the primary key is set -> the update method will be called. If the pk is not set the save() method will be called. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . upsert () # will call save as the pk is empty track = await Track . objects . get ( name = 'The Bird' ) await track . upsert ( name = 'The Bird Strikes Again' ) # will call update as pk is already populated","title":"upsert"},{"location":"models/methods/#delete","text":"You can delete models by using QuerySet.delete() method or by using your model and calling delete() method. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . delete () # will delete the model from database Tip Note that that track object stays the same, only record in the database is removed.","title":"delete"},{"location":"models/methods/#save_related","text":"save_related(follow: bool = False, save_all: bool = False, exclude=Optional[Union[Set, Dict]]) -> None Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. To understand when a model is saved check save status section above. By default the save_related method saved only models that are directly related (one step away) to the model on which the method is called. But you can specify the follow=True parameter to traverse through nested models and save all of them in the relation tree. By default save_related saves only model that has not saved status, meaning that they were modified in current scope. If you want to force saving all of the related methods use save_all=True flag, which will upsert all related models, regardless of their save status. If you want to skip saving some of the relations you can pass exclude parameter. Exclude can be a set of own model relations, or it can be a dictionary that can also contain nested items. Note Note that exclude parameter in save_related accepts only relation fields names, so if you pass any other fields they will be saved anyway Note To read more about the structure of possible values passed to exclude check Queryset.fields method documentation. Warning To avoid circular updates with follow=True set, save_related keeps a set of already visited Models on each branch of relation tree, and won't perform nested save_related on Models that were already visited. So if you have circular relations types you need to perform the updates in a manual way. Note that with save_all=True and follow=True you can use save_related() to save whole relation tree at once. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) department_name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) course_name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean () department : Optional [ Department ] = ormar . ForeignKey ( Department ) class Student ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) courses = ormar . ManyToMany ( Course ) to_save = { \"department_name\" : \"Ormar\" , \"courses\" : [ { \"course_name\" : \"basic1\" , \"completed\" : True , \"students\" : [ { \"name\" : \"Jack\" }, { \"name\" : \"Abi\" } ]}, { \"course_name\" : \"basic2\" , \"completed\" : True , \"students\" : [ { \"name\" : \"Kate\" }, { \"name\" : \"Miranda\" } ] }, ], } # initializa whole tree department = Department ( ** to_save ) # save all at once (one after another) await department . save_related ( follow = True , save_all = True ) department_check = await Department . objects . select_all ( follow = True ) . get () to_exclude = { \"id\" : ... , \"courses\" : { \"id\" : ... , \"students\" : { \"id\" , \"studentcourse\" } } } # after excluding ids and through models you get exact same payload used to # construct whole tree assert department_check . dict ( exclude = to_exclude ) == to_save Warning save_related() iterates all relations and all models and upserts() them one by one, so it will save all models but might not be optimal in regard of number of database queries.","title":"save_related"},{"location":"models/migrations/","text":"Migrations Database Initialization Note that all examples assume that you already have a database. If that is not the case and you need to create your tables, that's super easy as ormar is using sqlalchemy for underlying table construction. All you have to do is call create_all() like in the example below. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # note that this has to be the same metadata that is used in ormar Models definition metadata . create_all ( engine ) You can also create single tables, sqlalchemy tables are exposed in ormar.Meta class. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # Artist is an ormar model from previous examples Artist . Meta . table . create ( engine ) Warning You need to create the tables only once, so use a python console for that or remove the script from your production code after first use. Alembic usage Likewise as with tables, since we base tables on sqlalchemy for migrations please use alembic . Initialization Use command line to reproduce this minimalistic example. 1 2 3 alembic init alembic alembic revision -- autogenerate - m \"made some changes\" alembic upgrade head Sample env.py file A quick example of alembic migrations should be something similar to: When you have application structure like: 1 2 3 4 5 -> app -> alembic (initialized folder - so run alembic init alembic inside app folder) -> models (here are the models) -> __init__.py -> my_models.py Your env.py file (in alembic folder) can look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from logging.config import fileConfig from sqlalchemy import create_engine from alembic import context import sys , os # add app folder to system path (alternative is running it from parent folder with python -m ...) myPath = os . path . dirname ( os . path . abspath ( __file__ )) sys . path . insert ( 0 , myPath + '/../../' ) # this is the Alembic Config object, which provides # access to the values within the .ini file in use. config = context . config # Interpret the config file for Python logging. # This line sets up loggers basically. fileConfig ( config . config_file_name ) # add your model's MetaData object here (the one used in ormar) # for 'autogenerate' support from app.models.my_models import metadata target_metadata = metadata # set your url here or import from settings # note that by default url is in saved sqlachemy.url variable in alembic.ini file URL = \"sqlite:///test.db\" def run_migrations_offline (): \"\"\"Run migrations in 'offline' mode. This configures the context with just a URL and not an Engine, though an Engine is acceptable here as well. By skipping the Engine creation we don't even need a DBAPI to be available. Calls to context.execute() here emit the given string to the script output. \"\"\" context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () def run_migrations_online (): \"\"\"Run migrations in 'online' mode. In this scenario we need to create an Engine and associate a connection with the context. \"\"\" connectable = create_engine ( URL ) with connectable . connect () as connection : context . configure ( connection = connection , target_metadata = target_metadata , # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () if context . is_offline_mode (): run_migrations_offline () else : run_migrations_online () Excluding tables You can also include/exclude specific tables with include_object parameter passed to context.configure . That should be a function returning True/False for given objects. A sample function excluding tables starting with data_ in name unless it's 'data_jobs': 1 2 3 4 5 def include_object ( object , name , type_ , reflected , compare_to ): if name and name . startswith ( 'data_' ) and name not in [ 'data_jobs' ]: return False return True Note Function parameters for include_objects (you can change the name) are required and defined in alembic to check what they do check the alembic documentation And you pass it into context like (both in online and offline): 1 2 3 4 5 6 7 8 context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, user_module_prefix = 'sa.' , include_object = include_object ) Info You can read more about table creation, altering and migrations in sqlalchemy table creation documentation.","title":"Migrations"},{"location":"models/migrations/#migrations","text":"","title":"Migrations"},{"location":"models/migrations/#database-initialization","text":"Note that all examples assume that you already have a database. If that is not the case and you need to create your tables, that's super easy as ormar is using sqlalchemy for underlying table construction. All you have to do is call create_all() like in the example below. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # note that this has to be the same metadata that is used in ormar Models definition metadata . create_all ( engine ) You can also create single tables, sqlalchemy tables are exposed in ormar.Meta class. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # Artist is an ormar model from previous examples Artist . Meta . table . create ( engine ) Warning You need to create the tables only once, so use a python console for that or remove the script from your production code after first use.","title":"Database Initialization"},{"location":"models/migrations/#alembic-usage","text":"Likewise as with tables, since we base tables on sqlalchemy for migrations please use alembic .","title":"Alembic usage"},{"location":"models/migrations/#initialization","text":"Use command line to reproduce this minimalistic example. 1 2 3 alembic init alembic alembic revision -- autogenerate - m \"made some changes\" alembic upgrade head","title":"Initialization"},{"location":"models/migrations/#sample-envpy-file","text":"A quick example of alembic migrations should be something similar to: When you have application structure like: 1 2 3 4 5 -> app -> alembic (initialized folder - so run alembic init alembic inside app folder) -> models (here are the models) -> __init__.py -> my_models.py Your env.py file (in alembic folder) can look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from logging.config import fileConfig from sqlalchemy import create_engine from alembic import context import sys , os # add app folder to system path (alternative is running it from parent folder with python -m ...) myPath = os . path . dirname ( os . path . abspath ( __file__ )) sys . path . insert ( 0 , myPath + '/../../' ) # this is the Alembic Config object, which provides # access to the values within the .ini file in use. config = context . config # Interpret the config file for Python logging. # This line sets up loggers basically. fileConfig ( config . config_file_name ) # add your model's MetaData object here (the one used in ormar) # for 'autogenerate' support from app.models.my_models import metadata target_metadata = metadata # set your url here or import from settings # note that by default url is in saved sqlachemy.url variable in alembic.ini file URL = \"sqlite:///test.db\" def run_migrations_offline (): \"\"\"Run migrations in 'offline' mode. This configures the context with just a URL and not an Engine, though an Engine is acceptable here as well. By skipping the Engine creation we don't even need a DBAPI to be available. Calls to context.execute() here emit the given string to the script output. \"\"\" context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () def run_migrations_online (): \"\"\"Run migrations in 'online' mode. In this scenario we need to create an Engine and associate a connection with the context. \"\"\" connectable = create_engine ( URL ) with connectable . connect () as connection : context . configure ( connection = connection , target_metadata = target_metadata , # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () if context . is_offline_mode (): run_migrations_offline () else : run_migrations_online ()","title":"Sample env.py file"},{"location":"models/migrations/#excluding-tables","text":"You can also include/exclude specific tables with include_object parameter passed to context.configure . That should be a function returning True/False for given objects. A sample function excluding tables starting with data_ in name unless it's 'data_jobs': 1 2 3 4 5 def include_object ( object , name , type_ , reflected , compare_to ): if name and name . startswith ( 'data_' ) and name not in [ 'data_jobs' ]: return False return True Note Function parameters for include_objects (you can change the name) are required and defined in alembic to check what they do check the alembic documentation And you pass it into context like (both in online and offline): 1 2 3 4 5 6 7 8 context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, user_module_prefix = 'sa.' , include_object = include_object ) Info You can read more about table creation, altering and migrations in sqlalchemy table creation documentation.","title":"Excluding tables"},{"location":"queries/","text":"Querying database with ormar QuerySet Each Model is auto registered with a QuerySet that represents the underlying query, and it's options. Most of the methods are also available through many to many relations and on reverse foreign key relations through QuerysetProxy interface. Info To see which relations are supported and how to construct relations visit relations . For simplicity available methods to fetch and save the data into the database are divided into categories according to the function they fulfill. Note that some functions/methods are in multiple categories. For complicity also Models and relations methods are listed. To read more about any specific section or function please refer to the details subpage. Insert data into database create(**kwargs) -> Model get_or_create(**kwargs) -> Model update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None Model Model.save() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.create(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.update_or_create(**kwargs) method Tip To read more about any or all of those functions visit create section. Read data from database get(**kwargs) -> Model get_or_none(**kwargs) -> Optional[Model] get_or_create(**kwargs) -> Model first() -> Model all(**kwargs) -> List[Optional[Model]] Model Model.load() method QuerysetProxy QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_none(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.first() method QuerysetProxy.all(**kwargs) method Tip To read more about any or all of those functions visit read section. Read raw data from database Instead of ormar models return raw data in form list of dictionaries or tuples. values(fields = None, exclude_through = False) -> List[Dict] values_list(fields = None, exclude_through = False, flatten = False) -> List QuerysetProxy QuerysetProxy.values(fields = None, exclude_through = False) method QuerysetProxy.values_list(fields = None, exclude_through= False, flatten = False) method Tip To read more about any or all of those functions visit raw data section. Update data in database update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_update(objects: List[Model], columns: List[str] = None) -> None Model Model.update() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.update_or_create(**kwargs) method Tip To read more about any or all of those functions visit update section. Delete data from database delete(each: bool = False, **kwargs) -> int Model Model.delete() method QuerysetProxy QuerysetProxy.remove() method QuerysetProxy.clear() method Tip To read more about any or all of those functions visit delete section. Joins and subqueries select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet Model Model.load() method QuerysetProxy QuerysetProxy.select_related(related: Union[List, str]) method QuerysetProxy.prefetch_related(related: Union[List, str]) method Tip To read more about any or all of those functions visit joins and subqueries section. Filtering and sorting filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet get(**kwargs) -> Model get_or_none(**kwargs) -> Optional[Model] get_or_create(**kwargs) -> Model all(**kwargs) -> List[Optional[Model]] QuerysetProxy QuerysetProxy.filter(**kwargs) method QuerysetProxy.exclude(**kwargs) method QuerysetProxy.order_by(columns:Union[List, str]) method QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_none(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.all(**kwargs) method Tip To read more about any or all of those functions visit filtering and sorting section. Selecting columns fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet QuerysetProxy QuerysetProxy.fields(columns: Union[List, str, set, dict]) method QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict]) method Tip To read more about any or all of those functions visit selecting columns section. Pagination and rows number paginate(page: int) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet get() -> Model first() -> Model QuerysetProxy QuerysetProxy.paginate(page: int) method QuerysetProxy.limit(limit_count: int) method QuerysetProxy.offset(offset: int) method Tip To read more about any or all of those functions visit pagination section. Aggregated functions count() -> int exists() -> bool QuerysetProxy QuerysetProxy.count() method QuerysetProxy.exists() method Tip To read more about any or all of those functions visit aggregations section.","title":"Querying database with ormar"},{"location":"queries/#querying-database-with-ormar","text":"","title":"Querying database with ormar"},{"location":"queries/#queryset","text":"Each Model is auto registered with a QuerySet that represents the underlying query, and it's options. Most of the methods are also available through many to many relations and on reverse foreign key relations through QuerysetProxy interface. Info To see which relations are supported and how to construct relations visit relations . For simplicity available methods to fetch and save the data into the database are divided into categories according to the function they fulfill. Note that some functions/methods are in multiple categories. For complicity also Models and relations methods are listed. To read more about any specific section or function please refer to the details subpage.","title":"QuerySet"},{"location":"queries/#insert-data-into-database","text":"create(**kwargs) -> Model get_or_create(**kwargs) -> Model update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None Model Model.save() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.create(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.update_or_create(**kwargs) method Tip To read more about any or all of those functions visit create section.","title":"Insert data into database"},{"location":"queries/#read-data-from-database","text":"get(**kwargs) -> Model get_or_none(**kwargs) -> Optional[Model] get_or_create(**kwargs) -> Model first() -> Model all(**kwargs) -> List[Optional[Model]] Model Model.load() method QuerysetProxy QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_none(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.first() method QuerysetProxy.all(**kwargs) method Tip To read more about any or all of those functions visit read section.","title":"Read data from database"},{"location":"queries/#read-raw-data-from-database","text":"Instead of ormar models return raw data in form list of dictionaries or tuples. values(fields = None, exclude_through = False) -> List[Dict] values_list(fields = None, exclude_through = False, flatten = False) -> List QuerysetProxy QuerysetProxy.values(fields = None, exclude_through = False) method QuerysetProxy.values_list(fields = None, exclude_through= False, flatten = False) method Tip To read more about any or all of those functions visit raw data section.","title":"Read raw data from database"},{"location":"queries/#update-data-in-database","text":"update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_update(objects: List[Model], columns: List[str] = None) -> None Model Model.update() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.update_or_create(**kwargs) method Tip To read more about any or all of those functions visit update section.","title":"Update data in database"},{"location":"queries/#delete-data-from-database","text":"delete(each: bool = False, **kwargs) -> int Model Model.delete() method QuerysetProxy QuerysetProxy.remove() method QuerysetProxy.clear() method Tip To read more about any or all of those functions visit delete section.","title":"Delete data from database"},{"location":"queries/#joins-and-subqueries","text":"select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet Model Model.load() method QuerysetProxy QuerysetProxy.select_related(related: Union[List, str]) method QuerysetProxy.prefetch_related(related: Union[List, str]) method Tip To read more about any or all of those functions visit joins and subqueries section.","title":"Joins and subqueries"},{"location":"queries/#filtering-and-sorting","text":"filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet get(**kwargs) -> Model get_or_none(**kwargs) -> Optional[Model] get_or_create(**kwargs) -> Model all(**kwargs) -> List[Optional[Model]] QuerysetProxy QuerysetProxy.filter(**kwargs) method QuerysetProxy.exclude(**kwargs) method QuerysetProxy.order_by(columns:Union[List, str]) method QuerysetProxy.get(**kwargs) method QuerysetProxy.get_or_none(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.all(**kwargs) method Tip To read more about any or all of those functions visit filtering and sorting section.","title":"Filtering and sorting"},{"location":"queries/#selecting-columns","text":"fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet QuerysetProxy QuerysetProxy.fields(columns: Union[List, str, set, dict]) method QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict]) method Tip To read more about any or all of those functions visit selecting columns section.","title":"Selecting columns"},{"location":"queries/#pagination-and-rows-number","text":"paginate(page: int) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet get() -> Model first() -> Model QuerysetProxy QuerysetProxy.paginate(page: int) method QuerysetProxy.limit(limit_count: int) method QuerysetProxy.offset(offset: int) method Tip To read more about any or all of those functions visit pagination section.","title":"Pagination and rows number"},{"location":"queries/#aggregated-functions","text":"count() -> int exists() -> bool QuerysetProxy QuerysetProxy.count() method QuerysetProxy.exists() method Tip To read more about any or all of those functions visit aggregations section.","title":"Aggregated functions"},{"location":"queries/aggregations/","text":"Aggregation functions Currently 6 aggregation functions are supported. count() -> int exists() -> bool sum(columns) -> Any avg(columns) -> Any min(columns) -> Any max(columns) -> Any QuerysetProxy QuerysetProxy.count() method QuerysetProxy.exists() method QuerysetProxy.sum(columns) method QuerysetProxy.avg(columns) method QuerysetProxy.min(column) method QuerysetProxy.max(columns) method count count() -> int Returns number of rows matching the given criteria (i.e. applied with filter and exclude ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = \"Fiction\" , choices = [ \"Fiction\" , \"Adventure\" , \"Historic\" , \"Fantasy\" ], ) 1 2 # returns count of rows in db for Books model no_of_books = await Book . objects . count () exists exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = \"Fiction\" , choices = [ \"Fiction\" , \"Adventure\" , \"Historic\" , \"Fantasy\" ], ) 1 2 # returns a boolean value if given row exists has_sample = await Book . objects . filter ( title = 'Sample' ) . exists () sum sum(columns) -> Any Returns sum value of columns for rows matching the given criteria (applied with filter and exclude if set before). You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) You cannot sum non numeric columns. If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned Given models like follows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" order_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" order_by = [ \"year\" , \"-ranking\" ] id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) A sample usage might look like following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 author = await Author ( name = \"Author 1\" ) . save () await Book ( title = \"Book 1\" , year = 1920 , ranking = 3 , author = author ) . save () await Book ( title = \"Book 2\" , year = 1930 , ranking = 1 , author = author ) . save () await Book ( title = \"Book 3\" , year = 1923 , ranking = 5 , author = author ) . save () assert await Book . objects . sum ( \"year\" ) == 5773 result = await Book . objects . sum ([ \"year\" , \"ranking\" ]) assert result == dict ( year = 5773 , ranking = 9 ) try : # cannot sum string column await Book . objects . sum ( \"title\" ) except ormar . QueryDefinitionError : pass assert await Author . objects . select_related ( \"books\" ) . sum ( \"books__year\" ) == 5773 result = await Author . objects . select_related ( \"books\" ) . sum ( [ \"books__year\" , \"books__ranking\" ] ) assert result == dict ( books__year = 5773 , books__ranking = 9 ) assert ( await Author . objects . select_related ( \"books\" ) . filter ( books__year__lt = 1925 ) . sum ( \"books__year\" ) == 3843 ) avg avg(columns) -> Any Returns avg value of columns for rows matching the given criteria (applied with filter and exclude if set before). You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) You cannot avg non numeric columns. If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" order_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" order_by = [ \"year\" , \"-ranking\" ] id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) A sample usage might look like following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 author = await Author ( name = \"Author 1\" ) . save () await Book ( title = \"Book 1\" , year = 1920 , ranking = 3 , author = author ) . save () await Book ( title = \"Book 2\" , year = 1930 , ranking = 1 , author = author ) . save () await Book ( title = \"Book 3\" , year = 1923 , ranking = 5 , author = author ) . save () assert round ( float ( await Book . objects . avg ( \"year\" )), 2 ) == 1924.33 result = await Book . objects . avg ([ \"year\" , \"ranking\" ]) assert round ( float ( result . get ( \"year\" )), 2 ) == 1924.33 assert result . get ( \"ranking\" ) == 3.0 try : # cannot avg string column await Book . objects . avg ( \"title\" ) except ormar . QueryDefinitionError : pass result = await Author . objects . select_related ( \"books\" ) . avg ( \"books__year\" ) assert round ( float ( result ), 2 ) == 1924.33 result = await Author . objects . select_related ( \"books\" ) . avg ( [ \"books__year\" , \"books__ranking\" ] ) assert round ( float ( result . get ( \"books__year\" )), 2 ) == 1924.33 assert result . get ( \"books__ranking\" ) == 3.0 assert ( await Author . objects . select_related ( \"books\" ) . filter ( books__year__lt = 1925 ) . avg ( \"books__year\" ) == 1921.5 ) min min(columns) -> Any Returns min value of columns for rows matching the given criteria (applied with filter and exclude if set before). You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" order_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" order_by = [ \"year\" , \"-ranking\" ] id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) A sample usage might look like following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 author = await Author ( name = \"Author 1\" ) . save () await Book ( title = \"Book 1\" , year = 1920 , ranking = 3 , author = author ) . save () await Book ( title = \"Book 2\" , year = 1930 , ranking = 1 , author = author ) . save () await Book ( title = \"Book 3\" , year = 1923 , ranking = 5 , author = author ) . save () assert await Book . objects . min ( \"year\" ) == 1920 result = await Book . objects . min ([ \"year\" , \"ranking\" ]) assert result == dict ( year = 1920 , ranking = 1 ) assert await Book . objects . min ( \"title\" ) == \"Book 1\" assert await Author . objects . select_related ( \"books\" ) . min ( \"books__year\" ) == 1920 result = await Author . objects . select_related ( \"books\" ) . min ( [ \"books__year\" , \"books__ranking\" ] ) assert result == dict ( books__year = 1920 , books__ranking = 1 ) assert ( await Author . objects . select_related ( \"books\" ) . filter ( books__year__gt = 1925 ) . min ( \"books__year\" ) == 1930 ) max max(columns) -> Any Returns max value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns min value of columns for rows matching the given criteria (applied with filter and exclude if set before). You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" order_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" order_by = [ \"year\" , \"-ranking\" ] id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) A sample usage might look like following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 author = await Author ( name = \"Author 1\" ) . save () await Book ( title = \"Book 1\" , year = 1920 , ranking = 3 , author = author ) . save () await Book ( title = \"Book 2\" , year = 1930 , ranking = 1 , author = author ) . save () await Book ( title = \"Book 3\" , year = 1923 , ranking = 5 , author = author ) . save () assert await Book . objects . max ( \"year\" ) == 1930 result = await Book . objects . max ([ \"year\" , \"ranking\" ]) assert result == dict ( year = 1930 , ranking = 5 ) assert await Book . objects . max ( \"title\" ) == \"Book 3\" assert await Author . objects . select_related ( \"books\" ) . max ( \"books__year\" ) == 1930 result = await Author . objects . select_related ( \"books\" ) . max ( [ \"books__year\" , \"books__ranking\" ] ) assert result == dict ( books__year = 1930 , books__ranking = 5 ) assert ( await Author . objects . select_related ( \"books\" ) . filter ( books__year__lt = 1925 ) . max ( \"books__year\" ) == 1923 ) QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes a subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. count Works exactly the same as count function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section exists Works exactly the same as exists function above but allows you to select columns from related objects from other side of the relation. sum Works exactly the same as sum function above but allows you to sum columns from related objects from other side of the relation. avg Works exactly the same as avg function above but allows you to average columns from related objects from other side of the relation. min Works exactly the same as min function above but allows you to select minimum of columns from related objects from other side of the relation. max Works exactly the same as max function above but allows you to select maximum of columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"Aggregation functions"},{"location":"queries/aggregations/#aggregation-functions","text":"Currently 6 aggregation functions are supported. count() -> int exists() -> bool sum(columns) -> Any avg(columns) -> Any min(columns) -> Any max(columns) -> Any QuerysetProxy QuerysetProxy.count() method QuerysetProxy.exists() method QuerysetProxy.sum(columns) method QuerysetProxy.avg(columns) method QuerysetProxy.min(column) method QuerysetProxy.max(columns) method","title":"Aggregation functions"},{"location":"queries/aggregations/#count","text":"count() -> int Returns number of rows matching the given criteria (i.e. applied with filter and exclude ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = \"Fiction\" , choices = [ \"Fiction\" , \"Adventure\" , \"Historic\" , \"Fantasy\" ], ) 1 2 # returns count of rows in db for Books model no_of_books = await Book . objects . count ()","title":"count"},{"location":"queries/aggregations/#exists","text":"exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = \"Fiction\" , choices = [ \"Fiction\" , \"Adventure\" , \"Historic\" , \"Fantasy\" ], ) 1 2 # returns a boolean value if given row exists has_sample = await Book . objects . filter ( title = 'Sample' ) . exists ()","title":"exists"},{"location":"queries/aggregations/#sum","text":"sum(columns) -> Any Returns sum value of columns for rows matching the given criteria (applied with filter and exclude if set before). You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) You cannot sum non numeric columns. If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned Given models like follows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" order_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" order_by = [ \"year\" , \"-ranking\" ] id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) A sample usage might look like following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 author = await Author ( name = \"Author 1\" ) . save () await Book ( title = \"Book 1\" , year = 1920 , ranking = 3 , author = author ) . save () await Book ( title = \"Book 2\" , year = 1930 , ranking = 1 , author = author ) . save () await Book ( title = \"Book 3\" , year = 1923 , ranking = 5 , author = author ) . save () assert await Book . objects . sum ( \"year\" ) == 5773 result = await Book . objects . sum ([ \"year\" , \"ranking\" ]) assert result == dict ( year = 5773 , ranking = 9 ) try : # cannot sum string column await Book . objects . sum ( \"title\" ) except ormar . QueryDefinitionError : pass assert await Author . objects . select_related ( \"books\" ) . sum ( \"books__year\" ) == 5773 result = await Author . objects . select_related ( \"books\" ) . sum ( [ \"books__year\" , \"books__ranking\" ] ) assert result == dict ( books__year = 5773 , books__ranking = 9 ) assert ( await Author . objects . select_related ( \"books\" ) . filter ( books__year__lt = 1925 ) . sum ( \"books__year\" ) == 3843 )","title":"sum"},{"location":"queries/aggregations/#avg","text":"avg(columns) -> Any Returns avg value of columns for rows matching the given criteria (applied with filter and exclude if set before). You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) You cannot avg non numeric columns. If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" order_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" order_by = [ \"year\" , \"-ranking\" ] id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) A sample usage might look like following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 author = await Author ( name = \"Author 1\" ) . save () await Book ( title = \"Book 1\" , year = 1920 , ranking = 3 , author = author ) . save () await Book ( title = \"Book 2\" , year = 1930 , ranking = 1 , author = author ) . save () await Book ( title = \"Book 3\" , year = 1923 , ranking = 5 , author = author ) . save () assert round ( float ( await Book . objects . avg ( \"year\" )), 2 ) == 1924.33 result = await Book . objects . avg ([ \"year\" , \"ranking\" ]) assert round ( float ( result . get ( \"year\" )), 2 ) == 1924.33 assert result . get ( \"ranking\" ) == 3.0 try : # cannot avg string column await Book . objects . avg ( \"title\" ) except ormar . QueryDefinitionError : pass result = await Author . objects . select_related ( \"books\" ) . avg ( \"books__year\" ) assert round ( float ( result ), 2 ) == 1924.33 result = await Author . objects . select_related ( \"books\" ) . avg ( [ \"books__year\" , \"books__ranking\" ] ) assert round ( float ( result . get ( \"books__year\" )), 2 ) == 1924.33 assert result . get ( \"books__ranking\" ) == 3.0 assert ( await Author . objects . select_related ( \"books\" ) . filter ( books__year__lt = 1925 ) . avg ( \"books__year\" ) == 1921.5 )","title":"avg"},{"location":"queries/aggregations/#min","text":"min(columns) -> Any Returns min value of columns for rows matching the given criteria (applied with filter and exclude if set before). You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" order_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" order_by = [ \"year\" , \"-ranking\" ] id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) A sample usage might look like following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 author = await Author ( name = \"Author 1\" ) . save () await Book ( title = \"Book 1\" , year = 1920 , ranking = 3 , author = author ) . save () await Book ( title = \"Book 2\" , year = 1930 , ranking = 1 , author = author ) . save () await Book ( title = \"Book 3\" , year = 1923 , ranking = 5 , author = author ) . save () assert await Book . objects . min ( \"year\" ) == 1920 result = await Book . objects . min ([ \"year\" , \"ranking\" ]) assert result == dict ( year = 1920 , ranking = 1 ) assert await Book . objects . min ( \"title\" ) == \"Book 1\" assert await Author . objects . select_related ( \"books\" ) . min ( \"books__year\" ) == 1920 result = await Author . objects . select_related ( \"books\" ) . min ( [ \"books__year\" , \"books__ranking\" ] ) assert result == dict ( books__year = 1920 , books__ranking = 1 ) assert ( await Author . objects . select_related ( \"books\" ) . filter ( books__year__gt = 1925 ) . min ( \"books__year\" ) == 1930 )","title":"min"},{"location":"queries/aggregations/#max","text":"max(columns) -> Any Returns max value of columns for rows matching the given criteria (applied with filter and exclude if set before). Returns min value of columns for rows matching the given criteria (applied with filter and exclude if set before). You can pass one or many column names including related columns. As of now each column passed is aggregated separately (so sum(col1+col2) is not possible, you can have sum(col1, col2) and later add 2 returned sums in python) If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from typing import Optional import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" order_by = [ \"-name\" ] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" order_by = [ \"year\" , \"-ranking\" ] id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) A sample usage might look like following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 author = await Author ( name = \"Author 1\" ) . save () await Book ( title = \"Book 1\" , year = 1920 , ranking = 3 , author = author ) . save () await Book ( title = \"Book 2\" , year = 1930 , ranking = 1 , author = author ) . save () await Book ( title = \"Book 3\" , year = 1923 , ranking = 5 , author = author ) . save () assert await Book . objects . max ( \"year\" ) == 1930 result = await Book . objects . max ([ \"year\" , \"ranking\" ]) assert result == dict ( year = 1930 , ranking = 5 ) assert await Book . objects . max ( \"title\" ) == \"Book 3\" assert await Author . objects . select_related ( \"books\" ) . max ( \"books__year\" ) == 1930 result = await Author . objects . select_related ( \"books\" ) . max ( [ \"books__year\" , \"books__ranking\" ] ) assert result == dict ( books__year = 1930 , books__ranking = 5 ) assert ( await Author . objects . select_related ( \"books\" ) . filter ( books__year__lt = 1925 ) . max ( \"books__year\" ) == 1923 )","title":"max"},{"location":"queries/aggregations/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes a subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/aggregations/#count_1","text":"Works exactly the same as count function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"count"},{"location":"queries/aggregations/#exists_1","text":"Works exactly the same as exists function above but allows you to select columns from related objects from other side of the relation.","title":"exists"},{"location":"queries/aggregations/#sum_1","text":"Works exactly the same as sum function above but allows you to sum columns from related objects from other side of the relation.","title":"sum"},{"location":"queries/aggregations/#avg_1","text":"Works exactly the same as avg function above but allows you to average columns from related objects from other side of the relation.","title":"avg"},{"location":"queries/aggregations/#min_1","text":"Works exactly the same as min function above but allows you to select minimum of columns from related objects from other side of the relation.","title":"min"},{"location":"queries/aggregations/#max_1","text":"Works exactly the same as max function above but allows you to select maximum of columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"max"},{"location":"queries/create/","text":"Insert data into database Following methods allow you to insert data into the database. create(**kwargs) -> Model get_or_create(**kwargs) -> Model update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None Model Model.save() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.create(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.update_or_create(**kwargs) method create create(**kwargs): -> Model Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) The alternative is a split creation and persistence of the Model . 1 2 malibu = Album ( name = \"Malibu\" ) await malibu . save () Tip Check other Model methods in models get_or_create get_or_create(**kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being a equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement update_or_create update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement bulk_create bulk_create(objects: List[\"Model\"]) -> None Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class ToDo ( ormar . Model ): class Meta : tablename = \"todos\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) text : str = ormar . String ( max_length = 500 ) completed = ormar . Boolean ( default = False ) # create multiple instances at once with bulk_create await ToDo . objects . bulk_create ( [ ToDo ( text = \"Buy the groceries.\" ), ToDo ( text = \"Call Mum.\" , completed = True ), ToDo ( text = \"Send invoices.\" , completed = True ), ] ) todoes = await ToDo . objects . all () assert len ( todoes ) == 3 Model methods Each model instance have a set of methods to save , update or load itself. save You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. Tip Read more about save() method in models-save upsert It's a proxy to either save() or update(**kwargs) methods of a Model. If the pk is not set the save() method will be called. Tip Read more about upsert() method in models-upsert save_related Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. Tip Read more about save_related() method in models-save-related QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. create Works exactly the same as create function above but allows you to create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section get_or_create Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section update_or_create Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Insert data into database"},{"location":"queries/create/#insert-data-into-database","text":"Following methods allow you to insert data into the database. create(**kwargs) -> Model get_or_create(**kwargs) -> Model update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None Model Model.save() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.create(**kwargs) method QuerysetProxy.get_or_create(**kwargs) method QuerysetProxy.update_or_create(**kwargs) method","title":"Insert data into database"},{"location":"queries/create/#create","text":"create(**kwargs): -> Model Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) The alternative is a split creation and persistence of the Model . 1 2 malibu = Album ( name = \"Malibu\" ) await malibu . save () Tip Check other Model methods in models","title":"create"},{"location":"queries/create/#get_or_create","text":"get_or_create(**kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being a equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"get_or_create"},{"location":"queries/create/#update_or_create","text":"update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"update_or_create"},{"location":"queries/create/#bulk_create","text":"bulk_create(objects: List[\"Model\"]) -> None Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class ToDo ( ormar . Model ): class Meta : tablename = \"todos\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) text : str = ormar . String ( max_length = 500 ) completed = ormar . Boolean ( default = False ) # create multiple instances at once with bulk_create await ToDo . objects . bulk_create ( [ ToDo ( text = \"Buy the groceries.\" ), ToDo ( text = \"Call Mum.\" , completed = True ), ToDo ( text = \"Send invoices.\" , completed = True ), ] ) todoes = await ToDo . objects . all () assert len ( todoes ) == 3","title":"bulk_create"},{"location":"queries/create/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/create/#save","text":"You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. Tip Read more about save() method in models-save","title":"save"},{"location":"queries/create/#upsert","text":"It's a proxy to either save() or update(**kwargs) methods of a Model. If the pk is not set the save() method will be called. Tip Read more about upsert() method in models-upsert","title":"upsert"},{"location":"queries/create/#save_related","text":"Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. Tip Read more about save_related() method in models-save-related","title":"save_related"},{"location":"queries/create/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/create/#create_1","text":"Works exactly the same as create function above but allows you to create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"create"},{"location":"queries/create/#get_or_create_1","text":"Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get_or_create"},{"location":"queries/create/#update_or_create_1","text":"Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"update_or_create"},{"location":"queries/delete/","text":"Delete data from database Following methods allow you to delete data from the database. delete(each: bool = False, **kwargs) -> int Model Model.delete() method QuerysetProxy QuerysetProxy.remove() method QuerysetProxy.clear() method delete delete(each: bool = False, **kwargs) -> int QuerySet level delete is used to delete multiple records at once. You either have to filter the QuerySet first or provide a each=True flag to delete whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows deleted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace in Space' , author = \"Tolstoy, Leo\" , genre = 'Fantasy' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # delete accepts kwargs that will be used in filter # acting in same way as queryset.filter(**kwargs).delete() await Book . objects . delete ( genre = 'Fantasy' ) # delete all fantasy books all_books = await Book . objects . all () assert len ( all_books ) == 2 Model methods Each model instance have a set of methods to save , update or load itself. delete You can delete model instance by calling delete() method on it. Tip Read more about delete() method in models methods QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. remove Removal of the related model one by one. Removes the relation in the database. If you specify the keep_reversed flag to False ormar will also delete the related model from the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 9 10 album = await Album ( name = \"Malibu\" ) . save () track1 = await Track ( album = album , title = \"The Bird\" , position = 1 , play_count = 30 , ) . save () # remove through proxy from reverse side of relation await album . tracks . remove ( track1 , keep_reversed = False ) # the track was also deleted tracks = await Track . objects . all () assert len ( tracks ) == 0 clear Removal of all related models in one call. Removes also the relation in the database. If you specify the keep_reversed flag to False ormar will also delete the related model from the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 album = await Album ( name = \"Malibu\" ) . save () track1 = await Track ( album = album , title = \"The Bird\" , position = 1 , play_count = 30 , ) . save () track2 = await Track ( album = album , title = \"Heart don't stand a chance\" , position = 2 , play_count = 20 , ) . save () # removes the relation only -> clears foreign keys on tracks await album . tracks . clear () # removes also the tracks await album . tracks . clear ( keep_reversed = False )","title":"Delete data from database"},{"location":"queries/delete/#delete-data-from-database","text":"Following methods allow you to delete data from the database. delete(each: bool = False, **kwargs) -> int Model Model.delete() method QuerysetProxy QuerysetProxy.remove() method QuerysetProxy.clear() method","title":"Delete data from database"},{"location":"queries/delete/#delete","text":"delete(each: bool = False, **kwargs) -> int QuerySet level delete is used to delete multiple records at once. You either have to filter the QuerySet first or provide a each=True flag to delete whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows deleted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace in Space' , author = \"Tolstoy, Leo\" , genre = 'Fantasy' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # delete accepts kwargs that will be used in filter # acting in same way as queryset.filter(**kwargs).delete() await Book . objects . delete ( genre = 'Fantasy' ) # delete all fantasy books all_books = await Book . objects . all () assert len ( all_books ) == 2","title":"delete"},{"location":"queries/delete/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/delete/#delete_1","text":"You can delete model instance by calling delete() method on it. Tip Read more about delete() method in models methods","title":"delete"},{"location":"queries/delete/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/delete/#remove","text":"Removal of the related model one by one. Removes the relation in the database. If you specify the keep_reversed flag to False ormar will also delete the related model from the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 9 10 album = await Album ( name = \"Malibu\" ) . save () track1 = await Track ( album = album , title = \"The Bird\" , position = 1 , play_count = 30 , ) . save () # remove through proxy from reverse side of relation await album . tracks . remove ( track1 , keep_reversed = False ) # the track was also deleted tracks = await Track . objects . all () assert len ( tracks ) == 0","title":"remove"},{"location":"queries/delete/#clear","text":"Removal of all related models in one call. Removes also the relation in the database. If you specify the keep_reversed flag to False ormar will also delete the related model from the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 album = await Album ( name = \"Malibu\" ) . save () track1 = await Track ( album = album , title = \"The Bird\" , position = 1 , play_count = 30 , ) . save () track2 = await Track ( album = album , title = \"Heart don't stand a chance\" , position = 2 , play_count = 20 , ) . save () # removes the relation only -> clears foreign keys on tracks await album . tracks . clear () # removes also the tracks await album . tracks . clear ( keep_reversed = False )","title":"clear"},{"location":"queries/filter-and-sort/","text":"Filtering and sorting data You can use following methods to filter the data (sql where clause). filter(*args, **kwargs) -> QuerySet exclude(*args, **kwargs) -> QuerySet get(*args, **kwargs) -> Model get_or_none(*args, **kwargs) -> Optional[Model] get_or_create(*args, **kwargs) -> Model all(*args, **kwargs) -> List[Optional[Model]] QuerysetProxy QuerysetProxy.filter(*args, **kwargs) method QuerysetProxy.exclude(*args, **kwargs) method QuerysetProxy.get(*args, **kwargs) method QuerysetProxy.get_or_none(*args, **kwargs) method QuerysetProxy.get_or_create(*args, **kwargs) method QuerysetProxy.all(*args, **kwargs) method And following methods to sort the data (sql order by clause). order_by(columns:Union[List, str, OrderAction]) -> QuerySet QuerysetProxy QuerysetProxy.order_by(columns:Union[List, str, OrderAction]) method Filtering filter filter(*args, **kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 track = Track . objects . filter ( name = \"The Bird\" ) . get () # will return a track with name equal to 'The Bird' tracks = Track . objects . filter ( album__name = \"Fantasies\" ) . all () # will return all tracks where the columns album name = 'Fantasies' Django style filters You can use special filter suffix to change the filter operands: exact - exact match to value, sql column = <VALUE> can be written as album__name__exact='Malibu' iexact - exact match sql column = <VALUE> (case insensitive) can be written as album__name__iexact='malibu' contains - sql column LIKE '%<VALUE>%' can be written as album__name__contains='Mal' icontains - sql column LIKE '%<VALUE>%' (case insensitive) can be written as album__name__icontains='mal' in - sql column IN (<VALUE1>, <VALUE2>, ...) can be written as album__name__in=['Malibu', 'Barclay'] isnull - sql column IS NULL (and sql column IS NOT NULL ) can be written as album__name__isnull=True (isnotnull album__name__isnull=False ) gt - sql column > <VALUE> (greater than) can be written as position__gt=3 gte - sql column >= <VALUE> (greater or equal than) can be written as position__gte=3 lt - sql column < <VALUE> (lower than) can be written as position__lt=3 lte - sql column <= <VALUE> (lower equal than) can be written as position__lte=3 startswith - sql column LIKE '<VALUE>%' (exact start match) can be written as album__name__startswith='Mal' istartswith - sql column LIKE '<VALUE>%' (case insensitive) can be written as album__name__istartswith='mal' endswith - sql column LIKE '%<VALUE>' (exact end match) can be written as album__name__endswith='ibu' iendswith - sql column LIKE '%<VALUE>' (case insensitive) can be written as album__name__iendswith='IBU' Some samples: 1 2 3 4 5 6 7 8 9 10 11 # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) Product . objects . filter ( name = 'Test' , rating__gte = 3.0 ) . get () # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) # OR (categories.name IN ('Toys', 'Books')) Product . objects . filter ( ormar . or_ ( ormar . and_ ( name = 'Test' , rating__gte = 3.0 ), categories__name__in = [ 'Toys' , 'Books' ]) ) . get () # note: to read more about and_ and or_ read complex filters section below Python style filters exact - exact match to value, sql column = <VALUE> can be written as Track.album.name == 'Malibu iexact - exact match sql column = <VALUE> (case insensitive) can be written as Track.album.name.iexact('malibu') contains - sql column LIKE '%<VALUE>%' can be written as Track.album.name % 'Mal') can be written as Track.album.name.contains('Mal') icontains - sql column LIKE '%<VALUE>%' (case insensitive) can be written as Track.album.name.icontains('mal') in - sql column IN (<VALUE1>, <VALUE2>, ...) can be written as Track.album.name << ['Malibu', 'Barclay'] can be written as Track.album.name.in_(['Malibu', 'Barclay']) isnull - sql column IS NULL (and sql column IS NOT NULL ) can be written as Track.album.name >> None can be written as Track.album.name.isnull(True) not null can be written as Track.album.name.isnull(False) not null can be written as ~(Track.album.name >> None) not null can be written as ~(Track.album.name.isnull(True)) gt - sql column > <VALUE> (greater than) can be written as Track.album.name > 3 gte - sql column >= <VALUE> (greater or equal than) can be written as Track.album.name >= 3 lt - sql column < <VALUE> (lower than) can be written as Track.album.name < 3 lte - sql column <= <VALUE> (lower equal than) can be written as Track.album.name <= 3 startswith - sql column LIKE '<VALUE>%' (exact start match) can be written as Track.album.name.startswith('Mal') istartswith - sql column LIKE '<VALUE>%' (case insensitive) can be written as Track.album.name.istartswith('mal') endswith - sql column LIKE '%<VALUE>' (exact end match) can be written as Track.album.name.endswith('ibu') iendswith - sql column LIKE '%<VALUE>' (case insensitive) can be written as Track.album.name.iendswith('IBU') Some samples: 1 2 3 4 5 6 7 8 9 10 11 # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) Product . objects . filter ( ( Product . name == 'Test' ) & ( Product . rating >= 3.0 ) ) . get () # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) # OR (categories.name IN ('Toys', 'Books')) Product . objects . filter ( (( Product . name == 'Test' ) & ( Product . rating >= 3.0 )) | ( Product . categories . name << [ 'Toys' , 'Books' ]) ) . get () Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() Warning Note that you do not have to specify the % wildcard in contains and other filters, it's added for you. If you include % in your search value it will be escaped and treated as literal percentage sign inside the text. exclude exclude(*args, **kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which equals to where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 notes = await Track . objects . exclude ( position_gt = 3 ) . all () # returns all tracks with position < 3 Complex filters (including OR) By default both filter() and exclude() methods combine provided filter options with AND condition so filter(name=\"John\", age__gt=30) translates into WHERE name = 'John' AND age > 30 . Sometimes it's useful to query the database with conditions that should not be applied jointly like WHERE name = 'John' OR age > 30 , or build a complex where query that you would like to have bigger control over. After all WHERE (name = 'John' OR age > 30) and city='New York' is completely different than WHERE name = 'John' OR (age > 30 and city='New York') . In order to build OR and nested conditions ormar provides two functions that can be used in filter() and exclude() in QuerySet and QuerysetProxy . Note Note that you can provide those methods in any other method like get() or all() that accepts *args . Call to or_ and and_ can be nested in each other, as well as combined with keyword arguments. Since it sounds more complicated than it is, let's look at some examples. Given a sample models like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) Let's create some sample data: 1 2 3 4 5 6 7 tolkien = await Author ( name = \"J.R.R. Tolkien\" ) . save () await Book ( author = tolkien , title = \"The Hobbit\" , year = 1933 ) . save () await Book ( author = tolkien , title = \"The Lord of the Rings\" , year = 1955 ) . save () await Book ( author = tolkien , title = \"The Silmarillion\" , year = 1977 ) . save () sapkowski = await Author ( name = \"Andrzej Sapkowski\" ) . save () await Book ( author = sapkowski , title = \"The Witcher\" , year = 1990 ) . save () await Book ( author = sapkowski , title = \"The Tower of Fools\" , year = 2002 ) . save () We can construct some sample complex queries: Let's select books of Tolkien OR books written after 1970 sql: WHERE ( authors.name = 'J.R.R. Tolkien' OR books.year > 1970 ) Django style 1 2 3 4 5 6 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( author__name = \"J.R.R. Tolkien\" , year__gt = 1970 )) . all () ) assert len ( books ) == 5 Python style 1 2 3 4 5 6 books = ( await Book . objects . select_related ( \"author\" ) . filter (( Book . author . name == \"J.R.R. Tolkien\" ) | ( Book . year > 1970 )) . all () ) assert len ( books ) == 5 Now let's select books written after 1960 or before 1940 which were written by Tolkien. sql: WHERE ( books.year > 1960 OR books.year < 1940 ) AND authors.name = 'J.R.R. Tolkien' Django style 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # OPTION 1 - split and into separate call books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( year__gt = 1960 , year__lt = 1940 )) . filter ( author__name = \"J.R.R. Tolkien\" ) . all () ) assert len ( books ) == 2 # OPTION 2 - all in one books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . and_ ( ormar . or_ ( year__gt = 1960 , year__lt = 1940 ), author__name = \"J.R.R. Tolkien\" , ) ) . all () ) assert len ( books ) == 2 assert books [ 0 ] . title == \"The Hobbit\" assert books [ 1 ] . title == \"The Silmarillion\" Python style 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 books = ( await Book . objects . select_related ( \"author\" ) . filter (( Book . year > 1960 ) | ( Book . year < 1940 )) . filter ( Book . author . name == \"J.R.R. Tolkien\" ) . all () ) assert len ( books ) == 2 # OPTION 2 - all in one books = ( await Book . objects . select_related ( \"author\" ) . filter ( ( ( Book . year > 1960 ) | ( Book . year < 1940 ) ) & ( Book . author . name == \"J.R.R. Tolkien\" ) ) . all () ) assert len ( books ) == 2 assert books [ 0 ] . title == \"The Hobbit\" assert books [ 1 ] . title == \"The Silmarillion\" Books of Sapkowski from before 2000 or books of Tolkien written after 1960 sql: WHERE ( ( books.year > 1960 AND authors.name = 'J.R.R. Tolkien' ) OR ( books.year < 2000 AND authors.name = 'Andrzej Sapkowski' ) ) Django style 1 2 3 4 5 6 7 8 9 10 11 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( ormar . and_ ( year__gt = 1960 , author__name = \"J.R.R. Tolkien\" ), ormar . and_ ( year__lt = 2000 , author__name = \"Andrzej Sapkowski\" ), ) ) . all () ) assert len ( books ) == 2 Python style 1 2 3 4 5 6 7 8 9 books = ( await Book . objects . select_related ( \"author\" ) . filter ( (( Book . year > 1960 ) & ( Book . author . name == \"J.R.R. Tolkien\" )) | (( Book . year < 2000 ) & ( Book . author . name == \"Andrzej Sapkowski\" )) ) . all () ) assert len ( books ) == 2 Of course those functions can have more than 2 conditions, so if we for example want books that contains 'hobbit': sql: WHERE ( ( books.year > 1960 AND authors.name = 'J.R.R. Tolkien' ) OR ( books.year < 2000 AND os0cec_authors.name = 'Andrzej Sapkowski' ) OR books.title LIKE '%hobbit%' ) Django style 1 2 3 4 5 6 7 8 9 10 11 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( ormar . and_ ( year__gt = 1960 , author__name = \"J.R.R. Tolkien\" ), ormar . and_ ( year__lt = 2000 , author__name = \"Andrzej Sapkowski\" ), title__icontains = \"hobbit\" , ) ) . all () ) Python style 1 2 3 4 5 6 7 8 9 books = ( await Book . objects . select_related ( \"author\" ) . filter ( (( Book . year > 1960 ) & ( Book . author . name == \"J.R.R. Tolkien\" )) | (( Book . year < 2000 ) & ( Book . author . name == \"Andrzej Sapkowski\" )) | ( Book . title . icontains ( \"hobbit\" )) ) . all () ) If you want or need to you can nest deeper conditions as deep as you want, in example to achieve a query like this: sql: 1 2 3 WHERE ( ( ( books.year > 1960 OR books.year < 1940 ) AND authors.name = 'J.R.R. Tolkien' ) OR ( books.year < 2000 AND authors.name = 'Andrzej Sapkowski' ) ) You can construct a query as follows: Django style 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( ormar . and_ ( ormar . or_ ( year__gt = 1960 , year__lt = 1940 ), author__name = \"J.R.R. Tolkien\" , ), ormar . and_ ( year__lt = 2000 , author__name = \"Andrzej Sapkowski\" ), ) ) . all () ) assert len ( books ) == 3 assert books [ 0 ] . title == \"The Hobbit\" assert books [ 1 ] . title == \"The Silmarillion\" assert books [ 2 ] . title == \"The Witcher\" Python style 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ( ( ( Book . year > 1960 ) | ( Book . year < 1940 ) ) & ( Book . author . name == \"J.R.R. Tolkien\" ) ) | ( ( Book . year < 2000 ) & ( Book . author . name == \"Andrzej Sapkowski\" ) ) ) . all () ) assert len ( books ) == 3 assert books [ 0 ] . title == \"The Hobbit\" assert books [ 1 ] . title == \"The Silmarillion\" assert books [ 2 ] . title == \"The Witcher\" By now you should already have an idea how ormar.or_ and ormar.and_ works. Of course, you could chain them in any other methods of queryset, so in example a perfectly valid query can look like follows: 1 2 3 4 5 6 7 8 9 10 11 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( year__gt = 1980 , author__name = \"Andrzej Sapkowski\" )) . filter ( title__startswith = \"The\" ) . limit ( 1 ) . offset ( 1 ) . order_by ( \"-id\" ) . all () ) assert len ( books ) == 1 assert books [ 0 ] . title == \"The Witcher\" Same applies to python style chaining and nesting. Django style Note that with django style you cannot provide the same keyword argument several times so queries like filter(ormar.or_(name='Jack', name='John')) are not allowed. If you want to check the same column for several values simply use in operator: filter(name__in=['Jack','John']) . If you pass only one parameter to or_ or and_ functions it's simply wrapped in parenthesis and has no effect on actual query, so in the end all 3 queries are identical: 1 2 3 await Book . objects . filter ( title = 'The Hobbit' ) . get () await Book . objects . filter ( ormar . or_ ( title = 'The Hobbit' )) . get () await Book . objects . filter ( ormar . and_ ( title = 'The Hobbit' )) . get () Note Note that or_ and and_ queries will have WHERE (title='The Hobbit') but the parenthesis is redundant and has no real effect. This feature can be used if you really need to use the same field name twice. Remember that you cannot pass the same keyword arguments twice to the function, so how you can query in example WHERE (authors.name LIKE '%tolkien%') OR (authors.name LIKE '%sapkowski%')) ? You cannot do: 1 2 3 4 5 6 7 8 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( author__name__icontains = \"tolkien\" , author__name__icontains = \"sapkowski\" # you cannot use same keyword twice in or_! )) # python syntax error . all () ) But you can do this: 1 2 3 4 5 6 7 8 9 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( ormar . and_ ( author__name__icontains = \"tolkien\" ), # one argument == just wrapped in () ormar . and_ ( author__name__icontains = \"sapkowski\" ) )) . all () ) assert len ( books ) == 5 Python style Note that with python style you can perfectly use the same fields as many times as you want. 1 2 3 4 5 6 7 8 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ( Book . author . name . icontains ( \"tolkien\" )) | ( Book . author . name . icontains ( \"sapkowski\" )) )) . all () ) get get(*args, **kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. When any args and/or kwargs are passed it's a shortcut equivalent to calling filter(*args, **kwargs).get() Tip To read more about filter go to filter . To read more about get go to read/get get_or_none Exact equivalent of get described above but instead of raising the exception returns None if no db record matching the criteria is found. get_or_create get_or_create(*args, **kwargs) -> Model Combination of create and get methods. When any args and/or kwargs are passed it's a shortcut equivalent to calling filter(*args, **kwargs).get_or_create() Tip To read more about filter go to filter . To read more about get_or_create go to read/get_or_create Warning When given item does not exist you need to pass kwargs for all required fields of the model, including but not limited to primary_key column (unless it's autoincrement). all all(*args, **kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. When any kwargs are passed it's a shortcut equivalent to calling filter(*args, **kwargs).all() Tip To read more about filter go to filter . To read more about all go to read/all QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. filter Works exactly the same as filter function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section exclude Works exactly the same as exclude function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section get Works exactly the same as get function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section get_or_none Exact equivalent of get described above but instead of raising the exception returns None if no db record matching the criteria is found. get_or_create Works exactly the same as get_or_create function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section all Works exactly the same as all function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section Sorting order_by order_by(columns: Union[List, str, OrderAction]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with different fields. Ordering in sql will be applied in order of names you provide in order_by. Tip By default if you do not provide ordering ormar explicitly orders by all primary keys Warning If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. Sample raw database rows result (sort by child model desc): 1 2 3 MODEL: 1 - Child Model - 3 MODEL: 2 - Child Model - 2 MODEL: 1 - Child Model - 1 will result in 2 rows of result: 1 2 MODEL: 1 - Child Models: [3, 1] # encountered first in result, all children rows combined MODEL: 2 - Child Modles: [2] The main model will never duplicate in the result Given sample Models like following: 1 -- 8 < -- \"../../docs_src/queries/docs007.py\" To order by main model field just provide a field name Django style 1 2 3 4 5 6 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"name\" ) . all () assert [ x . name . replace ( \"Toy \" , \"\" ) for x in toys ] == [ str ( x + 1 ) for x in range ( 6 ) ] assert toys [ 0 ] . owner == zeus assert toys [ 1 ] . owner == aphrodite Python style 1 2 3 4 5 6 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( Toy . name . asc ()) . all () assert [ x . name . replace ( \"Toy \" , \"\" ) for x in toys ] == [ str ( x + 1 ) for x in range ( 6 ) ] assert toys [ 0 ] . owner == zeus assert toys [ 1 ] . owner == aphrodite To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. Django style 1 2 3 4 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"owner__name\" ) . all () assert toys [ 0 ] . owner . name == toys [ 1 ] . owner . name == \"Aphrodite\" assert toys [ 2 ] . owner . name == toys [ 3 ] . owner . name == \"Hermes\" assert toys [ 4 ] . owner . name == toys [ 5 ] . owner . name == \"Zeus\" Python style 1 2 3 4 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( Toy . owner . name . asc ()) . all () assert toys [ 0 ] . owner . name == toys [ 1 ] . owner . name == \"Aphrodite\" assert toys [ 2 ] . owner . name == toys [ 3 ] . owner . name == \"Hermes\" assert toys [ 4 ] . owner . name == toys [ 5 ] . owner . name == \"Zeus\" To sort in descending order provide a hyphen in front of the field name Django style 1 2 3 4 5 6 7 8 owner = ( await Owner . objects . select_related ( \"toys\" ) . order_by ( \"-toys__name\" ) . filter ( name = \"Zeus\" ) . get () ) assert owner . toys [ 0 ] . name == \"Toy 4\" assert owner . toys [ 1 ] . name == \"Toy 1\" Python style 1 2 3 4 5 6 7 8 owner = ( await Owner . objects . select_related ( \"toys\" ) . order_by ( Owner . toys . name . desc ()) . filter ( Owner . name == \"Zeus\" ) . get () ) assert owner . toys [ 0 ] . name == \"Toy 4\" assert owner . toys [ 1 ] . name == \"Toy 1\" Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() Default sorting in ormar Since order of rows in a database is not guaranteed, ormar always issues an order by sql clause to each (part of) query even if you do not provide order yourself. When querying the database with given model by default the Model is ordered by the primary_key column ascending. If you wish to change the default behaviour you can do it by providing orders_by parameter to model Meta class. Tip To read more about models sort order visit models section of documentation By default the relations follow the same ordering, but you can modify the order in which related models are loaded during query by providing orders_by and related_orders_by parameters to relations. Tip To read more about models sort order visit relations section of documentation Order in which order_by clauses are applied is as follows: Explicitly passed order_by() calls in query Relation passed orders_by and related_orders_by if exists Model Meta class orders_by Model primary_key column ascending (fallback, used if none of above provided) Order from only one source is applied to each Model (so that you can always overwrite it in a single query). That means that if you provide explicit order_by for a model in a query, the Relation and Model sort orders are skipped. If you provide a Relation one, the Model sort is skipped. Finally, if you provide one for Model the default one by primary_key is skipped. QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. order_by Works exactly the same as order_by function above but allows you to sort related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Filtering and sorting data"},{"location":"queries/filter-and-sort/#filtering-and-sorting-data","text":"You can use following methods to filter the data (sql where clause). filter(*args, **kwargs) -> QuerySet exclude(*args, **kwargs) -> QuerySet get(*args, **kwargs) -> Model get_or_none(*args, **kwargs) -> Optional[Model] get_or_create(*args, **kwargs) -> Model all(*args, **kwargs) -> List[Optional[Model]] QuerysetProxy QuerysetProxy.filter(*args, **kwargs) method QuerysetProxy.exclude(*args, **kwargs) method QuerysetProxy.get(*args, **kwargs) method QuerysetProxy.get_or_none(*args, **kwargs) method QuerysetProxy.get_or_create(*args, **kwargs) method QuerysetProxy.all(*args, **kwargs) method And following methods to sort the data (sql order by clause). order_by(columns:Union[List, str, OrderAction]) -> QuerySet QuerysetProxy QuerysetProxy.order_by(columns:Union[List, str, OrderAction]) method","title":"Filtering and sorting data"},{"location":"queries/filter-and-sort/#filtering","text":"","title":"Filtering"},{"location":"queries/filter-and-sort/#filter","text":"filter(*args, **kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 track = Track . objects . filter ( name = \"The Bird\" ) . get () # will return a track with name equal to 'The Bird' tracks = Track . objects . filter ( album__name = \"Fantasies\" ) . all () # will return all tracks where the columns album name = 'Fantasies'","title":"filter"},{"location":"queries/filter-and-sort/#django-style-filters","text":"You can use special filter suffix to change the filter operands: exact - exact match to value, sql column = <VALUE> can be written as album__name__exact='Malibu' iexact - exact match sql column = <VALUE> (case insensitive) can be written as album__name__iexact='malibu' contains - sql column LIKE '%<VALUE>%' can be written as album__name__contains='Mal' icontains - sql column LIKE '%<VALUE>%' (case insensitive) can be written as album__name__icontains='mal' in - sql column IN (<VALUE1>, <VALUE2>, ...) can be written as album__name__in=['Malibu', 'Barclay'] isnull - sql column IS NULL (and sql column IS NOT NULL ) can be written as album__name__isnull=True (isnotnull album__name__isnull=False ) gt - sql column > <VALUE> (greater than) can be written as position__gt=3 gte - sql column >= <VALUE> (greater or equal than) can be written as position__gte=3 lt - sql column < <VALUE> (lower than) can be written as position__lt=3 lte - sql column <= <VALUE> (lower equal than) can be written as position__lte=3 startswith - sql column LIKE '<VALUE>%' (exact start match) can be written as album__name__startswith='Mal' istartswith - sql column LIKE '<VALUE>%' (case insensitive) can be written as album__name__istartswith='mal' endswith - sql column LIKE '%<VALUE>' (exact end match) can be written as album__name__endswith='ibu' iendswith - sql column LIKE '%<VALUE>' (case insensitive) can be written as album__name__iendswith='IBU' Some samples: 1 2 3 4 5 6 7 8 9 10 11 # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) Product . objects . filter ( name = 'Test' , rating__gte = 3.0 ) . get () # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) # OR (categories.name IN ('Toys', 'Books')) Product . objects . filter ( ormar . or_ ( ormar . and_ ( name = 'Test' , rating__gte = 3.0 ), categories__name__in = [ 'Toys' , 'Books' ]) ) . get () # note: to read more about and_ and or_ read complex filters section below","title":"Django style filters"},{"location":"queries/filter-and-sort/#python-style-filters","text":"exact - exact match to value, sql column = <VALUE> can be written as Track.album.name == 'Malibu iexact - exact match sql column = <VALUE> (case insensitive) can be written as Track.album.name.iexact('malibu') contains - sql column LIKE '%<VALUE>%' can be written as Track.album.name % 'Mal') can be written as Track.album.name.contains('Mal') icontains - sql column LIKE '%<VALUE>%' (case insensitive) can be written as Track.album.name.icontains('mal') in - sql column IN (<VALUE1>, <VALUE2>, ...) can be written as Track.album.name << ['Malibu', 'Barclay'] can be written as Track.album.name.in_(['Malibu', 'Barclay']) isnull - sql column IS NULL (and sql column IS NOT NULL ) can be written as Track.album.name >> None can be written as Track.album.name.isnull(True) not null can be written as Track.album.name.isnull(False) not null can be written as ~(Track.album.name >> None) not null can be written as ~(Track.album.name.isnull(True)) gt - sql column > <VALUE> (greater than) can be written as Track.album.name > 3 gte - sql column >= <VALUE> (greater or equal than) can be written as Track.album.name >= 3 lt - sql column < <VALUE> (lower than) can be written as Track.album.name < 3 lte - sql column <= <VALUE> (lower equal than) can be written as Track.album.name <= 3 startswith - sql column LIKE '<VALUE>%' (exact start match) can be written as Track.album.name.startswith('Mal') istartswith - sql column LIKE '<VALUE>%' (case insensitive) can be written as Track.album.name.istartswith('mal') endswith - sql column LIKE '%<VALUE>' (exact end match) can be written as Track.album.name.endswith('ibu') iendswith - sql column LIKE '%<VALUE>' (case insensitive) can be written as Track.album.name.iendswith('IBU') Some samples: 1 2 3 4 5 6 7 8 9 10 11 # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) Product . objects . filter ( ( Product . name == 'Test' ) & ( Product . rating >= 3.0 ) ) . get () # sql: ( product.name = 'Test' AND product.rating >= 3.0 ) # OR (categories.name IN ('Toys', 'Books')) Product . objects . filter ( (( Product . name == 'Test' ) & ( Product . rating >= 3.0 )) | ( Product . categories . name << [ 'Toys' , 'Books' ]) ) . get () Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() Warning Note that you do not have to specify the % wildcard in contains and other filters, it's added for you. If you include % in your search value it will be escaped and treated as literal percentage sign inside the text.","title":"Python style filters"},{"location":"queries/filter-and-sort/#exclude","text":"exclude(*args, **kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which equals to where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 notes = await Track . objects . exclude ( position_gt = 3 ) . all () # returns all tracks with position < 3","title":"exclude"},{"location":"queries/filter-and-sort/#complex-filters-including-or","text":"By default both filter() and exclude() methods combine provided filter options with AND condition so filter(name=\"John\", age__gt=30) translates into WHERE name = 'John' AND age > 30 . Sometimes it's useful to query the database with conditions that should not be applied jointly like WHERE name = 'John' OR age > 30 , or build a complex where query that you would like to have bigger control over. After all WHERE (name = 'John' OR age > 30) and city='New York' is completely different than WHERE name = 'John' OR (age > 30 and city='New York') . In order to build OR and nested conditions ormar provides two functions that can be used in filter() and exclude() in QuerySet and QuerysetProxy . Note Note that you can provide those methods in any other method like get() or all() that accepts *args . Call to or_ and and_ can be nested in each other, as well as combined with keyword arguments. Since it sounds more complicated than it is, let's look at some examples. Given a sample models like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) Let's create some sample data: 1 2 3 4 5 6 7 tolkien = await Author ( name = \"J.R.R. Tolkien\" ) . save () await Book ( author = tolkien , title = \"The Hobbit\" , year = 1933 ) . save () await Book ( author = tolkien , title = \"The Lord of the Rings\" , year = 1955 ) . save () await Book ( author = tolkien , title = \"The Silmarillion\" , year = 1977 ) . save () sapkowski = await Author ( name = \"Andrzej Sapkowski\" ) . save () await Book ( author = sapkowski , title = \"The Witcher\" , year = 1990 ) . save () await Book ( author = sapkowski , title = \"The Tower of Fools\" , year = 2002 ) . save () We can construct some sample complex queries: Let's select books of Tolkien OR books written after 1970 sql: WHERE ( authors.name = 'J.R.R. Tolkien' OR books.year > 1970 )","title":"Complex filters (including OR)"},{"location":"queries/filter-and-sort/#django-style","text":"1 2 3 4 5 6 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( author__name = \"J.R.R. Tolkien\" , year__gt = 1970 )) . all () ) assert len ( books ) == 5","title":"Django style"},{"location":"queries/filter-and-sort/#python-style","text":"1 2 3 4 5 6 books = ( await Book . objects . select_related ( \"author\" ) . filter (( Book . author . name == \"J.R.R. Tolkien\" ) | ( Book . year > 1970 )) . all () ) assert len ( books ) == 5 Now let's select books written after 1960 or before 1940 which were written by Tolkien. sql: WHERE ( books.year > 1960 OR books.year < 1940 ) AND authors.name = 'J.R.R. Tolkien'","title":"Python style"},{"location":"queries/filter-and-sort/#django-style_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # OPTION 1 - split and into separate call books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( year__gt = 1960 , year__lt = 1940 )) . filter ( author__name = \"J.R.R. Tolkien\" ) . all () ) assert len ( books ) == 2 # OPTION 2 - all in one books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . and_ ( ormar . or_ ( year__gt = 1960 , year__lt = 1940 ), author__name = \"J.R.R. Tolkien\" , ) ) . all () ) assert len ( books ) == 2 assert books [ 0 ] . title == \"The Hobbit\" assert books [ 1 ] . title == \"The Silmarillion\"","title":"Django style"},{"location":"queries/filter-and-sort/#python-style_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 books = ( await Book . objects . select_related ( \"author\" ) . filter (( Book . year > 1960 ) | ( Book . year < 1940 )) . filter ( Book . author . name == \"J.R.R. Tolkien\" ) . all () ) assert len ( books ) == 2 # OPTION 2 - all in one books = ( await Book . objects . select_related ( \"author\" ) . filter ( ( ( Book . year > 1960 ) | ( Book . year < 1940 ) ) & ( Book . author . name == \"J.R.R. Tolkien\" ) ) . all () ) assert len ( books ) == 2 assert books [ 0 ] . title == \"The Hobbit\" assert books [ 1 ] . title == \"The Silmarillion\" Books of Sapkowski from before 2000 or books of Tolkien written after 1960 sql: WHERE ( ( books.year > 1960 AND authors.name = 'J.R.R. Tolkien' ) OR ( books.year < 2000 AND authors.name = 'Andrzej Sapkowski' ) )","title":"Python style"},{"location":"queries/filter-and-sort/#django-style_2","text":"1 2 3 4 5 6 7 8 9 10 11 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( ormar . and_ ( year__gt = 1960 , author__name = \"J.R.R. Tolkien\" ), ormar . and_ ( year__lt = 2000 , author__name = \"Andrzej Sapkowski\" ), ) ) . all () ) assert len ( books ) == 2","title":"Django style"},{"location":"queries/filter-and-sort/#python-style_2","text":"1 2 3 4 5 6 7 8 9 books = ( await Book . objects . select_related ( \"author\" ) . filter ( (( Book . year > 1960 ) & ( Book . author . name == \"J.R.R. Tolkien\" )) | (( Book . year < 2000 ) & ( Book . author . name == \"Andrzej Sapkowski\" )) ) . all () ) assert len ( books ) == 2 Of course those functions can have more than 2 conditions, so if we for example want books that contains 'hobbit': sql: WHERE ( ( books.year > 1960 AND authors.name = 'J.R.R. Tolkien' ) OR ( books.year < 2000 AND os0cec_authors.name = 'Andrzej Sapkowski' ) OR books.title LIKE '%hobbit%' )","title":"Python style"},{"location":"queries/filter-and-sort/#django-style_3","text":"1 2 3 4 5 6 7 8 9 10 11 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( ormar . and_ ( year__gt = 1960 , author__name = \"J.R.R. Tolkien\" ), ormar . and_ ( year__lt = 2000 , author__name = \"Andrzej Sapkowski\" ), title__icontains = \"hobbit\" , ) ) . all () )","title":"Django style"},{"location":"queries/filter-and-sort/#python-style_3","text":"1 2 3 4 5 6 7 8 9 books = ( await Book . objects . select_related ( \"author\" ) . filter ( (( Book . year > 1960 ) & ( Book . author . name == \"J.R.R. Tolkien\" )) | (( Book . year < 2000 ) & ( Book . author . name == \"Andrzej Sapkowski\" )) | ( Book . title . icontains ( \"hobbit\" )) ) . all () ) If you want or need to you can nest deeper conditions as deep as you want, in example to achieve a query like this: sql: 1 2 3 WHERE ( ( ( books.year > 1960 OR books.year < 1940 ) AND authors.name = 'J.R.R. Tolkien' ) OR ( books.year < 2000 AND authors.name = 'Andrzej Sapkowski' ) ) You can construct a query as follows:","title":"Python style"},{"location":"queries/filter-and-sort/#django-style_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( ormar . and_ ( ormar . or_ ( year__gt = 1960 , year__lt = 1940 ), author__name = \"J.R.R. Tolkien\" , ), ormar . and_ ( year__lt = 2000 , author__name = \"Andrzej Sapkowski\" ), ) ) . all () ) assert len ( books ) == 3 assert books [ 0 ] . title == \"The Hobbit\" assert books [ 1 ] . title == \"The Silmarillion\" assert books [ 2 ] . title == \"The Witcher\"","title":"Django style"},{"location":"queries/filter-and-sort/#python-style_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ( ( ( Book . year > 1960 ) | ( Book . year < 1940 ) ) & ( Book . author . name == \"J.R.R. Tolkien\" ) ) | ( ( Book . year < 2000 ) & ( Book . author . name == \"Andrzej Sapkowski\" ) ) ) . all () ) assert len ( books ) == 3 assert books [ 0 ] . title == \"The Hobbit\" assert books [ 1 ] . title == \"The Silmarillion\" assert books [ 2 ] . title == \"The Witcher\" By now you should already have an idea how ormar.or_ and ormar.and_ works. Of course, you could chain them in any other methods of queryset, so in example a perfectly valid query can look like follows: 1 2 3 4 5 6 7 8 9 10 11 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( year__gt = 1980 , author__name = \"Andrzej Sapkowski\" )) . filter ( title__startswith = \"The\" ) . limit ( 1 ) . offset ( 1 ) . order_by ( \"-id\" ) . all () ) assert len ( books ) == 1 assert books [ 0 ] . title == \"The Witcher\" Same applies to python style chaining and nesting.","title":"Python style"},{"location":"queries/filter-and-sort/#django-style_5","text":"Note that with django style you cannot provide the same keyword argument several times so queries like filter(ormar.or_(name='Jack', name='John')) are not allowed. If you want to check the same column for several values simply use in operator: filter(name__in=['Jack','John']) . If you pass only one parameter to or_ or and_ functions it's simply wrapped in parenthesis and has no effect on actual query, so in the end all 3 queries are identical: 1 2 3 await Book . objects . filter ( title = 'The Hobbit' ) . get () await Book . objects . filter ( ormar . or_ ( title = 'The Hobbit' )) . get () await Book . objects . filter ( ormar . and_ ( title = 'The Hobbit' )) . get () Note Note that or_ and and_ queries will have WHERE (title='The Hobbit') but the parenthesis is redundant and has no real effect. This feature can be used if you really need to use the same field name twice. Remember that you cannot pass the same keyword arguments twice to the function, so how you can query in example WHERE (authors.name LIKE '%tolkien%') OR (authors.name LIKE '%sapkowski%')) ? You cannot do: 1 2 3 4 5 6 7 8 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( author__name__icontains = \"tolkien\" , author__name__icontains = \"sapkowski\" # you cannot use same keyword twice in or_! )) # python syntax error . all () ) But you can do this: 1 2 3 4 5 6 7 8 9 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ormar . or_ ( ormar . and_ ( author__name__icontains = \"tolkien\" ), # one argument == just wrapped in () ormar . and_ ( author__name__icontains = \"sapkowski\" ) )) . all () ) assert len ( books ) == 5","title":"Django style"},{"location":"queries/filter-and-sort/#python-style_5","text":"Note that with python style you can perfectly use the same fields as many times as you want. 1 2 3 4 5 6 7 8 books = ( await Book . objects . select_related ( \"author\" ) . filter ( ( Book . author . name . icontains ( \"tolkien\" )) | ( Book . author . name . icontains ( \"sapkowski\" )) )) . all () )","title":"Python style"},{"location":"queries/filter-and-sort/#get","text":"get(*args, **kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. When any args and/or kwargs are passed it's a shortcut equivalent to calling filter(*args, **kwargs).get() Tip To read more about filter go to filter . To read more about get go to read/get","title":"get"},{"location":"queries/filter-and-sort/#get_or_none","text":"Exact equivalent of get described above but instead of raising the exception returns None if no db record matching the criteria is found.","title":"get_or_none"},{"location":"queries/filter-and-sort/#get_or_create","text":"get_or_create(*args, **kwargs) -> Model Combination of create and get methods. When any args and/or kwargs are passed it's a shortcut equivalent to calling filter(*args, **kwargs).get_or_create() Tip To read more about filter go to filter . To read more about get_or_create go to read/get_or_create Warning When given item does not exist you need to pass kwargs for all required fields of the model, including but not limited to primary_key column (unless it's autoincrement).","title":"get_or_create"},{"location":"queries/filter-and-sort/#all","text":"all(*args, **kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. When any kwargs are passed it's a shortcut equivalent to calling filter(*args, **kwargs).all() Tip To read more about filter go to filter . To read more about all go to read/all","title":"all"},{"location":"queries/filter-and-sort/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/filter-and-sort/#filter_1","text":"Works exactly the same as filter function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"filter"},{"location":"queries/filter-and-sort/#exclude_1","text":"Works exactly the same as exclude function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"exclude"},{"location":"queries/filter-and-sort/#get_1","text":"Works exactly the same as get function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get"},{"location":"queries/filter-and-sort/#get_or_none_1","text":"Exact equivalent of get described above but instead of raising the exception returns None if no db record matching the criteria is found.","title":"get_or_none"},{"location":"queries/filter-and-sort/#get_or_create_1","text":"Works exactly the same as get_or_create function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get_or_create"},{"location":"queries/filter-and-sort/#all_1","text":"Works exactly the same as all function above but allows you to filter related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"all"},{"location":"queries/filter-and-sort/#sorting","text":"","title":"Sorting"},{"location":"queries/filter-and-sort/#order_by","text":"order_by(columns: Union[List, str, OrderAction]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with different fields. Ordering in sql will be applied in order of names you provide in order_by. Tip By default if you do not provide ordering ormar explicitly orders by all primary keys Warning If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. Sample raw database rows result (sort by child model desc): 1 2 3 MODEL: 1 - Child Model - 3 MODEL: 2 - Child Model - 2 MODEL: 1 - Child Model - 1 will result in 2 rows of result: 1 2 MODEL: 1 - Child Models: [3, 1] # encountered first in result, all children rows combined MODEL: 2 - Child Modles: [2] The main model will never duplicate in the result Given sample Models like following: 1 -- 8 < -- \"../../docs_src/queries/docs007.py\" To order by main model field just provide a field name","title":"order_by"},{"location":"queries/filter-and-sort/#django-style_6","text":"1 2 3 4 5 6 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"name\" ) . all () assert [ x . name . replace ( \"Toy \" , \"\" ) for x in toys ] == [ str ( x + 1 ) for x in range ( 6 ) ] assert toys [ 0 ] . owner == zeus assert toys [ 1 ] . owner == aphrodite","title":"Django style"},{"location":"queries/filter-and-sort/#python-style_6","text":"1 2 3 4 5 6 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( Toy . name . asc ()) . all () assert [ x . name . replace ( \"Toy \" , \"\" ) for x in toys ] == [ str ( x + 1 ) for x in range ( 6 ) ] assert toys [ 0 ] . owner == zeus assert toys [ 1 ] . owner == aphrodite To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields.","title":"Python style"},{"location":"queries/filter-and-sort/#django-style_7","text":"1 2 3 4 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"owner__name\" ) . all () assert toys [ 0 ] . owner . name == toys [ 1 ] . owner . name == \"Aphrodite\" assert toys [ 2 ] . owner . name == toys [ 3 ] . owner . name == \"Hermes\" assert toys [ 4 ] . owner . name == toys [ 5 ] . owner . name == \"Zeus\"","title":"Django style"},{"location":"queries/filter-and-sort/#python-style_7","text":"1 2 3 4 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( Toy . owner . name . asc ()) . all () assert toys [ 0 ] . owner . name == toys [ 1 ] . owner . name == \"Aphrodite\" assert toys [ 2 ] . owner . name == toys [ 3 ] . owner . name == \"Hermes\" assert toys [ 4 ] . owner . name == toys [ 5 ] . owner . name == \"Zeus\" To sort in descending order provide a hyphen in front of the field name","title":"Python style"},{"location":"queries/filter-and-sort/#django-style_8","text":"1 2 3 4 5 6 7 8 owner = ( await Owner . objects . select_related ( \"toys\" ) . order_by ( \"-toys__name\" ) . filter ( name = \"Zeus\" ) . get () ) assert owner . toys [ 0 ] . name == \"Toy 4\" assert owner . toys [ 1 ] . name == \"Toy 1\"","title":"Django style"},{"location":"queries/filter-and-sort/#python-style_8","text":"1 2 3 4 5 6 7 8 owner = ( await Owner . objects . select_related ( \"toys\" ) . order_by ( Owner . toys . name . desc ()) . filter ( Owner . name == \"Zeus\" ) . get () ) assert owner . toys [ 0 ] . name == \"Toy 4\" assert owner . toys [ 1 ] . name == \"Toy 1\" Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"Python style"},{"location":"queries/filter-and-sort/#default-sorting-in-ormar","text":"Since order of rows in a database is not guaranteed, ormar always issues an order by sql clause to each (part of) query even if you do not provide order yourself. When querying the database with given model by default the Model is ordered by the primary_key column ascending. If you wish to change the default behaviour you can do it by providing orders_by parameter to model Meta class. Tip To read more about models sort order visit models section of documentation By default the relations follow the same ordering, but you can modify the order in which related models are loaded during query by providing orders_by and related_orders_by parameters to relations. Tip To read more about models sort order visit relations section of documentation Order in which order_by clauses are applied is as follows: Explicitly passed order_by() calls in query Relation passed orders_by and related_orders_by if exists Model Meta class orders_by Model primary_key column ascending (fallback, used if none of above provided) Order from only one source is applied to each Model (so that you can always overwrite it in a single query). That means that if you provide explicit order_by for a model in a query, the Relation and Model sort orders are skipped. If you provide a Relation one, the Model sort is skipped. Finally, if you provide one for Model the default one by primary_key is skipped.","title":"Default sorting in ormar"},{"location":"queries/filter-and-sort/#querysetproxy-methods_1","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/filter-and-sort/#order_by_1","text":"Works exactly the same as order_by function above but allows you to sort related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"order_by"},{"location":"queries/joins-and-subqueries/","text":"Joins and subqueries To join one table to another, so load also related models you can use following methods. select_related(related: Union[List, str]) -> QuerySet select_all(follow: bool = True) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet Model Model.load() method QuerysetProxy QuerysetProxy.select_related(related: Union[List, str]) method QuerysetProxy.select_all(follow: bool=True) method QuerysetProxy.prefetch_related(related: Union[List, str]) method select_related select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Note If you are coming from django note that ormar select_related differs -> in django you can select_related only singe relation types, while in ormar you can select related across ForeignKey relation, reverse side of ForeignKey (so virtual auto generated keys) and ManyToMany fields (so all relations as of current version). Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 # Django style album = await Album . objects . select_related ( \"tracks\" ) . all () # Python style album = await Album . objects . select_related ( Album . tracks ) . all () # will return album will all columns tracks You can provide a string or a list of strings (or a field/ list of fields) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SchoolClass ( ormar . Model ): class Meta : tablename = \"schoolclasses\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Department ] = ormar . ForeignKey ( Department , nullable = False ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Student ( ormar . Model ): class Meta : tablename = \"students\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) class Teacher ( ormar . Model ): class Meta : tablename = \"teachers\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) 1 2 3 4 5 6 7 8 9 10 # Django style classes = await SchoolClass . objects . select_related ( [ \"teachers__category\" , \"students\" ]) . all () # Python style classes = await SchoolClass . objects . select_related ( [ SchoolClass . teachers . category , SchoolClass . students ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() select_all select_all(follow: bool = False) -> QuerySet By default when you select all() none of the relations are loaded, likewise, when select_related() is used you need to explicitly specify all relations that should be loaded. If you want to include also nested relations this can be cumberstone. That's why select_all() was introduced, so by default load all relations of a model (so kind of opposite as with all() approach). By default adds only directly related models of a parent model (from which the query is run). If follow=True is set it adds also related models of related models. Info To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -> Model B -> Model C -> Model A -> Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually. With sample date like follow: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): database = database metadata = metadata class Address ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"addresses\" id : int = ormar . Integer ( primary_key = True ) street : str = ormar . String ( max_length = 100 , nullable = False ) number : int = ormar . Integer ( nullable = False ) post_code : str = ormar . String ( max_length = 20 , nullable = False ) class Branch ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"branches\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , nullable = False ) address = ormar . ForeignKey ( Address ) class Company ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"companies\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , nullable = False , name = \"company_name\" ) founded : int = ormar . Integer ( nullable = True ) branches = ormar . ManyToMany ( Branch ) To select all Companies with all Branches and Addresses you can simply query: 1 2 3 4 companies = await Company . objects . select_all ( follow = True ) . all () # which is equivalent to: companies = await Company . objects . select_related ( 'branches__address' ) . all () Of course in this case it's quite easy to issue explicit relation names in select_related , but the benefit of select_all() shows when you have multiple relations. If for example Company would have 3 relations and all of those 3 relations have it's own 3 relations you would have to issue 9 relation strings to select_related , select_all() is also resistant to change in names of relations. Note Note that you can chain select_all() with other QuerySet methods like filter , exclude_fields etc. To exclude relations use exclude_fields() call with names of relations (also nested) to exclude. prefetch_related prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 # Django style album = await Album . objects . prefetch_related ( \"tracks\" ) . all () # Python style album = await Album . objects . prefetch_related ( Album . tracks ) . all () # will return album will all columns tracks You can provide a string, or a list of strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SchoolClass ( ormar . Model ): class Meta : tablename = \"schoolclasses\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Department ] = ormar . ForeignKey ( Department , nullable = False ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Student ( ormar . Model ): class Meta : tablename = \"students\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) class Teacher ( ormar . Model ): class Meta : tablename = \"teachers\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) 1 2 3 4 5 6 7 8 9 # Django style classes = await SchoolClass . objects . prefetch_related ( [ \"teachers__category\" , \"students\" ]) . all () # Python style classes = await SchoolClass . objects . prefetch_related ( [ SchoolClass . teachers . category , SchoolClass . students ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() select_related vs prefetch_related Which should you use -> select_related or prefetch_related ? Well, it really depends on your data. The best answer is try yourself and see which one performs faster/better in your system constraints. What to keep in mind: Performance Number of queries : select_related always executes one query against the database, while prefetch_related executes multiple queries. Usually the query (I/O) operation is the slowest one but it does not have to be. Number of rows : Imagine that you have 10 000 object in one table A and each of those objects have 3 children in table B, and subsequently each object in table B has 2 children in table C. Something like this: 1 2 3 4 5 6 7 8 9 10 11 Model C / Model B - Model C / Model A - Model B - Model C \\ \\ \\ Model C \\ Model B - Model C \\ Model C That means that select_related will always return 60 000 rows (10 000 * 3 * 2) later compacted to 10 000 models. How many rows will return prefetch_related ? Well, that depends, if each of models B and C is unique it will return 10 000 rows in first query, 30 000 rows (each of 3 children of A in table B are unique) in second query and 60 000 rows (each of 2 children of model B in table C are unique) in 3rd query. In this case select_related seems like a better choice, not only it will run one query comparing to 3 of prefetch_related but will also return 60 000 rows comparing to 100 000 of prefetch_related (10+30+60k). But what if each Model A has exactly the same 3 models B and each models C has exactly same models C? select_related will still return 60 000 rows, while prefetch_related will return 10 000 for model A, 3 rows for model B and 2 rows for Model C. So in total 10 006 rows. Now depending on the structure of models (i.e. if it has long Text() fields etc.) prefetch_related might be faster despite it needs to perform three separate queries instead of one. Memory ormar is a mini ORM meaning that it does not keep a registry of already loaded models. That means that in select_related example above you will always have 10 000 Models A, 30 000 Models B (even if the unique number of rows in db is 3 - processing of select_related spawns new child models for each parent model). And 60 000 Models C. If the same Model B is shared by rows 1, 10, 100 etc. and you update one of those, the rest of rows that share the same child will not be updated on the spot. If you persist your changes into the database the change will be available only after reload (either each child separately or the whole query again) . That means that select_related will use more memory as each child is instantiated as a new object - obviously using it's own space. Note This might change in future versions if we decide to introduce caching. Warning By default all children (or event the same models loaded 2+ times) are completely independent, distinct python objects, despite that they represent the same row in db. They will evaluate to True when compared, so in example above: 1 2 3 4 5 6 7 8 # will return True if child1 of both rows is the same child db row row1 . child1 == row100 . child1 # same here: model1 = await Model . get ( pk = 1 ) model2 = await Model . get ( pk = 1 ) # same pk = same row in db # will return `True` model1 == model2 but 1 2 3 4 5 # will return False (note that id is a python `builtin` function not ormar one). id ( row1 . child1 ) == ( ro100 . child1 ) # from above - will also return False id ( model1 ) == id ( model2 ) On the contrary - with prefetch_related each unique distinct child model is instantiated only once and the same child models is shared across all parent models. That means that in prefetch_related example above if there are 3 distinct models in table B and 2 in table C, there will be only 5 children nested models shared between all model A instances. That also means that if you update any attribute it will be updated on all parents as they share the same child object. Model methods Each model instance have a set of methods to save , update or load itself. load You can load the ForeignKey related model by calling load() method. load() can be used to refresh the model from the database (if it was changed by some other process). Tip Read more about load() method in models methods QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. select_related Works exactly the same as select_related function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section select_all Works exactly the same as select_all function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section prefetch_related Works exactly the same as prefetch_related function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Joins and subqueries"},{"location":"queries/joins-and-subqueries/#joins-and-subqueries","text":"To join one table to another, so load also related models you can use following methods. select_related(related: Union[List, str]) -> QuerySet select_all(follow: bool = True) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet Model Model.load() method QuerysetProxy QuerysetProxy.select_related(related: Union[List, str]) method QuerysetProxy.select_all(follow: bool=True) method QuerysetProxy.prefetch_related(related: Union[List, str]) method","title":"Joins and subqueries"},{"location":"queries/joins-and-subqueries/#select_related","text":"select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Note If you are coming from django note that ormar select_related differs -> in django you can select_related only singe relation types, while in ormar you can select related across ForeignKey relation, reverse side of ForeignKey (so virtual auto generated keys) and ManyToMany fields (so all relations as of current version). Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 # Django style album = await Album . objects . select_related ( \"tracks\" ) . all () # Python style album = await Album . objects . select_related ( Album . tracks ) . all () # will return album will all columns tracks You can provide a string or a list of strings (or a field/ list of fields) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SchoolClass ( ormar . Model ): class Meta : tablename = \"schoolclasses\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Department ] = ormar . ForeignKey ( Department , nullable = False ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Student ( ormar . Model ): class Meta : tablename = \"students\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) class Teacher ( ormar . Model ): class Meta : tablename = \"teachers\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) 1 2 3 4 5 6 7 8 9 10 # Django style classes = await SchoolClass . objects . select_related ( [ \"teachers__category\" , \"students\" ]) . all () # Python style classes = await SchoolClass . objects . select_related ( [ SchoolClass . teachers . category , SchoolClass . students ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"select_related"},{"location":"queries/joins-and-subqueries/#select_all","text":"select_all(follow: bool = False) -> QuerySet By default when you select all() none of the relations are loaded, likewise, when select_related() is used you need to explicitly specify all relations that should be loaded. If you want to include also nested relations this can be cumberstone. That's why select_all() was introduced, so by default load all relations of a model (so kind of opposite as with all() approach). By default adds only directly related models of a parent model (from which the query is run). If follow=True is set it adds also related models of related models. Info To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept. That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -> Model B -> Model C -> Model A -> Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually. With sample date like follow: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): database = database metadata = metadata class Address ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"addresses\" id : int = ormar . Integer ( primary_key = True ) street : str = ormar . String ( max_length = 100 , nullable = False ) number : int = ormar . Integer ( nullable = False ) post_code : str = ormar . String ( max_length = 20 , nullable = False ) class Branch ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"branches\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , nullable = False ) address = ormar . ForeignKey ( Address ) class Company ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"companies\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 , nullable = False , name = \"company_name\" ) founded : int = ormar . Integer ( nullable = True ) branches = ormar . ManyToMany ( Branch ) To select all Companies with all Branches and Addresses you can simply query: 1 2 3 4 companies = await Company . objects . select_all ( follow = True ) . all () # which is equivalent to: companies = await Company . objects . select_related ( 'branches__address' ) . all () Of course in this case it's quite easy to issue explicit relation names in select_related , but the benefit of select_all() shows when you have multiple relations. If for example Company would have 3 relations and all of those 3 relations have it's own 3 relations you would have to issue 9 relation strings to select_related , select_all() is also resistant to change in names of relations. Note Note that you can chain select_all() with other QuerySet methods like filter , exclude_fields etc. To exclude relations use exclude_fields() call with names of relations (also nested) to exclude.","title":"select_all"},{"location":"queries/joins-and-subqueries/#prefetch_related","text":"prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) class Track ( ormar . Model ): class Meta : tablename = \"tracks\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () play_count : int = ormar . Integer ( nullable = True ) 1 2 3 4 5 6 7 8 # Django style album = await Album . objects . prefetch_related ( \"tracks\" ) . all () # Python style album = await Album . objects . prefetch_related ( Album . tracks ) . all () # will return album will all columns tracks You can provide a string, or a list of strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SchoolClass ( ormar . Model ): class Meta : tablename = \"schoolclasses\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Department ] = ormar . ForeignKey ( Department , nullable = False ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Student ( ormar . Model ): class Meta : tablename = \"students\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) class Teacher ( ormar . Model ): class Meta : tablename = \"teachers\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) schoolclass : Optional [ SchoolClass ] = ormar . ForeignKey ( SchoolClass ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) 1 2 3 4 5 6 7 8 9 # Django style classes = await SchoolClass . objects . prefetch_related ( [ \"teachers__category\" , \"students\" ]) . all () # Python style classes = await SchoolClass . objects . prefetch_related ( [ SchoolClass . teachers . category , SchoolClass . students ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"prefetch_related"},{"location":"queries/joins-and-subqueries/#select_related-vs-prefetch_related","text":"Which should you use -> select_related or prefetch_related ? Well, it really depends on your data. The best answer is try yourself and see which one performs faster/better in your system constraints. What to keep in mind:","title":"select_related vs prefetch_related"},{"location":"queries/joins-and-subqueries/#performance","text":"Number of queries : select_related always executes one query against the database, while prefetch_related executes multiple queries. Usually the query (I/O) operation is the slowest one but it does not have to be. Number of rows : Imagine that you have 10 000 object in one table A and each of those objects have 3 children in table B, and subsequently each object in table B has 2 children in table C. Something like this: 1 2 3 4 5 6 7 8 9 10 11 Model C / Model B - Model C / Model A - Model B - Model C \\ \\ \\ Model C \\ Model B - Model C \\ Model C That means that select_related will always return 60 000 rows (10 000 * 3 * 2) later compacted to 10 000 models. How many rows will return prefetch_related ? Well, that depends, if each of models B and C is unique it will return 10 000 rows in first query, 30 000 rows (each of 3 children of A in table B are unique) in second query and 60 000 rows (each of 2 children of model B in table C are unique) in 3rd query. In this case select_related seems like a better choice, not only it will run one query comparing to 3 of prefetch_related but will also return 60 000 rows comparing to 100 000 of prefetch_related (10+30+60k). But what if each Model A has exactly the same 3 models B and each models C has exactly same models C? select_related will still return 60 000 rows, while prefetch_related will return 10 000 for model A, 3 rows for model B and 2 rows for Model C. So in total 10 006 rows. Now depending on the structure of models (i.e. if it has long Text() fields etc.) prefetch_related might be faster despite it needs to perform three separate queries instead of one.","title":"Performance"},{"location":"queries/joins-and-subqueries/#memory","text":"ormar is a mini ORM meaning that it does not keep a registry of already loaded models. That means that in select_related example above you will always have 10 000 Models A, 30 000 Models B (even if the unique number of rows in db is 3 - processing of select_related spawns new child models for each parent model). And 60 000 Models C. If the same Model B is shared by rows 1, 10, 100 etc. and you update one of those, the rest of rows that share the same child will not be updated on the spot. If you persist your changes into the database the change will be available only after reload (either each child separately or the whole query again) . That means that select_related will use more memory as each child is instantiated as a new object - obviously using it's own space. Note This might change in future versions if we decide to introduce caching. Warning By default all children (or event the same models loaded 2+ times) are completely independent, distinct python objects, despite that they represent the same row in db. They will evaluate to True when compared, so in example above: 1 2 3 4 5 6 7 8 # will return True if child1 of both rows is the same child db row row1 . child1 == row100 . child1 # same here: model1 = await Model . get ( pk = 1 ) model2 = await Model . get ( pk = 1 ) # same pk = same row in db # will return `True` model1 == model2 but 1 2 3 4 5 # will return False (note that id is a python `builtin` function not ormar one). id ( row1 . child1 ) == ( ro100 . child1 ) # from above - will also return False id ( model1 ) == id ( model2 ) On the contrary - with prefetch_related each unique distinct child model is instantiated only once and the same child models is shared across all parent models. That means that in prefetch_related example above if there are 3 distinct models in table B and 2 in table C, there will be only 5 children nested models shared between all model A instances. That also means that if you update any attribute it will be updated on all parents as they share the same child object.","title":"Memory"},{"location":"queries/joins-and-subqueries/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/joins-and-subqueries/#load","text":"You can load the ForeignKey related model by calling load() method. load() can be used to refresh the model from the database (if it was changed by some other process). Tip Read more about load() method in models methods","title":"load"},{"location":"queries/joins-and-subqueries/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/joins-and-subqueries/#select_related_1","text":"Works exactly the same as select_related function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"select_related"},{"location":"queries/joins-and-subqueries/#select_all_1","text":"Works exactly the same as select_all function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"select_all"},{"location":"queries/joins-and-subqueries/#prefetch_related_1","text":"Works exactly the same as prefetch_related function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"prefetch_related"},{"location":"queries/pagination-and-rows-number/","text":"Pagination and rows number Following methods allow you to paginate and limit number of rows in queries. paginate(page: int) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet get() -> Model first() -> Model QuerysetProxy QuerysetProxy.paginate(page: int) method QuerysetProxy.limit(limit_count: int) method QuerysetProxy.offset(offset: int) method paginate paginate(page: int, page_size: int = 20) -> QuerySet Combines the offset and limit methods based on page number and size 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 tracks = await Track . objects . paginate ( 3 ) . all () # will return 20 tracks starting at row 41 # (with default page size of 20) Note that paginate(2) is equivalent to offset(20).limit(20) limit limit(limit_count: int, limit_raw_sql: bool = None) -> QuerySet You can limit the results to desired number of parent models. To limit the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 tracks = await Track . objects . limit ( 1 ) . all () # will return just one Track Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() offset offset(offset: int, limit_raw_sql: bool = None) -> QuerySet You can also offset the results by desired number of main models. To offset the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 tracks = await Track . objects . offset ( 1 ) . limit ( 1 ) . all () # will return just one Track, but this time the second one Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() get get(**kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria is set it will return the last row in db sorted by pk. (The criteria cannot be set also with filter/exclude). Tip To read more about get visit read/get first first() -> Model Gets the first row from the db ordered by primary key column ascending. Tip To read more about first visit read/first QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. paginate Works exactly the same as paginate function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section limit Works exactly the same as limit function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section offset Works exactly the same as offset function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Pagination and rows number"},{"location":"queries/pagination-and-rows-number/#pagination-and-rows-number","text":"Following methods allow you to paginate and limit number of rows in queries. paginate(page: int) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet get() -> Model first() -> Model QuerysetProxy QuerysetProxy.paginate(page: int) method QuerysetProxy.limit(limit_count: int) method QuerysetProxy.offset(offset: int) method","title":"Pagination and rows number"},{"location":"queries/pagination-and-rows-number/#paginate","text":"paginate(page: int, page_size: int = 20) -> QuerySet Combines the offset and limit methods based on page number and size 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 tracks = await Track . objects . paginate ( 3 ) . all () # will return 20 tracks starting at row 41 # (with default page size of 20) Note that paginate(2) is equivalent to offset(20).limit(20)","title":"paginate"},{"location":"queries/pagination-and-rows-number/#limit","text":"limit(limit_count: int, limit_raw_sql: bool = None) -> QuerySet You can limit the results to desired number of parent models. To limit the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 tracks = await Track . objects . limit ( 1 ) . all () # will return just one Track Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"limit"},{"location":"queries/pagination-and-rows-number/#offset","text":"offset(offset: int, limit_raw_sql: bool = None) -> QuerySet You can also offset the results by desired number of main models. To offset the actual number of database query rows instead of number of main models use the limit_raw_sql parameter flag, and set it to True . 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 tracks = await Track . objects . offset ( 1 ) . limit ( 1 ) . all () # will return just one Track, but this time the second one Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"offset"},{"location":"queries/pagination-and-rows-number/#get","text":"get(**kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria is set it will return the last row in db sorted by pk. (The criteria cannot be set also with filter/exclude). Tip To read more about get visit read/get","title":"get"},{"location":"queries/pagination-and-rows-number/#first","text":"first() -> Model Gets the first row from the db ordered by primary key column ascending. Tip To read more about first visit read/first","title":"first"},{"location":"queries/pagination-and-rows-number/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/pagination-and-rows-number/#paginate_1","text":"Works exactly the same as paginate function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"paginate"},{"location":"queries/pagination-and-rows-number/#limit_1","text":"Works exactly the same as limit function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"limit"},{"location":"queries/pagination-and-rows-number/#offset_1","text":"Works exactly the same as offset function above but allows you to paginate related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"offset"},{"location":"queries/raw-data/","text":"Return raw data Following methods allow you to execute a query but instead of returning ormar models those will return list of dicts or tuples. values(fields = None, exclude_through = False) -> List[Dict] values_list(fields = None, exclude_through = False, flatten = False) -> List QuerysetProxy QuerysetProxy.values(fields = None, exclude_through = False) method QuerysetProxy.values_list(fields = None, exclude_through= False, flatten = False) method Danger Note that values and values_list skips parsing the result to ormar models so skips also the validation of the result! Warning Note that each entry in a result list is one to one reflection of a query result row. Since rows are not parsed if you have one-to-many or many-to-many relation expect duplicated columns values in result entries if one parent row have multiple related rows. values values(fields: Union[List, str, Set, Dict] = None, exclude_through: bool = False) -> List[Dict] Return a list of dictionaries representing the values of the columns coming from the database. You can select a subset of fields with fields parameter, that accepts the same set of parameters as fields() method. Note that passing fields to values(fields) is actually a shortcut for calling fields(fields).values() . Tip To read more about what you can pass to fields and how to select nested models fields read selecting columns docs You can limit the number of rows by providing conditions in filter() and exclude() , but note that even if only one row (or no rows!) match your criteria you will return a list in response. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # declared models class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) sort_order : int = ormar . Integer ( nullable = True ) class Post ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) category : Optional [ Category ] = ormar . ForeignKey ( Category ) # sample data news = await Category ( name = \"News\" , sort_order = 0 ) . save () await Post ( name = \"Ormar strikes again!\" , category = news ) . save () await Post ( name = \"Why don't you use ormar yet?\" , category = news ) . save () await Post ( name = \"Check this out, ormar now for free\" , category = news ) . save () Access Post models: 1 2 3 4 5 6 posts = await Post . objects . values () assert posts == [ { \"id\" : 1 , \"name\" : \"Ormar strikes again!\" , \"category\" : 1 }, { \"id\" : 2 , \"name\" : \"Why don't you use ormar yet?\" , \"category\" : 1 }, { \"id\" : 3 , \"name\" : \"Check this out, ormar now for free\" , \"category\" : 1 }, ] To select also related models use select_related or prefetch_related . Note how nested models columns will be prefixed with full relation path coming from the main model (the one used in a query). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # declare models class User ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Role ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) users : List [ User ] = ormar . ManyToMany ( User ) # sample data creator = await User ( name = \"Anonymous\" ) . save () admin = await Role ( name = \"admin\" ) . save () editor = await Role ( name = \"editor\" ) . save () await creator . roles . add ( admin ) await creator . roles . add ( editor ) Select user with roles 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 user = await User . objects . select_related ( \"roles\" ) . values () # note nested prefixes: roleuser and roles assert user == [ { \"id\" : 1 , \"name\" : \"Anonymous\" , \"roleuser__id\" : 1 , \"roleuser__role\" : 1 , \"roleuser__user\" : 1 , \"roles__id\" : 1 , \"roles__name\" : \"admin\" , }, { \"id\" : 1 , \"name\" : \"Anonymous\" , \"roleuser__id\" : 2 , \"roleuser__role\" : 2 , \"roleuser__user\" : 1 , \"roles__id\" : 2 , \"roles__name\" : \"editor\" , }, ] Note Note how role to users relation is a ManyToMany relation so by default you also get through model columns. Combine select related and fields to select only 3 fields. Note that we also exclude through model as by definition every model included in a join but without any reference in fields is assumed to be selected in full (all fields included). Note Note that in contrary to other queryset methods here you can exclude the in-between models but keep the end columns, which does not make sense when parsing the raw data into models. So in relation category -> category_x_post -> post -> user you can exclude category_x_post and post models but can keep the user one. (in ormar model context that is not possible as if you would exclude through and post model there would be no way to reach user model from category model). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 user = ( await Role . objects . select_related ( \"users__categories\" ) . filter ( name = \"admin\" ) . fields ({ \"name\" : ... , \"users\" : { \"name\" : ... , \"categories\" : { \"name\" }}}) . exclude_fields ( \"roleuser\" ) . values () ) assert user == [ { \"name\" : \"admin\" , \"users__name\" : \"Anonymous\" , \"users__categories__name\" : \"News\" , } ] If you have multiple ManyToMany models in your query you would have to exclude each through model manually. To avoid this burden ormar provides you with exclude_through=False parameter. If you set this flag to True all through models will be fully excluded . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # equivalent to query above, note lack of exclude_fields call user = ( await Role . objects . select_related ( \"users__categories\" ) . filter ( name = \"admin\" ) . fields ({ \"name\" : ... , \"users\" : { \"name\" : ... , \"categories\" : { \"name\" }}}) . values ( exclude_through = True ) ) assert user == [ { \"name\" : \"admin\" , \"users__name\" : \"Anonymous\" , \"users__categories__name\" : \"News\" , } ] values_list values_list(fields: Union[List, str, Set, Dict] = None, flatten: bool = False, exclude_through: bool = False) -> List Return a list of tuples representing the values of the columns coming from the database. You can select a subset of fields with fields parameter, that accepts the same set of parameters as fields() method. Note that passing fields to values_list(fields) is actually a shortcut for calling fields(fields).values_list() . Tip To read more about what you can pass to fields and how to select nested models fields read selecting columns docs If you select only one column/field you can pass flatten=True which will return you a list of values instead of list of one element tuples. Warning Setting flatten=True if more than one (or none which means all) fields are selected will raise QueryDefinitionError exception. You can limit the number of rows by providing conditions in filter() and exclude() , but note that even if only one row (or no rows!) match your criteria you will return a list in response. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # declared models class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) sort_order : int = ormar . Integer ( nullable = True ) class Post ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) category : Optional [ Category ] = ormar . ForeignKey ( Category ) # sample data news = await Category ( name = \"News\" , sort_order = 0 ) . save () await Post ( name = \"Ormar strikes again!\" , category = news ) . save () await Post ( name = \"Why don't you use ormar yet?\" , category = news ) . save () await Post ( name = \"Check this out, ormar now for free\" , category = news ) . save () Access Post models: 1 2 3 4 5 6 7 posts = await Post . objects . values_list () # note how columns refer to id, name and category (fk) assert posts == [ ( 1 , \"Ormar strikes again!\" , 1 ), ( 2 , \"Why don't you use ormar yet?\" , 1 ), ( 3 , \"Check this out, ormar now for free\" , 1 ), ] To select also related models use select_related or prefetch_related . Let's complicate the relation and modify the previously mentioned Category model to refer to User model. 1 2 3 4 5 6 7 8 9 class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) sort_order : int = ormar . Integer ( nullable = True ) # new column below created_by : Optional [ User ] = ormar . ForeignKey ( User , related_name = \"categories\" ) Now create the sample data with link to user. 1 2 3 4 5 6 creator = await User ( name = \"Anonymous\" ) . save () admin = await Role ( name = \"admin\" ) . save () editor = await Role ( name = \"editor\" ) . save () await creator . roles . add ( admin ) await creator . roles . add ( editor ) news = await Category ( name = \"News\" , sort_order = 0 , created_by = creator ) . save () Combine select related and fields to select only 3 fields. Note that we also exclude through model as by definition every model included in a join but without any reference in fields is assumed to be selected in full (all fields included). Note Note that in contrary to other queryset methods here you can exclude the in-between models but keep the end columns, which does not make sense when parsing the raw data into models. So in relation category -> category_x_post -> post -> user you can exclude category_x_post and post models but can keep the user one. (in ormar model context that is not possible as if you would exclude through and post model there would be no way to reach user model from category model). 1 2 3 4 5 6 7 8 user = ( await Role . objects . select_related ( \"users__categories\" ) . filter ( name = \"admin\" ) . fields ({ \"name\" : ... , \"users\" : { \"name\" : ... , \"categories\" : { \"name\" }}}) . exclude_fields ( \"roleuser\" ) . values_list () ) assert user == [( \"admin\" , \"Anonymous\" , \"News\" )] If you have multiple ManyToMany models in your query you would have to exclude each through model manually. To avoid this burden ormar provides you with exclude_through=False parameter. If you set this flag to True all through models will be fully excluded . 1 2 3 4 5 6 7 8 # equivalent to query above, note lack of exclude_fields call user = ( await Role . objects . select_related ( \"users__categories\" ) . filter ( name = \"admin\" ) . fields ({ \"name\" : ... , \"users\" : { \"name\" : ... , \"categories\" : { \"name\" }}}) . values_list ( exclude_through = True ) ) assert user == [( \"admin\" , \"Anonymous\" , \"News\" )] Use flatten to get list of values. 1 2 3 4 5 6 # using flatten with more than one field will raise exception! await Role . objects . fields ({ \"name\" , \"id\" }) . values_list ( flatten = True ) # proper usage roles = await Role . objects . fields ( \"name\" ) . values_list ( flatten = True ) assert roles == [ \"admin\" , \"editor\" ] QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. Warning Because using values and values_list skips parsing of the models and validation, in contrast to all other read methods in querysetproxy those 2 does not clear currently loaded related models and does not overwrite the currently loaded models with result of own call! values Works exactly the same as values function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section values_list Works exactly the same as values_list function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"Return raw data"},{"location":"queries/raw-data/#return-raw-data","text":"Following methods allow you to execute a query but instead of returning ormar models those will return list of dicts or tuples. values(fields = None, exclude_through = False) -> List[Dict] values_list(fields = None, exclude_through = False, flatten = False) -> List QuerysetProxy QuerysetProxy.values(fields = None, exclude_through = False) method QuerysetProxy.values_list(fields = None, exclude_through= False, flatten = False) method Danger Note that values and values_list skips parsing the result to ormar models so skips also the validation of the result! Warning Note that each entry in a result list is one to one reflection of a query result row. Since rows are not parsed if you have one-to-many or many-to-many relation expect duplicated columns values in result entries if one parent row have multiple related rows.","title":"Return raw data"},{"location":"queries/raw-data/#values","text":"values(fields: Union[List, str, Set, Dict] = None, exclude_through: bool = False) -> List[Dict] Return a list of dictionaries representing the values of the columns coming from the database. You can select a subset of fields with fields parameter, that accepts the same set of parameters as fields() method. Note that passing fields to values(fields) is actually a shortcut for calling fields(fields).values() . Tip To read more about what you can pass to fields and how to select nested models fields read selecting columns docs You can limit the number of rows by providing conditions in filter() and exclude() , but note that even if only one row (or no rows!) match your criteria you will return a list in response. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # declared models class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) sort_order : int = ormar . Integer ( nullable = True ) class Post ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) category : Optional [ Category ] = ormar . ForeignKey ( Category ) # sample data news = await Category ( name = \"News\" , sort_order = 0 ) . save () await Post ( name = \"Ormar strikes again!\" , category = news ) . save () await Post ( name = \"Why don't you use ormar yet?\" , category = news ) . save () await Post ( name = \"Check this out, ormar now for free\" , category = news ) . save () Access Post models: 1 2 3 4 5 6 posts = await Post . objects . values () assert posts == [ { \"id\" : 1 , \"name\" : \"Ormar strikes again!\" , \"category\" : 1 }, { \"id\" : 2 , \"name\" : \"Why don't you use ormar yet?\" , \"category\" : 1 }, { \"id\" : 3 , \"name\" : \"Check this out, ormar now for free\" , \"category\" : 1 }, ] To select also related models use select_related or prefetch_related . Note how nested models columns will be prefixed with full relation path coming from the main model (the one used in a query). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # declare models class User ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Role ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) users : List [ User ] = ormar . ManyToMany ( User ) # sample data creator = await User ( name = \"Anonymous\" ) . save () admin = await Role ( name = \"admin\" ) . save () editor = await Role ( name = \"editor\" ) . save () await creator . roles . add ( admin ) await creator . roles . add ( editor ) Select user with roles 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 user = await User . objects . select_related ( \"roles\" ) . values () # note nested prefixes: roleuser and roles assert user == [ { \"id\" : 1 , \"name\" : \"Anonymous\" , \"roleuser__id\" : 1 , \"roleuser__role\" : 1 , \"roleuser__user\" : 1 , \"roles__id\" : 1 , \"roles__name\" : \"admin\" , }, { \"id\" : 1 , \"name\" : \"Anonymous\" , \"roleuser__id\" : 2 , \"roleuser__role\" : 2 , \"roleuser__user\" : 1 , \"roles__id\" : 2 , \"roles__name\" : \"editor\" , }, ] Note Note how role to users relation is a ManyToMany relation so by default you also get through model columns. Combine select related and fields to select only 3 fields. Note that we also exclude through model as by definition every model included in a join but without any reference in fields is assumed to be selected in full (all fields included). Note Note that in contrary to other queryset methods here you can exclude the in-between models but keep the end columns, which does not make sense when parsing the raw data into models. So in relation category -> category_x_post -> post -> user you can exclude category_x_post and post models but can keep the user one. (in ormar model context that is not possible as if you would exclude through and post model there would be no way to reach user model from category model). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 user = ( await Role . objects . select_related ( \"users__categories\" ) . filter ( name = \"admin\" ) . fields ({ \"name\" : ... , \"users\" : { \"name\" : ... , \"categories\" : { \"name\" }}}) . exclude_fields ( \"roleuser\" ) . values () ) assert user == [ { \"name\" : \"admin\" , \"users__name\" : \"Anonymous\" , \"users__categories__name\" : \"News\" , } ] If you have multiple ManyToMany models in your query you would have to exclude each through model manually. To avoid this burden ormar provides you with exclude_through=False parameter. If you set this flag to True all through models will be fully excluded . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # equivalent to query above, note lack of exclude_fields call user = ( await Role . objects . select_related ( \"users__categories\" ) . filter ( name = \"admin\" ) . fields ({ \"name\" : ... , \"users\" : { \"name\" : ... , \"categories\" : { \"name\" }}}) . values ( exclude_through = True ) ) assert user == [ { \"name\" : \"admin\" , \"users__name\" : \"Anonymous\" , \"users__categories__name\" : \"News\" , } ]","title":"values"},{"location":"queries/raw-data/#values_list","text":"values_list(fields: Union[List, str, Set, Dict] = None, flatten: bool = False, exclude_through: bool = False) -> List Return a list of tuples representing the values of the columns coming from the database. You can select a subset of fields with fields parameter, that accepts the same set of parameters as fields() method. Note that passing fields to values_list(fields) is actually a shortcut for calling fields(fields).values_list() . Tip To read more about what you can pass to fields and how to select nested models fields read selecting columns docs If you select only one column/field you can pass flatten=True which will return you a list of values instead of list of one element tuples. Warning Setting flatten=True if more than one (or none which means all) fields are selected will raise QueryDefinitionError exception. You can limit the number of rows by providing conditions in filter() and exclude() , but note that even if only one row (or no rows!) match your criteria you will return a list in response. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # declared models class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) sort_order : int = ormar . Integer ( nullable = True ) class Post ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 200 ) category : Optional [ Category ] = ormar . ForeignKey ( Category ) # sample data news = await Category ( name = \"News\" , sort_order = 0 ) . save () await Post ( name = \"Ormar strikes again!\" , category = news ) . save () await Post ( name = \"Why don't you use ormar yet?\" , category = news ) . save () await Post ( name = \"Check this out, ormar now for free\" , category = news ) . save () Access Post models: 1 2 3 4 5 6 7 posts = await Post . objects . values_list () # note how columns refer to id, name and category (fk) assert posts == [ ( 1 , \"Ormar strikes again!\" , 1 ), ( 2 , \"Why don't you use ormar yet?\" , 1 ), ( 3 , \"Check this out, ormar now for free\" , 1 ), ] To select also related models use select_related or prefetch_related . Let's complicate the relation and modify the previously mentioned Category model to refer to User model. 1 2 3 4 5 6 7 8 9 class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) sort_order : int = ormar . Integer ( nullable = True ) # new column below created_by : Optional [ User ] = ormar . ForeignKey ( User , related_name = \"categories\" ) Now create the sample data with link to user. 1 2 3 4 5 6 creator = await User ( name = \"Anonymous\" ) . save () admin = await Role ( name = \"admin\" ) . save () editor = await Role ( name = \"editor\" ) . save () await creator . roles . add ( admin ) await creator . roles . add ( editor ) news = await Category ( name = \"News\" , sort_order = 0 , created_by = creator ) . save () Combine select related and fields to select only 3 fields. Note that we also exclude through model as by definition every model included in a join but without any reference in fields is assumed to be selected in full (all fields included). Note Note that in contrary to other queryset methods here you can exclude the in-between models but keep the end columns, which does not make sense when parsing the raw data into models. So in relation category -> category_x_post -> post -> user you can exclude category_x_post and post models but can keep the user one. (in ormar model context that is not possible as if you would exclude through and post model there would be no way to reach user model from category model). 1 2 3 4 5 6 7 8 user = ( await Role . objects . select_related ( \"users__categories\" ) . filter ( name = \"admin\" ) . fields ({ \"name\" : ... , \"users\" : { \"name\" : ... , \"categories\" : { \"name\" }}}) . exclude_fields ( \"roleuser\" ) . values_list () ) assert user == [( \"admin\" , \"Anonymous\" , \"News\" )] If you have multiple ManyToMany models in your query you would have to exclude each through model manually. To avoid this burden ormar provides you with exclude_through=False parameter. If you set this flag to True all through models will be fully excluded . 1 2 3 4 5 6 7 8 # equivalent to query above, note lack of exclude_fields call user = ( await Role . objects . select_related ( \"users__categories\" ) . filter ( name = \"admin\" ) . fields ({ \"name\" : ... , \"users\" : { \"name\" : ... , \"categories\" : { \"name\" }}}) . values_list ( exclude_through = True ) ) assert user == [( \"admin\" , \"Anonymous\" , \"News\" )] Use flatten to get list of values. 1 2 3 4 5 6 # using flatten with more than one field will raise exception! await Role . objects . fields ({ \"name\" , \"id\" }) . values_list ( flatten = True ) # proper usage roles = await Role . objects . fields ( \"name\" ) . values_list ( flatten = True ) assert roles == [ \"admin\" , \"editor\" ]","title":"values_list"},{"location":"queries/raw-data/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. Warning Because using values and values_list skips parsing of the models and validation, in contrast to all other read methods in querysetproxy those 2 does not clear currently loaded related models and does not overwrite the currently loaded models with result of own call!","title":"QuerysetProxy methods"},{"location":"queries/raw-data/#values_1","text":"Works exactly the same as values function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"values"},{"location":"queries/raw-data/#values_list_1","text":"Works exactly the same as values_list function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit [querysetproxy][querysetproxy] section","title":"values_list"},{"location":"queries/read/","text":"Read data from database Following methods allow you to load data from the database. get(*args, **kwargs) -> Model get_or_create(*args, **kwargs) -> Model first(*args, **kwargs) -> Model all(*args, **kwargs) -> List[Optional[Model]] Model Model.load() method QuerysetProxy QuerysetProxy.get(*args, **kwargs) method QuerysetProxy.get_or_create(*args, **kwargs) method QuerysetProxy.first(*args, **kwargs) method QuerysetProxy.all(*args, **kwargs) method get get(*args, **kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk column. Passing a criteria is actually calling filter( args, *kwargs) method described below. 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 4 5 6 track = await Track . objects . get ( name = 'The Bird' ) # note that above is equivalent to await Track.objects.filter(name='The Bird').get() track2 = track = await Track . objects . get () track == track2 # True since it's the only row in db in our example # and get without arguments return first row by pk column desc Warning If no row meets the criteria NoMatch exception is raised. If there are multiple rows meeting the criteria the MultipleMatches exception is raised. get_or_none get_or_none(*args, **kwargs) -> Model Exact equivalent of get described above but instead of raising the exception returns None if no db record matching the criteria is found. get_or_create get_or_create(*args, **kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being an equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement first first(*args, **kwargs) -> Model Gets the first row from the db ordered by primary key column ascending. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 await Album . objects . create ( name = 'The Cat' ) await Album . objects . create ( name = 'The Dog' ) album = await Album . objects . first () # first row by primary_key column asc assert album . name == 'The Cat' all all(*args, **kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(*args, **kwargs).all() . If there are no rows meeting the criteria an empty list is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 4 5 6 tracks = await Track . objects . select_related ( \"album\" ) . all ( album__title = 'Sample' ) # will return a list of all Tracks for album Sample # for more on joins visit joining and subqueries section tracks = await Track . objects . all () # will return a list of all Tracks in database Model methods Each model instance have a set of methods to save , update or load itself. load You can load the ForeignKey related model by calling load() method. load() can be used to refresh the model from the database (if it was changed by some other process). Tip Read more about load() method in models methods QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. get Works exactly the same as get function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section get_or_none Exact equivalent of get described above but instead of raising the exception returns None if no db record matching the criteria is found. Tip To read more about QuerysetProxy visit querysetproxy section get_or_create Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section first Works exactly the same as first function above but allows you to query related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section all Works exactly the same as all function above but allows you to query related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Read data from database"},{"location":"queries/read/#read-data-from-database","text":"Following methods allow you to load data from the database. get(*args, **kwargs) -> Model get_or_create(*args, **kwargs) -> Model first(*args, **kwargs) -> Model all(*args, **kwargs) -> List[Optional[Model]] Model Model.load() method QuerysetProxy QuerysetProxy.get(*args, **kwargs) method QuerysetProxy.get_or_create(*args, **kwargs) method QuerysetProxy.first(*args, **kwargs) method QuerysetProxy.all(*args, **kwargs) method","title":"Read data from database"},{"location":"queries/read/#get","text":"get(*args, **kwargs) -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the last row in db sorted by pk column. Passing a criteria is actually calling filter( args, *kwargs) method described below. 1 2 3 4 5 6 7 8 9 10 class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) name : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 4 5 6 track = await Track . objects . get ( name = 'The Bird' ) # note that above is equivalent to await Track.objects.filter(name='The Bird').get() track2 = track = await Track . objects . get () track == track2 # True since it's the only row in db in our example # and get without arguments return first row by pk column desc Warning If no row meets the criteria NoMatch exception is raised. If there are multiple rows meeting the criteria the MultipleMatches exception is raised.","title":"get"},{"location":"queries/read/#get_or_none","text":"get_or_none(*args, **kwargs) -> Model Exact equivalent of get described above but instead of raising the exception returns None if no db record matching the criteria is found.","title":"get_or_none"},{"location":"queries/read/#get_or_create","text":"get_or_create(*args, **kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being an equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"get_or_create"},{"location":"queries/read/#first","text":"first(*args, **kwargs) -> Model Gets the first row from the db ordered by primary key column ascending. 1 2 3 4 5 6 7 8 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) 1 2 3 4 5 await Album . objects . create ( name = 'The Cat' ) await Album . objects . create ( name = 'The Dog' ) album = await Album . objects . first () # first row by primary_key column asc assert album . name == 'The Cat'","title":"first"},{"location":"queries/read/#all","text":"all(*args, **kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(*args, **kwargs).all() . If there are no rows meeting the criteria an empty list is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () 1 2 3 4 5 6 tracks = await Track . objects . select_related ( \"album\" ) . all ( album__title = 'Sample' ) # will return a list of all Tracks for album Sample # for more on joins visit joining and subqueries section tracks = await Track . objects . all () # will return a list of all Tracks in database","title":"all"},{"location":"queries/read/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/read/#load","text":"You can load the ForeignKey related model by calling load() method. load() can be used to refresh the model from the database (if it was changed by some other process). Tip Read more about load() method in models methods","title":"load"},{"location":"queries/read/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/read/#get_1","text":"Works exactly the same as get function above but allows you to fetch related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get"},{"location":"queries/read/#get_or_none_1","text":"Exact equivalent of get described above but instead of raising the exception returns None if no db record matching the criteria is found. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get_or_none"},{"location":"queries/read/#get_or_create_1","text":"Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"get_or_create"},{"location":"queries/read/#first_1","text":"Works exactly the same as first function above but allows you to query related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"first"},{"location":"queries/read/#all_1","text":"Works exactly the same as all function above but allows you to query related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"all"},{"location":"queries/select-columns/","text":"Selecting subset of columns To select only chosen columns of your model you can use following functions. fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet QuerysetProxy QuerysetProxy.fields(columns: Union[List, str, set, dict]) method QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict]) method fields fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Given a sample data like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . 1 2 3 4 5 6 7 8 9 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields implies a list of all fields for those nested models. 1 2 3 4 5 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ( 'id' ) . fields ( [ 'name' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. You cannot exclude mandatory model columns - manufacturer__name in this example. 1 2 3 await Car . objects . select_related ( 'manufacturer' ) . fields ( [ 'id' , 'name' , 'manufacturer__founded' ]) . all () # will raise pydantic ValidationError as company.name is required Tip Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Below you can see examples that are equivalent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1. like in example above await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () # 2. to mark a field as required use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' : ... } }) . all () # 3. to include whole nested model use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : ... }) . all () # 4. to specify fields at last nesting level you can also use set - equivalent to 2. above await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' } }) . all () # 5. of course set can have multiple fields await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' , 'founded' } }) . all () # 6. you can include all nested fields but it will be equivalent of 3. above which is shorter await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'id' , 'name' , 'founded' } }) . all () Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() exclude_fields exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Below you can find few simple examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) # select manufacturer but only name - to include related models use notation {model_name}__{column} all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' , 'company__founded' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None # fields() can be called several times, building up the columns to select # models selected in select_related but with no columns in fields list implies all fields all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( 'year' ) . exclude_fields ( [ 'gear' , 'gearbox_type' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 # cannot exclude mandatory model columns - company__name in this example - note usage of dict/set this time await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ([{ 'company' : { 'name' }}]) . all () # will raise pydantic ValidationError as company.name is required Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Tip Pk column cannot be excluded - it's always auto added even if explicitly excluded. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. fields Works exactly the same as fields function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section exclude_fields Works exactly the same as exclude_fields function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Selecting subset of columns"},{"location":"queries/select-columns/#selecting-subset-of-columns","text":"To select only chosen columns of your model you can use following functions. fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet QuerysetProxy QuerysetProxy.fields(columns: Union[List, str, set, dict]) method QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict]) method","title":"Selecting subset of columns"},{"location":"queries/select-columns/#fields","text":"fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Given a sample data like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . 1 2 3 4 5 6 7 8 9 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields implies a list of all fields for those nested models. 1 2 3 4 5 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ( 'id' ) . fields ( [ 'name' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. You cannot exclude mandatory model columns - manufacturer__name in this example. 1 2 3 await Car . objects . select_related ( 'manufacturer' ) . fields ( [ 'id' , 'name' , 'manufacturer__founded' ]) . all () # will raise pydantic ValidationError as company.name is required Tip Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Below you can see examples that are equivalent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1. like in example above await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () # 2. to mark a field as required use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' : ... } }) . all () # 3. to include whole nested model use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : ... }) . all () # 4. to specify fields at last nesting level you can also use set - equivalent to 2. above await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' } }) . all () # 5. of course set can have multiple fields await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' , 'founded' } }) . all () # 6. you can include all nested fields but it will be equivalent of 3. above which is shorter await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'id' , 'name' , 'founded' } }) . all () Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"fields"},{"location":"queries/select-columns/#exclude_fields","text":"exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Below you can find few simple examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) # select manufacturer but only name - to include related models use notation {model_name}__{column} all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' , 'company__founded' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None # fields() can be called several times, building up the columns to select # models selected in select_related but with no columns in fields list implies all fields all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( 'year' ) . exclude_fields ( [ 'gear' , 'gearbox_type' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 # cannot exclude mandatory model columns - company__name in this example - note usage of dict/set this time await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ([{ 'company' : { 'name' }}]) . all () # will raise pydantic ValidationError as company.name is required Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Tip Pk column cannot be excluded - it's always auto added even if explicitly excluded. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"exclude_fields"},{"location":"queries/select-columns/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/select-columns/#fields_1","text":"Works exactly the same as fields function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"fields"},{"location":"queries/select-columns/#exclude_fields_1","text":"Works exactly the same as exclude_fields function above but allows you to select columns from related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"exclude_fields"},{"location":"queries/update/","text":"Update data in database Following methods and functions allow updating existing data in the database. update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_update(objects: List[Model], columns: List[str] = None) -> None Model Model.update() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.update_or_create(**kwargs) method update update(each: bool = False, **kwargs) -> int QuerySet level update is used to update multiple records with the same value at once. You either have to filter the QuerySet first or provide a each=True flag to update whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows updated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . update ( each = True , genre = 'Fiction' ) all_books = await Book . objects . filter ( genre = 'Fiction' ) . all () assert len ( all_books ) == 3 Warning Queryset needs to be filtered before updating to prevent accidental overwrite. To update whole database table each=True needs to be provided as a safety switch update_or_create update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement bulk_update bulk_update(objects: List[\"Model\"], columns: List[str] = None) -> None Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. 1 2 3 4 5 6 7 8 9 10 11 # continuing the example from bulk_create # update objects for todo in todoes : todo . completed = False # perform update of all objects at once # objects need to have pk column set, otherwise exception is raised await ToDo . objects . bulk_update ( todoes ) completed = await ToDo . objects . filter ( completed = False ) . all () assert len ( completed ) == 3 Model methods Each model instance have a set of methods to save , update or load itself. update You can update models by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. Tip Read more about update() method in models-update upsert It's a proxy to either save() or update(**kwargs) methods of a Model. If the pk is set the update() method will be called. Tip Read more about upsert() method in models-upsert save_related Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. Tip Read more about save_related() method in models-save-related QuerysetProxy methods When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. update_or_create Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"Update data in database"},{"location":"queries/update/#update-data-in-database","text":"Following methods and functions allow updating existing data in the database. update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_update(objects: List[Model], columns: List[str] = None) -> None Model Model.update() method Model.upsert() method Model.save_related() method QuerysetProxy QuerysetProxy.update_or_create(**kwargs) method","title":"Update data in database"},{"location":"queries/update/#update","text":"update(each: bool = False, **kwargs) -> int QuerySet level update is used to update multiple records with the same value at once. You either have to filter the QuerySet first or provide a each=True flag to update whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows updated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . update ( each = True , genre = 'Fiction' ) all_books = await Book . objects . filter ( genre = 'Fiction' ) . all () assert len ( all_books ) == 3 Warning Queryset needs to be filtered before updating to prevent accidental overwrite. To update whole database table each=True needs to be provided as a safety switch","title":"update"},{"location":"queries/update/#update_or_create","text":"update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"update_or_create"},{"location":"queries/update/#bulk_update","text":"bulk_update(objects: List[\"Model\"], columns: List[str] = None) -> None Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. 1 2 3 4 5 6 7 8 9 10 11 # continuing the example from bulk_create # update objects for todo in todoes : todo . completed = False # perform update of all objects at once # objects need to have pk column set, otherwise exception is raised await ToDo . objects . bulk_update ( todoes ) completed = await ToDo . objects . filter ( completed = False ) . all () assert len ( completed ) == 3","title":"bulk_update"},{"location":"queries/update/#model-methods","text":"Each model instance have a set of methods to save , update or load itself.","title":"Model methods"},{"location":"queries/update/#update_1","text":"You can update models by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. Tip Read more about update() method in models-update","title":"update"},{"location":"queries/update/#upsert","text":"It's a proxy to either save() or update(**kwargs) methods of a Model. If the pk is set the update() method will be called. Tip Read more about upsert() method in models-upsert","title":"upsert"},{"location":"queries/update/#save_related","text":"Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. Tip Read more about save_related() method in models-save-related","title":"save_related"},{"location":"queries/update/#querysetproxy-methods","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.","title":"QuerysetProxy methods"},{"location":"queries/update/#update_or_create_1","text":"Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation. Tip To read more about QuerysetProxy visit querysetproxy section","title":"update_or_create"},{"location":"relations/","text":"Relations Currently ormar supports two types of relations: One-to-many (and many-to-one) with ForeignKey field Many-to-many with ManyToMany field Below you can find a very basic examples of definitions for each of those relations. To read more about methods, possibilities, definition etc. please read the subsequent section of the documentation. ForeignKey To define many-to-one relation use ForeignKey field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) Tip To read more about one-to-many relations visit foreign-keys section Reverse ForeignKey The definition of one-to-many relation also uses ForeignKey , and it's registered for you automatically. So in relation ato example above. 1 2 3 4 5 6 7 8 9 10 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # there is a virtual field here like follows courses : Optional [ List [ Course ]] = ormar . ForeignKey ( Course , virtual = True ) # note that you DO NOT define it yourself, ormar does it for you. Tip To read more about many-to-one relations (i.e changing the name of generated field) visit foreign-keys section Tip Reverse ForeignKey allows you to query the related models with queryset-proxy . It allows you to use await department.courses.all() to fetch data related only to specific department etc. ManyToMany To define many-to-many relation use ManyToMany field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ List [ Category ]] = ormar . ManyToMany ( Category ) Tip To read more about many-to-many relations visit many-to-many section Tip ManyToMany allows you to query the related models with queryset-proxy . It allows you to use await post.categories.all() but also await category.posts.all() to fetch data related only to specific post, category etc. Through fields As part of the ManyToMany relation you can define a through model, that can contain additional fields that you can use to filter, order etc. Fields defined like this are exposed on the reverse side of the current query for m2m models. So if you query from model A to model B , only model B has through field exposed. Which kind of make sense, since it's a one through model/field for each of related models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 40 ) # you can specify additional fields on through model class PostCategory ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts_x_categories\" id : int = ormar . Integer ( primary_key = True ) sort_order : int = ormar . Integer ( nullable = True ) param_name : str = ormar . String ( default = \"Name\" , max_length = 200 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories = ormar . ManyToMany ( Category , through = PostCategory ) Tip To read more about many-to-many relations and through fields visit many-to-many section Tip ManyToMany allows you to query the related models with queryset-proxy . It allows you to use await post.categories.all() but also await category.posts.all() to fetch data related only to specific post, category etc. Relationship default sort order By default relations follow model default sort order so primary_key column ascending, or any sort order se in Meta class. Tip To read more about models sort order visit models section of documentation But you can modify the order in which related models are loaded during query by providing orders_by and related_orders_by parameters to relations. In relations you can sort only by directly related model columns or for ManyToMany columns also Through model columns {through_field_name}__{column_name} Sample configuration might look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author , orders_by = [ \"name\" ], related_orders_by = [ \"-year\" ] ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) Now calls: await Author.objects.select_related(\"books\").get() - the books will be sorted by the book year descending await Book.objects.select_related(\"author\").all() - the authors will be sorted by author name ascending Self-reference and postponed references In order to create auto-relation or create two models that reference each other in at least two different relations (remember the reverse side is auto-registered for you), you need to use ForwardRef from typing module. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) Person . update_forward_refs () Tip To read more about self-reference and postponed relations visit postponed-annotations section","title":"Relations"},{"location":"relations/#relations","text":"Currently ormar supports two types of relations: One-to-many (and many-to-one) with ForeignKey field Many-to-many with ManyToMany field Below you can find a very basic examples of definitions for each of those relations. To read more about methods, possibilities, definition etc. please read the subsequent section of the documentation.","title":"Relations"},{"location":"relations/#foreignkey","text":"To define many-to-one relation use ForeignKey field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) Tip To read more about one-to-many relations visit foreign-keys section","title":"ForeignKey"},{"location":"relations/#reverse-foreignkey","text":"The definition of one-to-many relation also uses ForeignKey , and it's registered for you automatically. So in relation ato example above. 1 2 3 4 5 6 7 8 9 10 class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # there is a virtual field here like follows courses : Optional [ List [ Course ]] = ormar . ForeignKey ( Course , virtual = True ) # note that you DO NOT define it yourself, ormar does it for you. Tip To read more about many-to-one relations (i.e changing the name of generated field) visit foreign-keys section Tip Reverse ForeignKey allows you to query the related models with queryset-proxy . It allows you to use await department.courses.all() to fetch data related only to specific department etc.","title":"Reverse ForeignKey"},{"location":"relations/#manytomany","text":"To define many-to-many relation use ManyToMany field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ List [ Category ]] = ormar . ManyToMany ( Category ) Tip To read more about many-to-many relations visit many-to-many section Tip ManyToMany allows you to query the related models with queryset-proxy . It allows you to use await post.categories.all() but also await category.posts.all() to fetch data related only to specific post, category etc.","title":"ManyToMany"},{"location":"relations/#through-fields","text":"As part of the ManyToMany relation you can define a through model, that can contain additional fields that you can use to filter, order etc. Fields defined like this are exposed on the reverse side of the current query for m2m models. So if you query from model A to model B , only model B has through field exposed. Which kind of make sense, since it's a one through model/field for each of related models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 40 ) # you can specify additional fields on through model class PostCategory ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts_x_categories\" id : int = ormar . Integer ( primary_key = True ) sort_order : int = ormar . Integer ( nullable = True ) param_name : str = ormar . String ( default = \"Name\" , max_length = 200 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories = ormar . ManyToMany ( Category , through = PostCategory ) Tip To read more about many-to-many relations and through fields visit many-to-many section Tip ManyToMany allows you to query the related models with queryset-proxy . It allows you to use await post.categories.all() but also await category.posts.all() to fetch data related only to specific post, category etc.","title":"Through fields"},{"location":"relations/#relationship-default-sort-order","text":"By default relations follow model default sort order so primary_key column ascending, or any sort order se in Meta class. Tip To read more about models sort order visit models section of documentation But you can modify the order in which related models are loaded during query by providing orders_by and related_orders_by parameters to relations. In relations you can sort only by directly related model columns or for ManyToMany columns also Through model columns {through_field_name}__{column_name} Sample configuration might look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 database = databases . Database ( DATABASE_URL ) metadata = sqlalchemy . MetaData () class BaseMeta ( ormar . ModelMeta ): metadata = metadata database = database class Author ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"authors\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Book ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"books\" id : int = ormar . Integer ( primary_key = True ) author : Optional [ Author ] = ormar . ForeignKey ( Author , orders_by = [ \"name\" ], related_orders_by = [ \"-year\" ] ) title : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) ranking : int = ormar . Integer ( nullable = True ) Now calls: await Author.objects.select_related(\"books\").get() - the books will be sorted by the book year descending await Book.objects.select_related(\"author\").all() - the authors will be sorted by author name ascending","title":"Relationship default sort order"},{"location":"relations/#self-reference-and-postponed-references","text":"In order to create auto-relation or create two models that reference each other in at least two different relations (remember the reverse side is auto-registered for you), you need to use ForwardRef from typing module. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) Person . update_forward_refs () Tip To read more about self-reference and postponed relations visit postponed-annotations section","title":"Self-reference and postponed references"},{"location":"relations/foreign-key/","text":"ForeignKey ForeignKey(to, related_name=None) has required parameters to that takes target Model class. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model Defining Models To define a relation add ForeignKey field that points to related Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) Reverse Relation ForeignKey fields are automatically registering reverse side of the relation. By default it's child (source) Model name + s, like courses in snippet below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Reverse relation exposes API to manage related objects also from parent side. Skipping reverse relation If you are sure you don't want the reverse relation you can use skip_reverse=True flag of the ForeignKey . If you set skip_reverse flag internally the field is still registered on the other side of the relationship so you can: * filter by related models fields from reverse model * order_by by related models fields from reverse model But you cannot: * access the related field from reverse model with related_name * even if you select_related from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can filter and order_by over the relation) * the relation won't be populated in dict() and json() * you cannot pass the nested related objects when populating from dictionary or json (also through fastapi ). It will be either ignored or error will be raised depending on extra setting in pydantic Config . Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Author ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 80 ) last_name : str = ormar . String ( max_length = 80 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : Optional [ Author ] = ormar . ForeignKey ( Author , skip_reverse = True ) # create sample data author = Author ( first_name = \"Test\" , last_name = \"Author\" ) post = Post ( title = \"Test Post\" , author = author ) assert post . author == author # ok assert author . posts # Attribute error! # but still can use in order_by authors = ( await Author . objects . select_related ( \"posts\" ) . order_by ( \"posts__title\" ) . all () ) assert authors [ 0 ] . first_name == \"Test\" # note that posts are not populated for author even if explicitly # included in select_related - note no posts in dict() assert author . dict ( exclude = { \"id\" }) == { \"first_name\" : \"Test\" , \"last_name\" : \"Author\" } # still can filter through fields of related model authors = await Author . objects . filter ( posts__title = \"Test Post\" ) . all () assert authors [ 0 ] . first_name == \"Test\" assert len ( authors ) == 1 add Adding child model from parent side causes adding related model to currently loaded parent relation, as well as sets child's model foreign key value and updates the model. 1 2 3 4 5 6 7 8 9 department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False ) # note - not saved await department . courses . add ( course ) assert course . pk is not None # child model was saved # relation on child model is set and FK column saved in db assert course . department == department # relation on parent model is also set assert department . courses [ 0 ] == course Warning If you want to add child model on related model the primary key value for parent model has to exist in database . Otherwise ormar will raise RelationshipInstanceError as it cannot set child's ForeignKey column value if parent model has no primary key value. That means that in example above the department has to be saved before you can call department.courses.add() . Warning This method will not work on ManyToMany relations - there, both sides of the relation have to be saved before adding to relation. remove Removal of the related model one by one. In reverse relation calling remove() does not remove the child model, but instead nulls it ForeignKey value. 1 2 3 4 5 6 7 8 9 # continuing from above await department . courses . remove ( course ) assert len ( department . courses ) == 0 # course still exists and was saved in remove assert course . pk is not None assert course . department is None # to remove child from db await course . delete () But if you want to clear the relation and delete the child at the same time you can issue: 1 2 3 # this will not only clear the relation # but also delete related course from db await department . courses . remove ( course , keep_reversed = False ) clear Removal of all related models in one call. Like remove by default clear() nulls the ForeigKey column on child model (all, not matter if they are loaded or not). 1 2 # nulls department column on all courses related to this department await department . courses . clear () If you want to remove the children altogether from the database, set keep_reversed=False 1 2 # deletes from db all courses related to this department await department . courses . clear ( keep_reversed = False ) QuerysetProxy Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy related_name But you can overwrite this name by providing related_name parameter like below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department , related_name = \"my_courses\" ) department = Department ( name = \"Science\" ) course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . my_courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Tip The reverse relation on access returns list of wekref.proxy to avoid circular references. Warning When you provide multiple relations to the same model ormar can no longer auto generate the related_name for you. Therefore, in that situation you have to provide related_name for all but one (one can be default and generated) or all related fields. Relation Setup You have several ways to set-up a relationship connection. Model instance The most obvious one is to pass a related Model instance to the constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Primary key value You can setup the relation also with just the pk column value of the related model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Dictionary Next option is with a dictionary of key-values of the related model. You can build the dictionary yourself or get it from existing model with dict() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) None Finally you can explicitly set it to None (default behavior if no value passed). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library.","title":"ForeignKey"},{"location":"relations/foreign-key/#foreignkey","text":"ForeignKey(to, related_name=None) has required parameters to that takes target Model class. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model","title":"ForeignKey"},{"location":"relations/foreign-key/#defining-models","text":"To define a relation add ForeignKey field that points to related Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department )","title":"Defining Models"},{"location":"relations/foreign-key/#reverse-relation","text":"ForeignKey fields are automatically registering reverse side of the relation. By default it's child (source) Model name + s, like courses in snippet below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Reverse relation exposes API to manage related objects also from parent side.","title":"Reverse Relation"},{"location":"relations/foreign-key/#skipping-reverse-relation","text":"If you are sure you don't want the reverse relation you can use skip_reverse=True flag of the ForeignKey . If you set skip_reverse flag internally the field is still registered on the other side of the relationship so you can: * filter by related models fields from reverse model * order_by by related models fields from reverse model But you cannot: * access the related field from reverse model with related_name * even if you select_related from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can filter and order_by over the relation) * the relation won't be populated in dict() and json() * you cannot pass the nested related objects when populating from dictionary or json (also through fastapi ). It will be either ignored or error will be raised depending on extra setting in pydantic Config . Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Author ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 80 ) last_name : str = ormar . String ( max_length = 80 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : Optional [ Author ] = ormar . ForeignKey ( Author , skip_reverse = True ) # create sample data author = Author ( first_name = \"Test\" , last_name = \"Author\" ) post = Post ( title = \"Test Post\" , author = author ) assert post . author == author # ok assert author . posts # Attribute error! # but still can use in order_by authors = ( await Author . objects . select_related ( \"posts\" ) . order_by ( \"posts__title\" ) . all () ) assert authors [ 0 ] . first_name == \"Test\" # note that posts are not populated for author even if explicitly # included in select_related - note no posts in dict() assert author . dict ( exclude = { \"id\" }) == { \"first_name\" : \"Test\" , \"last_name\" : \"Author\" } # still can filter through fields of related model authors = await Author . objects . filter ( posts__title = \"Test Post\" ) . all () assert authors [ 0 ] . first_name == \"Test\" assert len ( authors ) == 1","title":"Skipping reverse relation"},{"location":"relations/foreign-key/#add","text":"Adding child model from parent side causes adding related model to currently loaded parent relation, as well as sets child's model foreign key value and updates the model. 1 2 3 4 5 6 7 8 9 department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False ) # note - not saved await department . courses . add ( course ) assert course . pk is not None # child model was saved # relation on child model is set and FK column saved in db assert course . department == department # relation on parent model is also set assert department . courses [ 0 ] == course Warning If you want to add child model on related model the primary key value for parent model has to exist in database . Otherwise ormar will raise RelationshipInstanceError as it cannot set child's ForeignKey column value if parent model has no primary key value. That means that in example above the department has to be saved before you can call department.courses.add() . Warning This method will not work on ManyToMany relations - there, both sides of the relation have to be saved before adding to relation.","title":"add"},{"location":"relations/foreign-key/#remove","text":"Removal of the related model one by one. In reverse relation calling remove() does not remove the child model, but instead nulls it ForeignKey value. 1 2 3 4 5 6 7 8 9 # continuing from above await department . courses . remove ( course ) assert len ( department . courses ) == 0 # course still exists and was saved in remove assert course . pk is not None assert course . department is None # to remove child from db await course . delete () But if you want to clear the relation and delete the child at the same time you can issue: 1 2 3 # this will not only clear the relation # but also delete related course from db await department . courses . remove ( course , keep_reversed = False )","title":"remove"},{"location":"relations/foreign-key/#clear","text":"Removal of all related models in one call. Like remove by default clear() nulls the ForeigKey column on child model (all, not matter if they are loaded or not). 1 2 # nulls department column on all courses related to this department await department . courses . clear () If you want to remove the children altogether from the database, set keep_reversed=False 1 2 # deletes from db all courses related to this department await department . courses . clear ( keep_reversed = False )","title":"clear"},{"location":"relations/foreign-key/#querysetproxy","text":"Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy","title":"QuerysetProxy"},{"location":"relations/foreign-key/#related_name","text":"But you can overwrite this name by providing related_name parameter like below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department , related_name = \"my_courses\" ) department = Department ( name = \"Science\" ) course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . my_courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Tip The reverse relation on access returns list of wekref.proxy to avoid circular references. Warning When you provide multiple relations to the same model ormar can no longer auto generate the related_name for you. Therefore, in that situation you have to provide related_name for all but one (one can be default and generated) or all related fields.","title":"related_name"},{"location":"relations/foreign-key/#relation-setup","text":"You have several ways to set-up a relationship connection.","title":"Relation Setup"},{"location":"relations/foreign-key/#model-instance","text":"The most obvious one is to pass a related Model instance to the constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Model instance"},{"location":"relations/foreign-key/#primary-key-value","text":"You can setup the relation also with just the pk column value of the related model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Primary key value"},{"location":"relations/foreign-key/#dictionary","text":"Next option is with a dictionary of key-values of the related model. You can build the dictionary yourself or get it from existing model with dict() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Dictionary"},{"location":"relations/foreign-key/#none","text":"Finally you can explicitly set it to None (default behavior if no value passed). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library.","title":"None"},{"location":"relations/many-to-many/","text":"ManyToMany ManyToMany(to, through) has required parameters to and optional through that takes target and relation Model classes. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model Defining Models 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from typing import Optional , Union , List import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Author ( ormar . Model ): class Meta : tablename = \"authors\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 80 ) last_name : str = ormar . String ( max_length = 80 ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ List [ Category ]] = ormar . ManyToMany ( Category ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) Create sample data: 1 2 3 guido = await Author . objects . create ( first_name = \"Guido\" , last_name = \"Van Rossum\" ) post = await Post . objects . create ( title = \"Hello, M2M\" , author = guido ) news = await Category . objects . create ( name = \"News\" ) Reverse relation ForeignKey fields are automatically registering reverse side of the relation. By default it's child (source) Model name + s, like courses in snippet below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ List [ Category ]] = ormar . ManyToMany ( Category ) # create some sample data post = await Post . objects . create ( title = \"Hello, M2M\" ) news = await Category . objects . create ( name = \"News\" ) await post . categories . add ( news ) # now you can query and access from both sides: post_check = Post . objects . select_related ( \"categories\" ) . get () assert post_check . categories [ 0 ] == news # query through auto registered reverse side category_check = Category . objects . select_related ( \"posts\" ) . get () assert category_check . posts [ 0 ] == post Reverse relation exposes API to manage related objects also from parent side. related_name By default, the related_name is generated in the same way as for the ForeignKey relation (class.name.lower()+'s'), but in the same way you can overwrite this name by providing related_name parameter like below: 1 2 3 categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory , related_name = \"new_categories\" ) Warning When you provide multiple relations to the same model ormar can no longer auto generate the related_name for you. Therefore, in that situation you have to provide related_name for all but one (one can be default and generated) or all related fields. Skipping reverse relation If you are sure you don't want the reverse relation you can use skip_reverse=True flag of the ManyToMany . If you set skip_reverse flag internally the field is still registered on the other side of the relationship so you can: * filter by related models fields from reverse model * order_by by related models fields from reverse model But you cannot: * access the related field from reverse model with related_name * even if you select_related from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can filter and order_by over the relation) * the relation won't be populated in dict() and json() * you cannot pass the nested related objects when populating from dictionary or json (also through fastapi ). It will be either ignored or error will be raised depending on extra setting in pydantic Config . Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ List [ Category ]] = ormar . ManyToMany ( Category , skip_reverse = True ) # create some sample data post = await Post . objects . create ( title = \"Hello, M2M\" ) news = await Category . objects . create ( name = \"News\" ) await post . categories . add ( news ) assert post . categories [ 0 ] == news # ok assert news . posts # Attribute error! # but still can use in order_by categories = ( await Category . objects . select_related ( \"posts\" ) . order_by ( \"posts__title\" ) . all () ) assert categories [ 0 ] . first_name == \"Test\" # note that posts are not populated for author even if explicitly # included in select_related - note no posts in dict() assert news . dict ( exclude = { \"id\" }) == { \"name\" : \"News\" } # still can filter through fields of related model categories = await Category . objects . filter ( posts__title = \"Hello, M2M\" ) . all () assert categories [ 0 ] . name == \"News\" assert len ( categories ) == 1 Through Model Optionally if you want to add additional fields you can explicitly create and pass the through model class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class BaseMeta ( ormar . ModelMeta ): database = database metadata = metadata class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts_x_categories\" id : int = ormar . Integer ( primary_key = True ) sort_order : int = ormar . Integer ( nullable = True ) param_name : str = ormar . String ( default = \"Name\" , max_length = 200 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories = ormar . ManyToMany ( Category , through = PostCategory ) Warning Note that even of you do not provide through model it's going to be created for you automatically and still has to be included in example in alembic migrations. Tip Note that you need to provide through model if you want to customize the Through model name or the database table name of this model. If you do not provide the Through field it will be generated for you. The default naming convention is: for class name it's union of both classes name (parent+other) so in example above it would be PostCategory for table name it similar but with underscore in between and s in the end of class lowercase name, in example above would be posts_categorys Customizing Through relation names By default Through model relation names default to related model name in lowercase. So in example like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... # course declaration omitted class Student ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) courses = ormar . ManyToMany ( Course ) # will produce default Through model like follows (example simplified) class StudentCourse ( ormar . Model ): class Meta : database = database metadata = metadata tablename = \"students_courses\" id : int = ormar . Integer ( primary_key = True ) student = ormar . ForeignKey ( Student ) # default name course = ormar . ForeignKey ( Course ) # default name To customize the names of fields/relation in Through model now you can use new parameters to ManyToMany : through_relation_name - name of the field leading to the model in which ManyToMany is declared through_reverse_relation_name - name of the field leading to the model to which ManyToMany leads to Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... # course declaration ommited class Student ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) courses = ormar . ManyToMany ( Course , through_relation_name = \"student_id\" , through_reverse_relation_name = \"course_id\" ) # will produce Through model like follows (example simplified) class StudentCourse ( ormar . Model ): class Meta : database = database metadata = metadata tablename = \"students_courses\" id : int = ormar . Integer ( primary_key = True ) student_id = ormar . ForeignKey ( Student ) # set by through_relation_name course_id = ormar . ForeignKey ( Course ) # set by through_reverse_relation_name Note Note that explicitly declaring relations in Through model is forbidden, so even if you provide your own custom Through model you cannot change the names there and you need to use same through_relation_name and through_reverse_relation_name parameters. Through Fields The through field is auto added to the reverse side of the relation. The exposed field is named as lowercase Through class name. The exposed field explicitly has no relations loaded as the relation is already populated in ManyToMany field, so it's useful only when additional fields are provided on Through model. In a sample model setup as following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class BaseMeta ( ormar . ModelMeta ): database = database metadata = metadata class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts_x_categories\" id : int = ormar . Integer ( primary_key = True ) sort_order : int = ormar . Integer ( nullable = True ) param_name : str = ormar . String ( default = \"Name\" , max_length = 200 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories = ormar . ManyToMany ( Category , through = PostCategory ) the through field can be used as a normal model field in most of the QuerySet operations. Note that through field is attached only to related side of the query so: 1 2 3 4 5 6 7 8 9 10 post = await Post . objects . select_related ( \"categories\" ) . get () # source model has no through field assert post . postcategory is None # related models have through field assert post . categories [ 0 ] . postcategory is not None # same is applicable for reversed query category = await Category . objects . select_related ( \"posts\" ) . get () assert category . postcategory is None assert category . posts [ 0 ] . postcategory is not None Through field can be used for filtering the data. 1 2 3 4 5 post = ( await Post . objects . select_related ( \"categories\" ) . filter ( postcategory__sort_order__gt = 1 ) . get () ) Tip Note that despite that the actual instance is not populated on source model, in queries, order by statements etc you can access through model from both sides. So below query has exactly the same effect (note access through categories ) 1 2 3 4 5 post = ( await Post . objects . select_related ( \"categories\" ) . filter ( categories__postcategory__sort_order__gt = 1 ) . get () ) Through model can be used in order by queries. 1 2 3 4 5 post = ( await Post . objects . select_related ( \"categories\" ) . order_by ( \"-postcategory__sort_order\" ) . get () ) You can also select subset of the columns in a normal QuerySet way with fields and exclude_fields . 1 2 3 4 5 post2 = ( await Post . objects . select_related ( \"categories\" ) . exclude_fields ( \"postcategory__param_name\" ) . get () ) Warning Note that because through fields explicitly nullifies all relation fields, as relation is populated in ManyToMany field, you should not use the standard model methods like save() and update() before re-loading the field from database. If you want to modify the through field in place remember to reload it from database. Otherwise you will set relations to None so effectively make the field useless! 1 2 3 4 # always reload the field before modification await post2 . categories [ 0 ] . postcategory . load () # only then update the field await post2 . categories [ 0 ] . postcategory . update ( sort_order = 3 ) Note that reloading the model effectively reloads the relations as pk_only models (only primary key is set) so they are not fully populated, but it's enough to preserve the relation on update. Warning If you use i.e. fastapi the partially loaded related models on through field might cause pydantic validation errors (that's the primary reason why they are not populated by default). So either you need to exclude the related fields in your response, or fully load the related models. In example above it would mean: 1 2 await post2 . categories [ 0 ] . postcategory . post . load () await post2 . categories [ 0 ] . postcategory . category . load () Alternatively you can use load_all() : 1 await post2 . categories [ 0 ] . postcategory . load_all () Preferred way of update is through queryset proxy update() method 1 2 # filter the desired related model with through field and update only through field params await post2 . categories . filter ( name = 'Test category' ) . update ( postcategory = { \"sort_order\" : 3 }) Relation methods add add(item: Model, **kwargs) Allows you to add model to ManyToMany relation. 1 2 3 4 # Add a category to a post. await post . categories . add ( news ) # or from the other end: await news . posts . add ( post ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library. If you declare your models with a Through model with additional fields, you can populate them during adding child model to relation. In order to do so, pass keyword arguments with field names and values to add() call. Note that this works only for ManyToMany relations. 1 2 3 4 post = await Post ( title = \"Test post\" ) . save () category = await Category ( name = \"Test category\" ) . save () # apart from model pass arguments referencing through model fields await post . categories . add ( category , sort_order = 1 , param_name = 'test' ) remove Removal of the related model one by one. Removes also the relation in the database. 1 await news . posts . remove ( post ) clear Removal of all related models in one call. Removes also the relation in the database. 1 await news . posts . clear () QuerysetProxy Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy","title":"ManyToMany"},{"location":"relations/many-to-many/#manytomany","text":"ManyToMany(to, through) has required parameters to and optional through that takes target and relation Model classes. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model","title":"ManyToMany"},{"location":"relations/many-to-many/#defining-models","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from typing import Optional , Union , List import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Author ( ormar . Model ): class Meta : tablename = \"authors\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 80 ) last_name : str = ormar . String ( max_length = 80 ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ List [ Category ]] = ormar . ManyToMany ( Category ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) Create sample data: 1 2 3 guido = await Author . objects . create ( first_name = \"Guido\" , last_name = \"Van Rossum\" ) post = await Post . objects . create ( title = \"Hello, M2M\" , author = guido ) news = await Category . objects . create ( name = \"News\" )","title":"Defining Models"},{"location":"relations/many-to-many/#reverse-relation","text":"ForeignKey fields are automatically registering reverse side of the relation. By default it's child (source) Model name + s, like courses in snippet below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ List [ Category ]] = ormar . ManyToMany ( Category ) # create some sample data post = await Post . objects . create ( title = \"Hello, M2M\" ) news = await Category . objects . create ( name = \"News\" ) await post . categories . add ( news ) # now you can query and access from both sides: post_check = Post . objects . select_related ( \"categories\" ) . get () assert post_check . categories [ 0 ] == news # query through auto registered reverse side category_check = Category . objects . select_related ( \"posts\" ) . get () assert category_check . posts [ 0 ] == post Reverse relation exposes API to manage related objects also from parent side.","title":"Reverse relation"},{"location":"relations/many-to-many/#related_name","text":"By default, the related_name is generated in the same way as for the ForeignKey relation (class.name.lower()+'s'), but in the same way you can overwrite this name by providing related_name parameter like below: 1 2 3 categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory , related_name = \"new_categories\" ) Warning When you provide multiple relations to the same model ormar can no longer auto generate the related_name for you. Therefore, in that situation you have to provide related_name for all but one (one can be default and generated) or all related fields.","title":"related_name"},{"location":"relations/many-to-many/#skipping-reverse-relation","text":"If you are sure you don't want the reverse relation you can use skip_reverse=True flag of the ManyToMany . If you set skip_reverse flag internally the field is still registered on the other side of the relationship so you can: * filter by related models fields from reverse model * order_by by related models fields from reverse model But you cannot: * access the related field from reverse model with related_name * even if you select_related from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can filter and order_by over the relation) * the relation won't be populated in dict() and json() * you cannot pass the nested related objects when populating from dictionary or json (also through fastapi ). It will be either ignored or error will be raised depending on extra setting in pydantic Config . Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ List [ Category ]] = ormar . ManyToMany ( Category , skip_reverse = True ) # create some sample data post = await Post . objects . create ( title = \"Hello, M2M\" ) news = await Category . objects . create ( name = \"News\" ) await post . categories . add ( news ) assert post . categories [ 0 ] == news # ok assert news . posts # Attribute error! # but still can use in order_by categories = ( await Category . objects . select_related ( \"posts\" ) . order_by ( \"posts__title\" ) . all () ) assert categories [ 0 ] . first_name == \"Test\" # note that posts are not populated for author even if explicitly # included in select_related - note no posts in dict() assert news . dict ( exclude = { \"id\" }) == { \"name\" : \"News\" } # still can filter through fields of related model categories = await Category . objects . filter ( posts__title = \"Hello, M2M\" ) . all () assert categories [ 0 ] . name == \"News\" assert len ( categories ) == 1","title":"Skipping reverse relation"},{"location":"relations/many-to-many/#through-model","text":"Optionally if you want to add additional fields you can explicitly create and pass the through model class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class BaseMeta ( ormar . ModelMeta ): database = database metadata = metadata class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts_x_categories\" id : int = ormar . Integer ( primary_key = True ) sort_order : int = ormar . Integer ( nullable = True ) param_name : str = ormar . String ( default = \"Name\" , max_length = 200 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories = ormar . ManyToMany ( Category , through = PostCategory ) Warning Note that even of you do not provide through model it's going to be created for you automatically and still has to be included in example in alembic migrations. Tip Note that you need to provide through model if you want to customize the Through model name or the database table name of this model. If you do not provide the Through field it will be generated for you. The default naming convention is: for class name it's union of both classes name (parent+other) so in example above it would be PostCategory for table name it similar but with underscore in between and s in the end of class lowercase name, in example above would be posts_categorys","title":"Through Model"},{"location":"relations/many-to-many/#customizing-through-relation-names","text":"By default Through model relation names default to related model name in lowercase. So in example like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... # course declaration omitted class Student ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) courses = ormar . ManyToMany ( Course ) # will produce default Through model like follows (example simplified) class StudentCourse ( ormar . Model ): class Meta : database = database metadata = metadata tablename = \"students_courses\" id : int = ormar . Integer ( primary_key = True ) student = ormar . ForeignKey ( Student ) # default name course = ormar . ForeignKey ( Course ) # default name To customize the names of fields/relation in Through model now you can use new parameters to ManyToMany : through_relation_name - name of the field leading to the model in which ManyToMany is declared through_reverse_relation_name - name of the field leading to the model to which ManyToMany leads to Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... # course declaration ommited class Student ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) courses = ormar . ManyToMany ( Course , through_relation_name = \"student_id\" , through_reverse_relation_name = \"course_id\" ) # will produce Through model like follows (example simplified) class StudentCourse ( ormar . Model ): class Meta : database = database metadata = metadata tablename = \"students_courses\" id : int = ormar . Integer ( primary_key = True ) student_id = ormar . ForeignKey ( Student ) # set by through_relation_name course_id = ormar . ForeignKey ( Course ) # set by through_reverse_relation_name Note Note that explicitly declaring relations in Through model is forbidden, so even if you provide your own custom Through model you cannot change the names there and you need to use same through_relation_name and through_reverse_relation_name parameters.","title":"Customizing Through relation names"},{"location":"relations/many-to-many/#through-fields","text":"The through field is auto added to the reverse side of the relation. The exposed field is named as lowercase Through class name. The exposed field explicitly has no relations loaded as the relation is already populated in ManyToMany field, so it's useful only when additional fields are provided on Through model. In a sample model setup as following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class BaseMeta ( ormar . ModelMeta ): database = database metadata = metadata class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts_x_categories\" id : int = ormar . Integer ( primary_key = True ) sort_order : int = ormar . Integer ( nullable = True ) param_name : str = ormar . String ( default = \"Name\" , max_length = 200 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories = ormar . ManyToMany ( Category , through = PostCategory ) the through field can be used as a normal model field in most of the QuerySet operations. Note that through field is attached only to related side of the query so: 1 2 3 4 5 6 7 8 9 10 post = await Post . objects . select_related ( \"categories\" ) . get () # source model has no through field assert post . postcategory is None # related models have through field assert post . categories [ 0 ] . postcategory is not None # same is applicable for reversed query category = await Category . objects . select_related ( \"posts\" ) . get () assert category . postcategory is None assert category . posts [ 0 ] . postcategory is not None Through field can be used for filtering the data. 1 2 3 4 5 post = ( await Post . objects . select_related ( \"categories\" ) . filter ( postcategory__sort_order__gt = 1 ) . get () ) Tip Note that despite that the actual instance is not populated on source model, in queries, order by statements etc you can access through model from both sides. So below query has exactly the same effect (note access through categories ) 1 2 3 4 5 post = ( await Post . objects . select_related ( \"categories\" ) . filter ( categories__postcategory__sort_order__gt = 1 ) . get () ) Through model can be used in order by queries. 1 2 3 4 5 post = ( await Post . objects . select_related ( \"categories\" ) . order_by ( \"-postcategory__sort_order\" ) . get () ) You can also select subset of the columns in a normal QuerySet way with fields and exclude_fields . 1 2 3 4 5 post2 = ( await Post . objects . select_related ( \"categories\" ) . exclude_fields ( \"postcategory__param_name\" ) . get () ) Warning Note that because through fields explicitly nullifies all relation fields, as relation is populated in ManyToMany field, you should not use the standard model methods like save() and update() before re-loading the field from database. If you want to modify the through field in place remember to reload it from database. Otherwise you will set relations to None so effectively make the field useless! 1 2 3 4 # always reload the field before modification await post2 . categories [ 0 ] . postcategory . load () # only then update the field await post2 . categories [ 0 ] . postcategory . update ( sort_order = 3 ) Note that reloading the model effectively reloads the relations as pk_only models (only primary key is set) so they are not fully populated, but it's enough to preserve the relation on update. Warning If you use i.e. fastapi the partially loaded related models on through field might cause pydantic validation errors (that's the primary reason why they are not populated by default). So either you need to exclude the related fields in your response, or fully load the related models. In example above it would mean: 1 2 await post2 . categories [ 0 ] . postcategory . post . load () await post2 . categories [ 0 ] . postcategory . category . load () Alternatively you can use load_all() : 1 await post2 . categories [ 0 ] . postcategory . load_all () Preferred way of update is through queryset proxy update() method 1 2 # filter the desired related model with through field and update only through field params await post2 . categories . filter ( name = 'Test category' ) . update ( postcategory = { \"sort_order\" : 3 })","title":"Through Fields"},{"location":"relations/many-to-many/#relation-methods","text":"","title":"Relation methods"},{"location":"relations/many-to-many/#add","text":"add(item: Model, **kwargs) Allows you to add model to ManyToMany relation. 1 2 3 4 # Add a category to a post. await post . categories . add ( news ) # or from the other end: await news . posts . add ( post ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library. If you declare your models with a Through model with additional fields, you can populate them during adding child model to relation. In order to do so, pass keyword arguments with field names and values to add() call. Note that this works only for ManyToMany relations. 1 2 3 4 post = await Post ( title = \"Test post\" ) . save () category = await Category ( name = \"Test category\" ) . save () # apart from model pass arguments referencing through model fields await post . categories . add ( category , sort_order = 1 , param_name = 'test' )","title":"add"},{"location":"relations/many-to-many/#remove","text":"Removal of the related model one by one. Removes also the relation in the database. 1 await news . posts . remove ( post )","title":"remove"},{"location":"relations/many-to-many/#clear","text":"Removal of all related models in one call. Removes also the relation in the database. 1 await news . posts . clear ()","title":"clear"},{"location":"relations/many-to-many/#querysetproxy","text":"Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy","title":"QuerysetProxy"},{"location":"relations/postponed-annotations/","text":"Postponed annotations Self-referencing Models When you want to reference the same model during declaration to create a relation you need to declare the referenced model as a ForwardRef , as during the declaration the class is not yet ready and python by default won't let you reference it. Although you might be tempted to use future annotations or simply quote the name with \"\" it won't work as ormar is designed to work with explicitly declared ForwardRef . First, you need to import the required ref from typing. 1 from typing import ForwardRef But note that before python 3.7 it used to be internal, so for python <= 3.6 you need 1 from typing import _ForwardRef as ForwardRef or since pydantic is required by ormar it can handle this switch for you. In that case you can simply import ForwardRef from pydantic regardless of your python version. 1 from pydantic.typing import ForwardRef Now we need a sample model and a reference to the same model, which will be used to creat a self referencing relation. 1 2 3 4 5 6 7 8 9 10 11 12 13 # create the forwardref to model Person PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # use the forwardref as to parameter supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) That's so simple. But before you can use the model you need to manually update the references so that they lead to the actual models. Warning If you try to use the model without updated references, ModelError exception will be raised. So in our example above any call like following will cause exception 1 2 3 4 5 6 # creation of model - exception await Person . objects . create ( name = \"Test\" ) # initialization of model - exception Person2 ( name = \"Test\" ) # usage of model's QuerySet - exception await Person2 . objects . get () To update the references call the update_forward_refs method on each model with forward references, only after all related models were declared. So in order to make our previous example work we need just one extra line. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) Person . update_forward_refs () Of course the same can be done with ManyToMany relations in exactly same way, both for to and through parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # declare the reference ChildRef = ForwardRef ( \"Child\" ) class ChildFriend ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db class Child ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # use it in relation friends = ormar . ManyToMany ( ChildRef , through = ChildFriend , related_name = \"also_friends\" ) Child . update_forward_refs () Cross model relations The same mechanism and logic as for self-reference model can be used to link multiple different models between each other. Of course ormar links both sides of relation for you, creating a reverse relation with specified (or default) related_name . But if you need two (or more) relations between any two models, that for whatever reason should be stored on both sides (so one relation is declared on one model, and other on the second model), you need to use ForwardRef to achieve that. Look at the following simple example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # teacher is not yet defined TeacherRef = ForwardRef ( \"Teacher\" ) class Student ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # so we use reference instead of actual model primary_teacher : TeacherRef = ormar . ForeignKey ( TeacherRef , related_name = \"own_students\" ) class StudentTeacher ( ormar . Model ): class Meta ( ModelMeta ): tablename = 'students_x_teachers' metadata = metadata database = db class Teacher ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # we need students for other relation hence the order students = ormar . ManyToMany ( Student , through = StudentTeacher , related_name = \"teachers\" ) # now the Teacher model is already defined we can update references Student . update_forward_refs () Warning Remember that related_name needs to be unique across related models regardless of how many relations are defined.","title":"Postponed annotations"},{"location":"relations/postponed-annotations/#postponed-annotations","text":"","title":"Postponed annotations"},{"location":"relations/postponed-annotations/#self-referencing-models","text":"When you want to reference the same model during declaration to create a relation you need to declare the referenced model as a ForwardRef , as during the declaration the class is not yet ready and python by default won't let you reference it. Although you might be tempted to use future annotations or simply quote the name with \"\" it won't work as ormar is designed to work with explicitly declared ForwardRef . First, you need to import the required ref from typing. 1 from typing import ForwardRef But note that before python 3.7 it used to be internal, so for python <= 3.6 you need 1 from typing import _ForwardRef as ForwardRef or since pydantic is required by ormar it can handle this switch for you. In that case you can simply import ForwardRef from pydantic regardless of your python version. 1 from pydantic.typing import ForwardRef Now we need a sample model and a reference to the same model, which will be used to creat a self referencing relation. 1 2 3 4 5 6 7 8 9 10 11 12 13 # create the forwardref to model Person PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # use the forwardref as to parameter supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) That's so simple. But before you can use the model you need to manually update the references so that they lead to the actual models. Warning If you try to use the model without updated references, ModelError exception will be raised. So in our example above any call like following will cause exception 1 2 3 4 5 6 # creation of model - exception await Person . objects . create ( name = \"Test\" ) # initialization of model - exception Person2 ( name = \"Test\" ) # usage of model's QuerySet - exception await Person2 . objects . get () To update the references call the update_forward_refs method on each model with forward references, only after all related models were declared. So in order to make our previous example work we need just one extra line. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PersonRef = ForwardRef ( \"Person\" ) class Person ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) supervisor : PersonRef = ormar . ForeignKey ( PersonRef , related_name = \"employees\" ) Person . update_forward_refs () Of course the same can be done with ManyToMany relations in exactly same way, both for to and through parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # declare the reference ChildRef = ForwardRef ( \"Child\" ) class ChildFriend ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db class Child ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # use it in relation friends = ormar . ManyToMany ( ChildRef , through = ChildFriend , related_name = \"also_friends\" ) Child . update_forward_refs ()","title":"Self-referencing Models"},{"location":"relations/postponed-annotations/#cross-model-relations","text":"The same mechanism and logic as for self-reference model can be used to link multiple different models between each other. Of course ormar links both sides of relation for you, creating a reverse relation with specified (or default) related_name . But if you need two (or more) relations between any two models, that for whatever reason should be stored on both sides (so one relation is declared on one model, and other on the second model), you need to use ForwardRef to achieve that. Look at the following simple example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # teacher is not yet defined TeacherRef = ForwardRef ( \"Teacher\" ) class Student ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # so we use reference instead of actual model primary_teacher : TeacherRef = ormar . ForeignKey ( TeacherRef , related_name = \"own_students\" ) class StudentTeacher ( ormar . Model ): class Meta ( ModelMeta ): tablename = 'students_x_teachers' metadata = metadata database = db class Teacher ( ormar . Model ): class Meta ( ModelMeta ): metadata = metadata database = db id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) # we need students for other relation hence the order students = ormar . ManyToMany ( Student , through = StudentTeacher , related_name = \"teachers\" ) # now the Teacher model is already defined we can update references Student . update_forward_refs () Warning Remember that related_name needs to be unique across related models regardless of how many relations are defined.","title":"Cross model relations"},{"location":"relations/queryset-proxy/","text":"QuerySetProxy When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. Note By default exposed QuerySet is already filtered to return only Models related to parent Model . So if you issue post.categories.all() you will get all categories related to that post, not all in table. Note Note that when accessing QuerySet API methods through QuerysetProxy you don't need to use objects attribute like in normal queries. So note that it's post.categories.all() and not post.categories.objects.all() . To learn more about available QuerySet methods visit queries Warning Querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 This happens for all QuerysetProxy methods returning data: get , all and first and in get_or_create if model already exists. Note that value returned by create or created in get_or_create and update_or_create if model does not exist will be added to relation list (not clearing it). Read data from database get get(**kwargs): -> Model To grab just one of related models filtered by name you can use get(**kwargs) method. 1 2 3 4 5 6 7 8 9 # grab one category assert news == await post . categories . get ( name = \"News\" ) # note that method returns the category so you can grab this value # but it also modifies list of related models in place # so regardless of what was previously loaded on parent model # now it has only one value -> just loaded with get() call assert len ( post . categories ) == 1 assert post . categories [ 0 ] == news Tip Read more in queries documentation get get_or_create get_or_create(**kwargs) -> Model Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. Tip Read more in queries documentation get_or_create all all(**kwargs) -> List[Optional[\"Model\"]] To get a list of related models use all() method. Note that you can filter the queryset, select related, exclude fields etc. like in normal query. 1 2 3 4 5 6 7 # with all Queryset methods - filtering, selecting columns, counting etc. await news . posts . filter ( title__contains = \"M2M\" ) . all () await Category . objects . filter ( posts__author = guido ) . get () # columns models of many to many relation can be prefetched news_posts = await news . posts . select_related ( \"author\" ) . all () assert news_posts [ 0 ] . author == guido Tip Read more in queries documentation all Insert/ update data into database create create(**kwargs): -> Model Create related Model directly from parent Model . The link table is automatically populated, as well as relation ids in the database. 1 2 3 4 # Creating columns object from instance: await post . categories . create ( name = \"Tips\" ) assert len ( await post . categories . all ()) == 2 # newly created instance already have relation persisted in the database Tip Read more in queries documentation create For ManyToMany relations there is an additional functionality of passing parameters that will be used to create a through model if you declared additional fields on explicitly provided Through model. Given sample like this: ```Python hl_lines=\"14-20, 29\" class BaseMeta(ormar.ModelMeta): database = database metadata = metadata class Category(ormar.Model): class Meta(BaseMeta): tablename = \"categories\" 1 2 id = ormar.Integer(primary_key=True) name = ormar.String(max_length=40) class PostCategory(ormar.Model): class Meta(BaseMeta): tablename = \"posts_x_categories\" 1 2 3 id: int = ormar.Integer(primary_key=True) sort_order: int = ormar.Integer(nullable=True) param_name: str = ormar.String(default=\"Name\", max_length=200) class Post(ormar.Model): class Meta(BaseMeta): pass 1 2 3 id: int = ormar.Integer(primary_key=True) title: str = ormar.String(max_length=200) categories = ormar.ManyToMany(Category, through=PostCategory) You can populate fields on through model in the `create()` call in a following way: python post = await Post(title=\"Test post\").save() await post.categories.create( name=\"Test category1\", # in arguments pass a dictionary with name of the through field and keys # corresponding to through model fields postcategory={\"sort_order\": 1, \"param_name\": \"volume\"}, ) ``` get_or_create get_or_create(**kwargs) -> Model Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. Tip Read more in queries documentation get_or_create update_or_create update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. Tip Read more in queries documentation update_or_create update update(**kwargs, each:bool = False) -> int Updates the related model with provided keyword arguments, return number of updated rows. Tip Read more in queries documentation update Note that for ManyToMany relations update can also accept an argument with through field name and a dictionary of fields. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class BaseMeta ( ormar . ModelMeta ): database = database metadata = metadata class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts_x_categories\" id : int = ormar . Integer ( primary_key = True ) sort_order : int = ormar . Integer ( nullable = True ) param_name : str = ormar . String ( default = \"Name\" , max_length = 200 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories = ormar . ManyToMany ( Category , through = PostCategory ) In example above you can update attributes of postcategory in a following call: 1 2 3 await post . categories . filter ( name = \"Test category3\" ) . update ( postcategory = { \"sort_order\" : 4 } ) Filtering and sorting filter filter(*args, **kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. Tip Read more in queries documentation filter exclude exclude(*args, **kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. Tip Read more in queries documentation exclude order_by order_by(columns:Union[List, str]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. Tip Read more in queries documentation order_by Joins and subqueries select_related select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python. Tip Read more in queries documentation select_related prefetch_related prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database, meaning that you will have multiple queries executed one after another. Tip Read more in queries documentation prefetch_related Pagination and rows number paginate paginate(page: int, page_size: int = 20) -> QuerySet Combines the offset and limit methods based on page number and size. Tip Read more in queries documentation paginate limit limit(limit_count: int) -> QuerySet You can limit the results to desired number of parent models. Tip Read more in queries documentation limit offset offset(offset: int) -> QuerySet You can offset the results by desired number of main models. Tip Read more in queries documentation offset Selecting subset of columns fields fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Tip Read more in queries documentation fields exclude_fields exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. Tip Read more in queries documentation exclude_fields Aggregated functions count count() -> int Returns number of rows matching the given criteria (i.e. applied with filter and exclude) Tip Read more in queries documentation count exists exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude) Tip Read more in queries documentation exists","title":"QuerySetProxy"},{"location":"relations/queryset-proxy/#querysetproxy","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. Note By default exposed QuerySet is already filtered to return only Models related to parent Model . So if you issue post.categories.all() you will get all categories related to that post, not all in table. Note Note that when accessing QuerySet API methods through QuerysetProxy you don't need to use objects attribute like in normal queries. So note that it's post.categories.all() and not post.categories.objects.all() . To learn more about available QuerySet methods visit queries Warning Querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 This happens for all QuerysetProxy methods returning data: get , all and first and in get_or_create if model already exists. Note that value returned by create or created in get_or_create and update_or_create if model does not exist will be added to relation list (not clearing it).","title":"QuerySetProxy"},{"location":"relations/queryset-proxy/#read-data-from-database","text":"","title":"Read data from database"},{"location":"relations/queryset-proxy/#get","text":"get(**kwargs): -> Model To grab just one of related models filtered by name you can use get(**kwargs) method. 1 2 3 4 5 6 7 8 9 # grab one category assert news == await post . categories . get ( name = \"News\" ) # note that method returns the category so you can grab this value # but it also modifies list of related models in place # so regardless of what was previously loaded on parent model # now it has only one value -> just loaded with get() call assert len ( post . categories ) == 1 assert post . categories [ 0 ] == news Tip Read more in queries documentation get","title":"get"},{"location":"relations/queryset-proxy/#get_or_create","text":"get_or_create(**kwargs) -> Model Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. Tip Read more in queries documentation get_or_create","title":"get_or_create"},{"location":"relations/queryset-proxy/#all","text":"all(**kwargs) -> List[Optional[\"Model\"]] To get a list of related models use all() method. Note that you can filter the queryset, select related, exclude fields etc. like in normal query. 1 2 3 4 5 6 7 # with all Queryset methods - filtering, selecting columns, counting etc. await news . posts . filter ( title__contains = \"M2M\" ) . all () await Category . objects . filter ( posts__author = guido ) . get () # columns models of many to many relation can be prefetched news_posts = await news . posts . select_related ( \"author\" ) . all () assert news_posts [ 0 ] . author == guido Tip Read more in queries documentation all","title":"all"},{"location":"relations/queryset-proxy/#insert-update-data-into-database","text":"","title":"Insert/ update data into database"},{"location":"relations/queryset-proxy/#create","text":"create(**kwargs): -> Model Create related Model directly from parent Model . The link table is automatically populated, as well as relation ids in the database. 1 2 3 4 # Creating columns object from instance: await post . categories . create ( name = \"Tips\" ) assert len ( await post . categories . all ()) == 2 # newly created instance already have relation persisted in the database Tip Read more in queries documentation create For ManyToMany relations there is an additional functionality of passing parameters that will be used to create a through model if you declared additional fields on explicitly provided Through model. Given sample like this: ```Python hl_lines=\"14-20, 29\" class BaseMeta(ormar.ModelMeta): database = database metadata = metadata class Category(ormar.Model): class Meta(BaseMeta): tablename = \"categories\" 1 2 id = ormar.Integer(primary_key=True) name = ormar.String(max_length=40) class PostCategory(ormar.Model): class Meta(BaseMeta): tablename = \"posts_x_categories\" 1 2 3 id: int = ormar.Integer(primary_key=True) sort_order: int = ormar.Integer(nullable=True) param_name: str = ormar.String(default=\"Name\", max_length=200) class Post(ormar.Model): class Meta(BaseMeta): pass 1 2 3 id: int = ormar.Integer(primary_key=True) title: str = ormar.String(max_length=200) categories = ormar.ManyToMany(Category, through=PostCategory) You can populate fields on through model in the `create()` call in a following way: python post = await Post(title=\"Test post\").save() await post.categories.create( name=\"Test category1\", # in arguments pass a dictionary with name of the through field and keys # corresponding to through model fields postcategory={\"sort_order\": 1, \"param_name\": \"volume\"}, ) ```","title":"create"},{"location":"relations/queryset-proxy/#get_or_create_1","text":"get_or_create(**kwargs) -> Model Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. Tip Read more in queries documentation get_or_create","title":"get_or_create"},{"location":"relations/queryset-proxy/#update_or_create","text":"update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. Tip Read more in queries documentation update_or_create","title":"update_or_create"},{"location":"relations/queryset-proxy/#update","text":"update(**kwargs, each:bool = False) -> int Updates the related model with provided keyword arguments, return number of updated rows. Tip Read more in queries documentation update Note that for ManyToMany relations update can also accept an argument with through field name and a dictionary of fields. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class BaseMeta ( ormar . ModelMeta ): database = database metadata = metadata class Category ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"categories\" id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta ( BaseMeta ): tablename = \"posts_x_categories\" id : int = ormar . Integer ( primary_key = True ) sort_order : int = ormar . Integer ( nullable = True ) param_name : str = ormar . String ( default = \"Name\" , max_length = 200 ) class Post ( ormar . Model ): class Meta ( BaseMeta ): pass id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories = ormar . ManyToMany ( Category , through = PostCategory ) In example above you can update attributes of postcategory in a following call: 1 2 3 await post . categories . filter ( name = \"Test category3\" ) . update ( postcategory = { \"sort_order\" : 4 } )","title":"update"},{"location":"relations/queryset-proxy/#filtering-and-sorting","text":"","title":"Filtering and sorting"},{"location":"relations/queryset-proxy/#filter","text":"filter(*args, **kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. Tip Read more in queries documentation filter","title":"filter"},{"location":"relations/queryset-proxy/#exclude","text":"exclude(*args, **kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. Tip Read more in queries documentation exclude","title":"exclude"},{"location":"relations/queryset-proxy/#order_by","text":"order_by(columns:Union[List, str]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. Tip Read more in queries documentation order_by","title":"order_by"},{"location":"relations/queryset-proxy/#joins-and-subqueries","text":"","title":"Joins and subqueries"},{"location":"relations/queryset-proxy/#select_related","text":"select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python. Tip Read more in queries documentation select_related","title":"select_related"},{"location":"relations/queryset-proxy/#prefetch_related","text":"prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database, meaning that you will have multiple queries executed one after another. Tip Read more in queries documentation prefetch_related","title":"prefetch_related"},{"location":"relations/queryset-proxy/#pagination-and-rows-number","text":"","title":"Pagination and rows number"},{"location":"relations/queryset-proxy/#paginate","text":"paginate(page: int, page_size: int = 20) -> QuerySet Combines the offset and limit methods based on page number and size. Tip Read more in queries documentation paginate","title":"paginate"},{"location":"relations/queryset-proxy/#limit","text":"limit(limit_count: int) -> QuerySet You can limit the results to desired number of parent models. Tip Read more in queries documentation limit","title":"limit"},{"location":"relations/queryset-proxy/#offset","text":"offset(offset: int) -> QuerySet You can offset the results by desired number of main models. Tip Read more in queries documentation offset","title":"offset"},{"location":"relations/queryset-proxy/#selecting-subset-of-columns","text":"","title":"Selecting subset of columns"},{"location":"relations/queryset-proxy/#fields","text":"fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Tip Read more in queries documentation fields","title":"fields"},{"location":"relations/queryset-proxy/#exclude_fields","text":"exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. Tip Read more in queries documentation exclude_fields","title":"exclude_fields"},{"location":"relations/queryset-proxy/#aggregated-functions","text":"","title":"Aggregated functions"},{"location":"relations/queryset-proxy/#count","text":"count() -> int Returns number of rows matching the given criteria (i.e. applied with filter and exclude) Tip Read more in queries documentation count","title":"count"},{"location":"relations/queryset-proxy/#exists","text":"exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude) Tip Read more in queries documentation exists","title":"exists"}]}